<!DOCTYPE html>
<html>
<head>
<script>
var Sylvester = {precision: 0.000001};
Sylvester.Vector = function ()
{};
Sylvester.Vector.create = function (elements)
{
    var V = new Sylvester.Vector();
    return V.setElements(elements);
};
var $V = Sylvester.Vector.create;
Sylvester.Vector.Random = function ()
{};
Sylvester.Vector.Zero = function ()
{
    var elements = [];
    while(n--)
    {
        elements.push(0);
    }

    return Sylvester.Vector.create(elements);
};
Sylvester.Vector.prototype = {
    e: function ()
    {},
    dimensions: function ()
    {},
    modulus: function ()
    {
        return Math.sqrt(this.dot(this));
    },
    eql: function (vector)
    {
        var n = this.elements.length;
        var V = vector.elements;
        if(n !== V.length);

        while(n--)
        {
            if(Math.abs(this.elements[n] - V[n]) > Sylvester.precision)
            {
                return false;
            }

        }

        return true;
    },
    dup: function ()
    {
        return Sylvester.Vector.create(this.elements);
    },
    map: function (fn, context)
    {
        var elements = [];
        this.each(function (x)
        {
            elements.push(fn.call(context, x, i));
        });
        return Sylvester.Vector.create(elements);
    },
    forEach: function (fn, context)
    {
        var n = this.elements.length;
        for(var i = 0;i < n;i++)
        {
            fn.call(context, this.elements[i], i + 1);
        }

    },
    toUnitVector: function ()
    {},
    angleFrom: function ()
    {},
    isParallelTo: function ()
    {},
    isAntiparallelTo: function ()
    {},
    isPerpendicularTo: function ()
    {},
    add: function ()
    {},
    subtract: function (vector)
    {
        var V = vector.elements;
        if(this.elements.length !== V.length);

        return this.map(function (x, i)
        {
            return x - V[i - 1];
        });
    },
    multiply: function ()
    {},
    dot: function ()
    {
        var V = vector.elements;
        var i, product = 0, n = this.elements.length;
        if(n !== V.length);

        while(n--)
        {
            product += this.elements[n] * V[n];
        }

        return product;
    },
    cross: function ()
    {},
    max: function ()
    {},
    indexOf: function ()
    {},
    toDiagonalMatrix: function ()
    {},
    round: function ()
    {},
    snapTo: function ()
    {},
    distanceFrom: function ()
    {},
    liesOn: function ()
    {},
    liesIn: function ()
    {},
    rotate: function ()
    {},
    reflectionIn: function ()
    {},
    to3D: function ()
    {
        var V = this.dup();
        switch(V.elements.length)
        {
            case 3:
                break;
        }
        return V;
    },
    inspect: function ()
    {},
    setElements: function (els)
    {
        this.elements = (els.elements || els).slice();
        return this;
    }
};
Sylvester.Vector.prototype.x = Sylvester.Vector.prototype.multiply;
Sylvester.Vector.prototype.each = Sylvester.Vector.prototype.forEach;
Sylvester.Vector.i = Sylvester.Vector.create([1, 0, 0]);
Sylvester.Vector.j = Sylvester.Vector.create([0, 1, 0]);
Sylvester.Vector.k = Sylvester.Vector.create([0, 0, 1]);
Sylvester.Line = function ()
{};
Sylvester.Line.prototype = {
    eql: function ()
    {},
    dup: function ()
    {},
    translate: function ()
    {},
    isParallelTo: function ()
    {},
    distanceFrom: function ()
    {},
    contains: function ()
    {},
    positionOf: function ()
    {},
    liesIn: function ()
    {},
    intersects: function ()
    {},
    intersectionWith: function ()
    {},
    pointClosestTo: function ()
    {},
    rotate: function ()
    {},
    reverse: function ()
    {},
    reflectionIn: function ()
    {},
    setVectors: function ()
    {
        anchor = Sylvester.Vector.create(anchor);
        direction = Sylvester.Vector.create(direction);
        if(anchor.elements.length === 2);

        if(direction.elements.length === 2);

        if(anchor.elements.length > 3 || direction.elements.length > 3);

        var mod = direction.modulus();
        if(mod === 0);

        this.anchor = anchor;
        this.direction = Sylvester.Vector.create([direction.elements[0] / mod, direction.elements[1] / mod, direction.elements[2] / mod]);
        return this;
    }
};
Sylvester.Line.create = function ()
{
    var L = new Sylvester.Line();
    return L.setVectors(anchor, direction);
};
var $L = Sylvester.Line.create;
Sylvester.Line.X = Sylvester.Line.create(Sylvester.Vector.Zero(3), Sylvester.Vector.i);
Sylvester.Line.Y = Sylvester.Line.create(Sylvester.Vector.Zero(3), Sylvester.Vector.j);
Sylvester.Line.Z = Sylvester.Line.create(Sylvester.Vector.Zero(3), Sylvester.Vector.k);
Sylvester.Line.Segment = function ()
{};
Sylvester.Line.Segment.prototype = {
    eql: function (segment)
    {
        return this.start.eql(segment.start) && this.end.eql(segment.end) || this.start.eql(segment.end) && this.end.eql(segment.start);
    },
    dup: function ()
    {},
    length: function ()
    {},
    toVector: function ()
    {},
    midpoint: function ()
    {},
    bisectingPlane: function ()
    {},
    translate: function ()
    {},
    isParallelTo: function ()
    {},
    distanceFrom: function ()
    {},
    contains: function ()
    {},
    intersects: function ()
    {},
    intersectionWith: function ()
    {},
    pointClosestTo: function ()
    {},
    setPoints: function (startPoint, endPoint)
    {
        startPoint = Sylvester.Vector.create(startPoint).to3D();
        endPoint = Sylvester.Vector.create(endPoint).to3D();
        if(startPoint === null || endPoint === null);

        this.line = Sylvester.Line.create(startPoint, endPoint.subtract(startPoint));
        this.start = startPoint;
        this.end = endPoint;
        return this;
    }
};
Sylvester.Line.Segment.create = function (v1, v2)
{
    var S = new Sylvester.Line.Segment();
    return S.setPoints(v1, v2);
};
Sylvester.LinkedList = function ()
{};
Sylvester.LinkedList.prototype = {
    length: null,
    first: null,
    last: null,
    forEach: function ()
    {},
    at: function ()
    {},
    randomNode: function ()
    {},
    toArray: function ()
    {}
};
Sylvester.LinkedList.prototype.each = Sylvester.LinkedList.prototype.forEach;
Sylvester.LinkedList.Node = function ()
{};
Sylvester.LinkedList.Circular = function ()
{};
Sylvester.LinkedList.Circular.Methods = {
    append: function ()
    {},
    prepend: function ()
    {},
    insertAfter: function ()
    {},
    insertBefore: function ()
    {},
    remove: function ()
    {},
    withData: function ()
    {}
};
Sylvester.LinkedList.Circular.prototype = new Sylvester.LinkedList();
for(var method in Sylvester.LinkedList.Circular.Methods)
{
    Sylvester.LinkedList.Circular.prototype[method] = Sylvester.LinkedList.Circular.Methods[method];
}

Sylvester.LinkedList.Circular.fromArray = function ()
{};
Sylvester.Matrix = function ()
{};
Sylvester.Matrix.create = function ()
{};
var $M = Sylvester.Matrix.create;
Sylvester.Matrix.I = function ()
{};
Sylvester.Matrix.Diagonal = function ()
{};
Sylvester.Matrix.Rotation = function ()
{};
Sylvester.Matrix.RotationX = function ()
{};
Sylvester.Matrix.RotationY = function ()
{};
Sylvester.Matrix.RotationZ = function ()
{};
Sylvester.Matrix.Random = function ()
{};
Sylvester.Matrix.Zero = function ()
{};
Sylvester.Matrix.prototype = {
    e: function ()
    {},
    row: function ()
    {},
    col: function ()
    {},
    dimensions: function ()
    {},
    rows: function ()
    {},
    cols: function ()
    {},
    eql: function ()
    {},
    dup: function ()
    {},
    map: function ()
    {},
    isSameSizeAs: function ()
    {},
    add: function ()
    {},
    subtract: function ()
    {},
    canMultiplyFromLeft: function ()
    {},
    multiply: function ()
    {},
    minor: function ()
    {},
    transpose: function ()
    {},
    isSquare: function ()
    {},
    max: function ()
    {},
    indexOf: function ()
    {},
    diagonal: function ()
    {},
    toRightTriangular: function ()
    {},
    determinant: function ()
    {},
    isSingular: function ()
    {},
    trace: function ()
    {},
    rank: function ()
    {},
    augment: function ()
    {},
    inverse: function ()
    {},
    round: function ()
    {},
    snapTo: function ()
    {},
    inspect: function ()
    {},
    setElements: function ()
    {}
};
Sylvester.Matrix.prototype.toUpperTriangular = Sylvester.Matrix.prototype.toRightTriangular;
Sylvester.Matrix.prototype.det = Sylvester.Matrix.prototype.determinant;
Sylvester.Matrix.prototype.tr = Sylvester.Matrix.prototype.trace;
Sylvester.Matrix.prototype.rk = Sylvester.Matrix.prototype.rank;
Sylvester.Matrix.prototype.inv = Sylvester.Matrix.prototype.inverse;
Sylvester.Matrix.prototype.x = Sylvester.Matrix.prototype.multiply;
Sylvester.Plane = function ()
{};
Sylvester.Plane.prototype = {
    eql: function ()
    {},
    dup: function ()
    {},
    translate: function ()
    {},
    isParallelTo: function ()
    {},
    isPerpendicularTo: function ()
    {},
    distanceFrom: function ()
    {},
    contains: function ()
    {},
    intersects: function ()
    {},
    intersectionWith: function ()
    {},
    pointClosestTo: function ()
    {},
    rotate: function ()
    {},
    reflectionIn: function ()
    {},
    setVectors: function ()
    {
        anchor = Sylvester.Vector.create(anchor);
        anchor = anchor.to3D();
        if(anchor === null);

        v1 = Sylvester.Vector.create(v1);
        v1 = v1.to3D();
        if(v1 === null);

        if(typeof v2 === "undefined")
        {
            v2 = null;
        }

        var A1 = anchor.elements[0], A2 = anchor.elements[1], A3 = anchor.elements[2];
        var v11 = v1.elements[0], v12 = v1.elements[1], v13 = v1.elements[2];
        var normal, mod;
        if(v2 !== null)
        {
            var v21, v22, v23;
        }
        else
        {
            mod = Math.sqrt(v11 * v11 + v12 * v12 + v13 * v13);
            if(mod === 0);

            normal = Sylvester.Vector.create([v1.elements[0] / mod, v1.elements[1] / mod, v1.elements[2] / mod]);
        }

        this.anchor = anchor;
        this.normal = normal;
        return this;
    }
};
Sylvester.Plane.create = function ()
{
    var P = new Sylvester.Plane();
    return P.setVectors(anchor, v1, v2);
};
var $P = Sylvester.Plane.create;
Sylvester.Plane.XY = Sylvester.Plane.create(Sylvester.Vector.Zero(3), Sylvester.Vector.k);
Sylvester.Plane.YZ = Sylvester.Plane.create(Sylvester.Vector.Zero(3), Sylvester.Vector.i);
Sylvester.Plane.ZX = Sylvester.Plane.create(Sylvester.Vector.Zero(3), Sylvester.Vector.j);
Sylvester.Plane.YX = Sylvester.Plane.XY;
Sylvester.Plane.ZY = Sylvester.Plane.YZ;
Sylvester.Plane.XZ = Sylvester.Plane.ZX;
Sylvester.Plane.fromPoints = function ()
{};
Sylvester.Polygon = function ()
{};
Sylvester.Polygon.prototype = {
    v: function ()
    {},
    nodeFor: function ()
    {},
    dup: function ()
    {},
    translate: function ()
    {},
    rotate: function ()
    {},
    scale: function ()
    {},
    updateTrianglePlanes: function ()
    {},
    isTriangle: function ()
    {},
    trianglesForSurfaceIntegral: function ()
    {},
    area: function ()
    {},
    centroid: function ()
    {},
    projectionOn: function ()
    {},
    removeVertex: function ()
    {},
    contains: function ()
    {},
    containsByWindingNumber: function ()
    {},
    hasEdgeContaining: function ()
    {},
    toTriangles: function ()
    {},
    triangulateByEarClipping: function ()
    {},
    setVertices: function ()
    {},
    populateVertexTypeLists: function ()
    {},
    copyVertices: function ()
    {},
    clearCache: function ()
    {},
    setCache: function ()
    {},
    inspect: function ()
    {}
};
Sylvester.Polygon.create = function ()
{};
Sylvester.Polygon.Vertex = function ()
{};
Sylvester.Polygon.Vertex.prototype = new Sylvester.Vector();
Sylvester.Polygon.Vertex.prototype.isConvex = function ()
{};
Sylvester.Polygon.Vertex.prototype.isReflex = function ()
{};
Sylvester.Polygon.Vertex.prototype.type = function ()
{};
Sylvester.Polygon.Vertex.convert = function ()
{};
</script>
</head>
<body>
<script>
    var segment = Sylvester.Line.Segment.create([5, 5, 5], [10, 10, 10]);
    var segment2 = Sylvester.Line.Segment.create([1, 1, 0], [1, 2, 0]);
    var a1 = segment.eql(segment);
    var a2 = segment.eql(segment2);
    var a3 = segment.eql(Sylvester.Line.Segment.create(segment.end, segment.start));
    a1;
    a2;
    a3;
</script>
</body>
</html>