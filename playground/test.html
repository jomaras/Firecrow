<!DOCTYPE html>

<html>

<head>

<script>

var Sylvester = {precision: 0.000001};

Sylvester.Vector = function ()

{};

Sylvester.Vector.create = function (elements)

{

    var V = new Sylvester.Vector();

    return V.setElements(elements);

};

Sylvester.Vector.Zero = function (n)

{

    var elements = [];

    while(n--)

    {

        elements.push(0);

    }



    return Sylvester.Vector.create(elements);

};

Sylvester.Vector.prototype = {

    modulus: function ()

    {

        return Math.sqrt(this.dot(this));

    },

    eql: function (vector)

    {

        var n = this.elements.length;

        var V = vector.elements || vector;

        if(n !== V.length);



        while(n--)

        {

            if(Math.abs(this.elements[n] - V[n]) > Sylvester.precision)

            {

                return false;

            }



        }



        return true;

    },

    dup: function ()

    {

        return Sylvester.Vector.create(this.elements);

    },

    map: function (fn, context)

    {

        var elements = [];

        this.each(function (x, i)

        {

            elements.push(fn.call(context, x, i));

        });

        return Sylvester.Vector.create(elements);

    },

    forEach: function (fn, context)

    {

        var n = this.elements.length;

        for(var i = 0;i < n;i++)

        {

            fn.call(context, this.elements[i], i + 1);

        }



    },

    toUnitVector: function ()

    {

        var r = this.modulus();

        if(r === 0);



        return this.map(function (x)

        {

            return x / r;

        });

    },

    angleFrom: function (vector)

    {

        var V = vector.elements;

        var n = this.elements.length;

        if(n !== V.length);



        var dot = 0, mod1 = 0, mod2 = 0;

        this.each(function (x, i)

        {

            dot += x * V[i - 1];

            mod1 += x * x;

            mod2 += V[i - 1] * V[i - 1];

        });

        mod1 = Math.sqrt(mod1);

        mod2 = Math.sqrt(mod2);

        var theta = dot / (mod1 * mod2);

        return Math.acos(theta);

    },

    isAntiparallelTo: function (vector)

    {

        var angle = this.angleFrom(vector);

        return angle === null ? 0 : Math.abs(angle - Math.PI) <= Sylvester.precision;

    },

    isPerpendicularTo: function (vector)

    {

        var dot = this.dot(vector);

        return dot === null ? 0 : Math.abs(dot) <= Sylvester.precision;

    },

    subtract: function (vector)

    {

        var V = vector.elements;

        if(this.elements.length !== V.length);



        return this.map(function (x, i)

        {

            return x - V[i - 1];

        });

    },

    dot: function (vector)

    {

        var V = vector.elements;

        var product = 0, n = this.elements.length;

        if(n !== V.length);



        while(n--)

        {

            product += this.elements[n] * V[n];

        }



        return product;

    },

    cross: function (vector)

    {

        var B = vector.elements;

        if(this.elements.length !== 3 || B.length !== 3);



        var A = this.elements;

        return Sylvester.Vector.create([(A[1] * B[2]) - (A[2] * B[1]), (A[2] * B[0]) - (A[0] * B[2]), (A[0] * B[1]) - (A[1] * B[0])]);

    },

    to3D: function ()

    {

        var V = this.dup();

        switch(V.elements.length)

        {

            case 3:

                break;

            case 2:

                V.elements.push(0);

                break;

        }

        return V;

    },

    setElements: function (els)

    {

        this.elements = (els.elements || els).slice();

        return this;

    }

};

Sylvester.Vector.prototype.each = Sylvester.Vector.prototype.forEach;

Sylvester.Vector.i = Sylvester.Vector.create([1, 0, 0]);

Sylvester.Vector.j = Sylvester.Vector.create([0, 1, 0]);

Sylvester.Vector.k = Sylvester.Vector.create([0, 0, 1]);

Sylvester.Line = function ()

{};

Sylvester.Line.prototype = {

    isParallelTo: function (obj)

    {

        if(obj.normal || obj.start);



        var theta = this.direction.angleFrom(obj.direction);

        return Math.abs(theta) <= Sylvester.precision || Math.abs(theta - Math.PI) <= Sylvester.precision;

    },

    distanceFrom: function (obj)

    {

        if(obj.normal || obj.start);



        if(obj.direction)

        {

            var N = this.direction.cross(obj.direction).toUnitVector().elements;

            var A = this.anchor.elements, B = obj.anchor.elements;

            return Math.abs((((A[0] - B[0]) * N[0]) + ((A[1] - B[1]) * N[1])) + ((A[2] - B[2]) * N[2]));

        }

        else

        {

            var P = obj.elements || obj;

            var A = this.anchor.elements, D = this.direction.elements;

            var PA1 = P[0] - A[0], PA2 = P[1] - A[1], PA3 = (P[2] || 0) - A[2];

            var modPA = Math.sqrt(((PA1 * PA1) + (PA2 * PA2)) + (PA3 * PA3));

            var cosTheta = (((PA1 * D[0]) + (PA2 * D[1])) + (PA3 * D[2])) / modPA;

            var sin2 = 1 - (cosTheta * cosTheta);

            return Math.abs(modPA * Math.sqrt(sin2 < 0 ? 0 : sin2));

        }



    },

    contains: function (obj)

    {

        if(obj.start);



        var dist = this.distanceFrom(obj);

        return dist !== null && dist <= Sylvester.precision;

    },

    positionOf: function (point)

    {

        if(!this.contains(point));



        var P = point.elements;

        var A = this.anchor.elements, D = this.direction.elements;

        return (((P[0] - A[0]) * D[0]) + ((P[1] - A[1]) * D[1])) + (((P[2] || 0) - A[2]) * D[2]);

    },

    intersects: function (obj)

    {

        if(obj.normal);



        return !this.isParallelTo(obj) && this.distanceFrom(obj) <= Sylvester.precision;

    },

    intersectionWith: function (obj)

    {

        if(!this.intersects(obj));



        var P = this.anchor.elements, X = this.direction.elements, Q = obj.anchor.elements, Y = obj.direction.elements;

        var X1 = X[0], X2 = X[1], X3 = X[2], Y1 = Y[0], Y2 = Y[1], Y3 = Y[2];

        var PsubQ1 = P[0] - Q[0], PsubQ2 = P[1] - Q[1], PsubQ3 = P[2] - Q[2];

        var XdotQsubP = ((-X1 * PsubQ1) - (X2 * PsubQ2)) - (X3 * PsubQ3);

        var YdotPsubQ = ((Y1 * PsubQ1) + (Y2 * PsubQ2)) + (Y3 * PsubQ3);

        var XdotX = ((X1 * X1) + (X2 * X2)) + (X3 * X3);

        var YdotY = ((Y1 * Y1) + (Y2 * Y2)) + (Y3 * Y3);

        var XdotY = ((X1 * Y1) + (X2 * Y2)) + (X3 * Y3);

        var k = (((XdotQsubP * YdotY) / XdotX) + (XdotY * YdotPsubQ)) / (YdotY - (XdotY * XdotY));

        return Sylvester.Vector.create([P[0] + (k * X1), P[1] + (k * X2), P[2] + (k * X3)]);

    },

    pointClosestTo: function (obj)

    {

        if(obj.start && obj.end)

        {

            var P = obj.pointClosestTo(this);

            return P === null ? 0 : this.pointClosestTo(P);

        }

        else if(obj.direction)

        {

            if(this.intersects(obj))

            {

                return this.intersectionWith(obj);

            }



            if(this.isParallelTo(obj));



            var D = this.direction.elements, E = obj.direction.elements;

            var D1 = D[0], D2 = D[1], D3 = D[2], E1 = E[0], E2 = E[1], E3 = E[2];

            var x = (D3 * E1) - (D1 * E3), y = (D1 * E2) - (D2 * E1), z = (D2 * E3) - (D3 * E2);

            var N = [(x * E3) - (y * E2), (y * E1) - (z * E3), (z * E2) - (x * E1)];

            var P = Sylvester.Plane.create(obj.anchor, N);

            return P.intersectionWith(this);

        }

        else

        {

            var P = obj.elements;

            if(this.contains(P));



            var A = this.anchor.elements, D = this.direction.elements;

            var D1 = D[0], D2 = D[1], D3 = D[2], A1 = A[0], A2 = A[1], A3 = A[2];

            var x = (D1 * (P[1] - A2)) - (D2 * (P[0] - A1)), y = (D2 * ((P[2] || 0) - A3)) - (D3 * (P[1] - A2)), z = (D3 * (P[0] - A1)) - (D1 * ((P[2] || 0) - A3));

            var V = Sylvester.Vector.create([(D2 * x) - (D3 * z), (D3 * y) - (D1 * x), (D1 * z) - (D2 * y)]);

            var k = this.distanceFrom(P) / V.modulus();

            return Sylvester.Vector.create([P[0] + (V.elements[0] * k), P[1] + (V.elements[1] * k), (P[2] || 0) + (V.elements[2] * k)]);

        }





    },

    setVectors: function (anchor, direction)

    {

        anchor = Sylvester.Vector.create(anchor);

        direction = Sylvester.Vector.create(direction);

        var mod = direction.modulus();

        if(mod === 0);



        this.anchor = anchor;

        this.direction = Sylvester.Vector.create([direction.elements[0] / mod, direction.elements[1] / mod, direction.elements[2] / mod]);

        return this;

    }

};

Sylvester.Line.create = function (anchor, direction)

{

    var L = new Sylvester.Line();

    return L.setVectors(anchor, direction);

};

var $L = Sylvester.Line.create;

Sylvester.Line.X = Sylvester.Line.create(Sylvester.Vector.Zero(3), Sylvester.Vector.i);

Sylvester.Line.Segment = function ()

{};

Sylvester.Line.Segment.prototype = {

    toVector: function ()

    {

        var A = this.start.elements, B = this.end.elements;

        return Sylvester.Vector.create([B[0] - A[0], B[1] - A[1], B[2] - A[2]]);

    },

    contains: function (obj)

    {

        var P = obj.elements.slice();

        if(P.length === 2);



        if(this.start.eql(P));



        var S = this.start.elements;

        var V = Sylvester.Vector.create([S[0] - P[0], S[1] - P[1], S[2] - (P[2] || 0)]);

        var vect = this.toVector();

        return V.isAntiparallelTo(vect) && V.modulus() <= vect.modulus();

    },

    pointClosestTo: function (obj)

    {

        if(obj.normal);

        else

        {

            var P = this.line.pointClosestTo(obj);

            if(P === null);



            if(this.contains(P))

            {

                return P;

            }



            return (this.line.positionOf(P) < 0 ? this.start : 0).dup();

        }



    },

    setPoints: function (startPoint, endPoint)

    {

        startPoint = Sylvester.Vector.create(startPoint).to3D();

        endPoint = Sylvester.Vector.create(endPoint).to3D();

        if(startPoint === null || endPoint === null);



        this.line = Sylvester.Line.create(startPoint, endPoint.subtract(startPoint));

        this.start = startPoint;

        this.end = endPoint;

        return this;

    }

};

Sylvester.Line.Segment.create = function (v1, v2)

{

    var S = new Sylvester.Line.Segment();

    return S.setPoints(v1, v2);

};

Sylvester.Plane = function ()

{};

Sylvester.Plane.prototype = {

    isParallelTo: function (obj)

    {

        if(false);

        else if(obj.direction)

        {

            return this.normal.isPerpendicularTo(obj.direction);

        }





    },

    intersects: function (obj)

    {

        if(typeof obj.direction === "undefined");



        return !this.isParallelTo(obj);

    },

    intersectionWith: function (obj)

    {

        if(!this.intersects(obj));



        if(obj.direction)

        {

            var A = obj.anchor.elements, D = obj.direction.elements, P = this.anchor.elements, N = this.normal.elements;

            var multiplier = (((N[0] * (P[0] - A[0])) + (N[1] * (P[1] - A[1]))) + (N[2] * (P[2] - A[2]))) / (((N[0] * D[0]) + (N[1] * D[1])) + (N[2] * D[2]));

            return Sylvester.Vector.create([A[0] + (D[0] * multiplier), A[1] + (D[1] * multiplier), A[2] + (D[2] * multiplier)]);

        }



    },

    setVectors: function (anchor, v1, v2)

    {

        anchor = Sylvester.Vector.create(anchor);

        anchor = anchor.to3D();

        if(anchor === null);



        v1 = Sylvester.Vector.create(v1);

        v1 = v1.to3D();

        if(v1 === null);



        if(typeof v2 === "undefined")

        {

            v2 = null;

        }



        var v11 = v1.elements[0], v12 = v1.elements[1], v13 = v1.elements[2];

        var normal, mod;

        if(v2 !== null);

        else

        {

            mod = Math.sqrt(((v11 * v11) + (v12 * v12)) + (v13 * v13));

            if(mod === 0);



            normal = Sylvester.Vector.create([v1.elements[0] / mod, v1.elements[1] / mod, v1.elements[2] / mod]);

        }



        this.anchor = anchor;

        this.normal = normal;

        return this;

    }

};

Sylvester.Plane.create = function (anchor, v1, v2)

{

    var P = new Sylvester.Plane();

    return P.setVectors(anchor, v1, v2);

};

Sylvester.Plane.create(Sylvester.Vector.Zero(3), Sylvester.Vector.k);

Sylvester.Plane.create(Sylvester.Vector.Zero(3), Sylvester.Vector.i);

Sylvester.Plane.create(Sylvester.Vector.Zero(3), Sylvester.Vector.j);

</script>

</head>

<body>

<script>

    var Line = Sylvester.Line;

    var a1 = Line.X.pointClosestTo(Sylvester.Vector.create([26, -2, 18])).eql([26, 0, 0]);

    var a2 = $L([0, 0, 0], [1, 0, 0]).pointClosestTo($L([0, 0, 24], [1, 1, 0])).eql([0, 0, 0]);

    var a3 = $L([0, 0, 24], [1, 1, 0]).pointClosestTo($L([0, 0, 0], [-1, 0, 0])).eql([0, 0, 24]);

    var a4 = Line.X.pointClosestTo(Line.Segment.create([3, 5], [9, 9])).eql([3, 0, 0]);

    var a5 = Line.X.pointClosestTo(Line.Segment.create([2, -2, 2], [4, 2, 2])).eql([3, 0, 0]);

    a1;

    a2;

    a3;

    a4;

    a5;

</script>

</body>

</html>