var EXPORTED_SYMBOLS = ["Firecrow"];
/*Just for the intellisense*/
if(typeof FBL === "undefined")
{
    FBL =  { ns:  function(namespaceFunction){ namespaceFunction(); }};
}
/*End just for intellisense*/

FBL.ns(function () { with (FBL)
{
    FBL.Firecrow =
    {
        DependencyGraph:
        {
            DependencyGraph: {},
            Node: {},
            Edge: {}
        },
        DoppelBrowser :
        {
            Browser: {},
            WebFile: {}
        },
        Interpreter:
        {
            Commands : {},
            InterpreterSimulator: {},
            Model:
            {
                Internals: {}
            },
            Internals: {},
            Simulator: {}
        },
        ScenarioGenerator: {
            Symbolic: {}
        },
        IsDebugMode: true,

        getWindow: function() { return frames[0] || window;},
        getDocument: function() { return this.getWindow().document; },
        postProcessorInclusions: {},

        includeNode: function(node, isIncludedByPostprocessor, dependencyIndex, dependencyConstraint)
        {
            if(isIncludedByPostprocessor && !node.shouldBeIncluded)
            {
                node.isIncludedByPostprocessor = isIncludedByPostprocessor;
                this.postProcessorInclusions[node.nodeId] = 1;
            }
            //if(node != null && node.loc != null && node.loc.start.line == 8152) debugger;
            //if(node.nodeId == 30) debugger;
            node.shouldBeIncluded = true;

            if(node.maxIncludedByDependencyIndex == null) { node.maxIncludedByDependencyIndex = dependencyIndex; }
            else if(node.maxIncludedByDependencyIndex < dependencyIndex) { node.maxIncludedByDependencyIndex = dependencyIndex ; }

            if(node.minIncludedByDependencyIndex == null) { node.minIncludedByDependencyIndex = dependencyIndex; }
            else if(node.minIncludedByDependencyIndex > dependencyIndex) { node.minIncludedByDependencyIndex = dependencyIndex ; }

            //TODO - sort on insertion
            if(dependencyIndex != null)
            {
                node.includedByDependencies = node.includedByDependencies || [];
                node.includedByDependencies.push(dependencyIndex);
            }

            if(dependencyConstraint != null)
            {
                node.includedConstraints = node.includedConstraints || [];
                node.includedConstraints.push(dependencyConstraint);
            }
        },

        INTERNAL_PROTOTYPE_FUNCTIONS:
        {
            Array:
            {
                concat: Array.concat, every: Array.every, forEach: Array.forEach,
                indexOf: Array.indexOf, join: Array.join, map: Array.map,
                pop: Array.pop, push: Array.push, reduce: Array.reduce,
                reduceRight: Array.reduceRight, reverse: Array.reverse,
                reverse: Array.reverse, shift: Array.shift, some: Array.some,
                sort: Array.sort, splice: Array.splice, unshift: Array.unshift
            },
            String:
            {
                camelCase: String.camelCase, capitalize: String.capitalize, charAt: String.charAt, charCodeAt: String.charAt,
                clean: String.clean, concat: String.concat, contains: String.contains, escapeRegExp: String.escapeRegExp,
                hyphenate: String.hyphenate, lastIndexOf: String.lastIndexOf, localeCompare: String.localeCompare, match: String.match,
                replace: String.replace, replace: String.replace, search: String.search, slice: String.slice,
                sub: String.sub, substitute: String.substitute, substr: String.substr, substring: String.substring, toFloat: String.toFloat,
                toInt: String.toInt, toLocaleLowerCase: String.toLocaleLowerCase, toLocaleString: String.toLocaleString,
                toLocaleUpperCase: String.toLocaleUpperCase, toLowerCase: String.toLowerCase, toUpperCase: String.toUpperCase, trim: String.trim,
                trimLeft: String.trimLeft, trimRight: String.trimRight, fromCharCode: String.fromCharCode
            }
        },

        IGNORED_SCRIPTS:
        [
            "google-analytics.com/ga.js",
            "twitter",
            "stumbleupon",
            "facebook",
            "linkedin",
            "apis.google.com",
            "widgets.dzone.com",
        ],

        isIgnoredScript: function(path)
        {
            if(path == null) { return false; }

            for(var i = 0; i < this.IGNORED_SCRIPTS.length; i++)
            {
                if(path.indexOf(this.IGNORED_SCRIPTS[i]) != -1) { return true; }
            }

            return false;
        }
    };
}});
var Firecrow = FBL.Firecrow;var usesModule = typeof module !== 'undefined' && module.exports
if(usesModule)
{
    FBL =  { Firecrow: {}, ns:  function(namespaceFunction){ namespaceFunction(); }};
}

FBL.ns(function () { with (FBL) {
/*************************************************************/
Firecrow.ValueTypeHelper =
{
    expand: function(base, expander)
    {
        if(base == null || expander == null) { return; }

        for(var prop in expander)
        {
            base[prop] = expander[prop];
        }
    },

    objectHasProperties: function(object)
    {
        if(object == null) { return false; }

        for(var prop in object)
        {
            return true;
        }

        return false;
    },

    getHighestIndexProperty: function(object)
    {
        if(object == null) { return null; }

        var highestIndex = Number.NEGATIVE_INFINITY;

        for(var prop in object)
        {
            if(this.isStringInteger(prop) || this.isInteger(prop))
            {
                var number = prop * 1;

                if(number > highestIndex)
                {
                    highestIndex = number;
                }
            }
        }

        if(highestIndex == Number.NEGATIVE_INFINITY) { return null; }

        return highestIndex;
    },

    isOfType: function (variable, className)
    {
        return variable instanceof className;
    },

    isOneOfTypes: function(variable, classNames)
    {
        for(var i = 0, length = classNames.length; i < length; i++)
        {
            if(this.isOfType(variable, classNames[i]))
            {
                return true;
            }
        }

        return false;
    },

    isPrimitive: function(variable)
    {
        return typeof variable == "undefined" || typeof variable == "number"
            || typeof variable == "string" || typeof variable == "boolean"
            || variable == null;
    },

    arePrimitive: function()
    {
        if(arguments.length == 0) { return false; }

        for(var i = 0; i < arguments.length; i++)
        {
            if(!this.isPrimitive(arguments[i]))
            {
                return false;
            }
        }

        return true;
    },

    isFunction: function(variable)
    {
        return this.isOfType(variable, Function) || (typeof variable == "function");
    },

    isRegExp: function(variable)
    {
        if(variable == null) { return false; }

        return variable instanceof RegExp || (variable.constructor && variable.constructor.name == "RegExp");
    },

    isXMLHttpRequest: function(variable)
    {
        if(variable == null) { return false; }

        return variable instanceof XMLHttpRequest || (variable.constructor && variable.constructor.name == "XMLHttpRequest");
    },

    isBoolean: function(variable)
    {
        if (this.isNull(variable)) { return false; }

        return typeof(variable) == "boolean";
    },

    isString: function (variable)
    {
        if (this.isNull(variable)) { return false; }

        return (typeof variable) == "string" || variable instanceof String;
    },

    isNumber: function(variable)
    {
        if (this.isNull(variable)) { return false; }

        return (typeof variable) == "number";
    },

    isInteger: function (variable)
    {
        if (this.isNull(variable)) { return false; }

        return (typeof variable) == "number" && variable == parseInt(variable,10);
    },

    isStringInteger: function(variable)
    {
        if (this.isNull(variable)) { return false; }

        return variable == parseInt(variable,10);
    },

    isNull: function (variable)
    {
        return variable === null;
    },

    isObject: function(potentialObject)
    {
        if(potentialObject == null) { return false; }

        return 'object' == typeof potentialObject;
    },

    isEmptyObject: function(object)
    {
        if(object == null) { return false; }

        for(var prop in object)
        {
            if(object.hasOwnProperty(prop)) { return false; }
        }

        return true;
    },

    isArray: function (arrayOfElements)
    {
        if (this.isNull(arrayOfElements)) { return false; }

        var result = (typeof arrayOfElements) == "array" || arrayOfElements instanceof Array;

        if(result) { return true; }

        if(Array != null && Array.isArray != null) { return Array.isArray(arrayOfElements); }

        return result;
    },

    isArrayLike: function(arrayLike)
    {
        if(arrayLike == null || arrayLike.length === null || arrayLike.length === undefined) { return false; }

        return !this.isString(arrayLike);
    },

    isArrayOf: function (arrayOfElements, type)
    {
        if (!this.isArray(arrayOfElements)) { return false; }

        for (var i = 0; i < arrayOfElements.length; i++)
        {
            if (!this.isOfType(arrayOfElements[i], type)) { return false; }
        }

        return true;
    },

    isStringArray: function(arrayOfElements)
    {
        if (!this.isArray(arrayOfElements)) { return false; }

        for (var i = 0; i < arrayOfElements.length; i++)
        {
            if (!this.isString(arrayOfElements[i])) { return false; }
        }

        return true;
    },

    isIntegerArray: function(arrayOfElements)
    {
        if (!this.isArray(arrayOfElements)) { return false; }

        for (var i = 0; i < arrayOfElements.length; i++)
        {
            if (!this.isInteger(arrayOfElements[i])) { return false; }
        }

        return true;
    },

    reverseArray: function(array)
    {
        if(array == null || array.length <= 1) { return; }

        var length = array.length;
        var halfLength = length/2;

        for(var i = 0; i < halfLength; i++)
        {
            var temp = array[i];
            array[i] = array[length - i - 1];
            array[length - i - 1] = temp;
        }
    },

    arrayContains: function(array, item)
    {
        for(var i = 0; i < array.length; i++)
        {
            if(array[i] === item) { return true; }
        }

        return false;
    },

    deepClone: function(object)
    {
        try
        {
            return JSON.parse(JSON.stringify(object));
        }
        catch(e) { alert("Error when deep cloning object:" + e);}
    },

    flattenArray: function(array)
    {
        var flattened = [];

        for(var i = 0; i < array.length; i++)
        {
            var item = array[i];

            this.isArray(item) ? this.pushAll(flattened, item)
                               : flattened.push(item);
        }

        return flattened;
    },

    getSubList: function(array, startIndex, endIndex)
    {
        var subList = [];

        for(var i = startIndex; i < endIndex; i++)
        {
            subList.push(array[i]);
        }

        return subList;
    },

    getArraySum: function(array)
    {
        var sum = 0;

        for(var i = 0; i < array.length; i++)
        {
            sum += array[i];
        }

        return sum;
    },

    getWithoutFirstElement: function(array)
    {
        var withoutFirst = [];

        for(var i = 1; i < array.length; i++)
        {
            withoutFirst.push(array[i]);
        }

        return withoutFirst;
    },

    getRandomElementFromArray: function(array)
    {
        if(array == null) { return null; }

        return array[this.getRandomInt(0, array.length)];
    },

    getRandomInt: function (min, max)
    {
        return Math.floor(Math.random() * (max - min)) + min;
    },

    cleanDuplicatesFromArray: function(array)
    {
        var cleansedArray = [];

        for(var i = 0; i < array.length; i++)
        {
            if(!this.arrayContains(cleansedArray, array[i]))
            {
                cleansedArray.push(array[i]);
            }
        }

        return cleansedArray;
    },

    sortArray: function(array)
    {
        for(var i = 0; i < array.length; i++)
        {
            for(var j = 0 ; j < array.length; j++)
            {
                if(array[i] < array[j])
                {
                    var temp = array[i];
                    array[i] = array[j];
                    array[j] = temp;
                }
            }
        }
        
        return array;   
    },

    createFilledIntArray: function(startIndex, endIndex)
    {
        var array = [];
		
		for(var currentNumber = startIndex; currentNumber <= endIndex; currentNumber++)
		{
			array.push(currentNumber);
		}
		
		return array;
    },

    removeAfter: function(string, character)
    {
        var index = string.indexOf(character);

        if(index >= 0)
        {
            return string.substr(0, index);
        }

        return string;
    },
    
    convertToArray: function(arrayLikeStructure)
    {
    	var array = [];
    	
    	for(var i = 0; i < arrayLikeStructure.length; i++)
    	{
    		array.push(arrayLikeStructure[i]);
    	}
    	
    	return array;
    },

    convertObjectMapToArray: function(object)
    {
        var array = [];

        for(var prop in object)
        {
            array.push(object[prop]);
        }

        return array;
    },

    convertObjectPropertyNamesToArray: function(object)
    {
        var array = [];

        for(var prop in object)
        {
            array.push(prop);
        }

        return array;
    },

    removeFromArrayByElement:function(array, element)
    {
        try
        {
            return this.removeFromArrayByIndex(array, array.indexOf(element));
        }
        catch(e) { alert("Error while removing elements from array by element: " + e);}
    },

    removeFromArrayByIndex:function(array, index)
    {
        try
        {
            if(index < 0 || index >= array.length) { debugger; alert("Index out of range when removing array in ValueTypeHelper"); return; }

            return array.splice(index, 1);
        }
        catch(e) { alert("Error while removing elements from array by index: " + e);}
    },

    getArraysIntersection: function(firstArray, secondArray)
    {
        if(firstArray == null || secondArray == null || firstArray.length == 0 || secondArray.length == 0) { return []; }

        var intersection = [];

        for(var i = 0; i < firstArray.length; i++)
        {
            for(var j = 0; j < secondArray.length; j++)
            {
                if(firstArray[i] == secondArray[j])
                {
                    intersection.push(firstArray[i]);
                }
            }
        }

        return intersection;
    },

    insertIntoStringAtPosition: function(baseString, insertionString, position)
    {
        if(baseString == "") { return insertionString; }
        if(insertionString == "") { return baseString; }

        return baseString.substr(0, position) + insertionString + baseString.substr(position);
    },

    insertIntoArrayAtIndex: function(array, element, index)
    {
      try
      {
          array.splice(index, 0, element);
      }
      catch(e) { alert("Error occured when inserting into array in ValueTypeHelper:" + e); }
    },

    insertElementsIntoArrayAtIndex: function(array, elements, index)
    {
        try
        {
            elements.forEach(function(element)
            {
                this.insertIntoArrayAtIndex(array, element, index++);
            }, this);
        }
        catch(e) { alert("Error when inserting elements into array: " + e);}
    },

    createArrayCopy: function(array)
    {
        try
        {
            if(array == null) { return []; }

            return array.slice();
        }
        catch(e) { alert("Error when Creating array copy - ValueTypeHelper:" + e);}
    },

    concatArray: function(firstArray, secondArray)
    {
        if(firstArray == null) { return secondArray; }
        if(secondArray == null) { return firstArray; }

        var joinedArray = [];

        for(var i = 0; i < firstArray.length; i++) { joinedArray.push(firstArray[i]); }
        for(var i = 0; i < secondArray.length; i++) { joinedArray.push(secondArray[i]); }

        return joinedArray;
    },

    pushAll: function(baseArray, arrayWithItems)
    {
        try
        {
            baseArray.push.apply(baseArray, arrayWithItems);
        }
        catch(e) { alert("Error while pushing all in ValueTypeHelper:" + e); }
    },

    findInArray: function(array, searchForItem, checkFunction)
    {
        try
        {
            for(var i = 0; i < array.length; i++)
            {
                var currentItem = array[i];

                if(checkFunction(currentItem, searchForItem))
                {
                    return currentItem;
                }
            }

            return null;
        }
        catch(e)
        {
            debugger;
            alert("ValueTypeHelper - Error while finding in array: " + e);
        }
    },

    clearArray: function(array)
    {
        for (var i = 0; i < array.length; i++)
        {
            if (array[i] == null)
            {
                array.splice(i, 1);
                i--;
            }
        }
    },
    
    trim: function(str, chars) 
    {
    	return this.trimLeft(this.trimRight(str, chars), chars);
    },
     
    trimLeft: function(str, chars) 
    {
    	chars = chars || "\\s";
    	return str.replace(new RegExp("^[" + chars + "]+", "g"), "");
    },
     
    trimRight: function(str, chars) 
    {
    	chars = chars || "\\s";
    	return str.replace(new RegExp("[" + chars + "]+$", "g"), "");
    },
    
    regexIndexOf: function(string, regex, startpos) 
    {
        var indexOf = string.substring(startpos || 0).search(regex);
        return (indexOf >= 0) ? (indexOf + (startpos || 0)) : indexOf;
    },

    //TODO - quickfixing the Firefox create RegEx from literal bug
    adjustForRegExBug: function(regExElement, regExString)
    {
        if(regExElement == null || regExElement.parent == null
        || regExElement.parent.loc == null || regExElement.parent.loc.source == null || regExElement.parent.loc.source.indexOf("medialize") == -1)
        {
            return regExString;
        }

        //IT seems that Firefox regEx functionality differs if it /someRegEx/gi or /someRegEx/ig -> bug, iritating bug
        //but in the parse tree it does not show //ig but //gi regardless of what is put
        //So if it is part of the medialize library that i'm testing do that replacement
        return regExString.replace(/\/gi$/, "/ig");
    },

    isHtmlElement: function(object)
    {
        if(object == null) { return false; }
        //It seems that Chrome creates new instances of HTML functions for each frame
        return object instanceof HTMLElement //works in Firefox
            || (object.nodeType == 1 && object.nodeName !== ""); //For Chrome
    },

    isDocumentFragment: function(object)
    {
        if(object == null) { return false; }

        return object instanceof DocumentFragment
            || (object.nodeType == 11 && object.nodeName !== "");
    },

    isImageElement: function(object)
    {
        if(object == null) { return false; }

        return object instanceof Image || object instanceof HTMLImageElement
            || (object.nodeType == 1 && object.nodeName === "IMG");
    },

    isCanvasElement: function(object)
    {
        if(object == null) { return false; }

        return object instanceof HTMLCanvasElement
            || (object.nodeType == 1 && object.nodeName === "CANVAS");
    },

    isScriptElement: function(object)
    {
        if(object == null) { return false; }

        return object instanceof HTMLScriptElement
            || (object.nodeType == 1 && object.nodeName === "SCRIPT");
    },

    isIFrameElement: function(object)
    {
        if(object == null) { return false; }

        return object instanceof HTMLScriptElement
            || (object.nodeType == 1 && object.nodeName === "IFRAME");
    },

    isTextNode: function(object)
    {
        if(object == null) { return false; }

        return object instanceof Text
            || (object.nodeType == 3 && object.nodeName !== "");
    },

    isComment: function(object)
    {
        if(object == null) { return false; }

        return object instanceof Text
            || (object.nodeType == 8 && object.nodeName !== "");
    },

    isDocument:function(object)
    {
        if(object == null) { return false; }

        return object instanceof Document
            || (object.nodeType == 9 && object.nodeName !== "");
    },

    isHtmlSelectElement: function (object)
    {
        if(object == null) { return false; }

        return object instanceof HTMLSelectElement
            || (object.nodeType == 1 && object.nodeName == "SELECT");
    },

    isHtmlInputElement: function(object)
    {
        if(object == null) { return false; }

        return object instanceof HTMLSelectElement
            || (object.nodeType == 1 && object.nodeName == "INPUT");
    },

    isHtmlTextAreaElement: function(object)
    {
        if(object == null) { return false; }

        return object instanceof HTMLTextAreaElement
            || (object.nodeType == 9 && object.nodeName == "TEXTAREA");
    },

    isHtmlFormElement: function(object)
    {
        if(object == null) { return false; }

        return object instanceof HTMLFormElement
           || (object.nodeType == 1 && object.nodeName == "FORM");
    }
};

//https://github.com/timgilbert/js-weighted-list/blob/master/js-weighted-list.js
/*  Example usage
 var data = [['a', 10], ['b',  1], ['c',  1], ['d',  5], ['e',  3]];
 var wl = new WeightedList(data); - in my case i would make the first element the index, and the second the probability
 var result = wl.peek();   // Ex: ['a']
 */
Firecrow.ValueTypeHelper.WeightedList = (function() {

    function _WeightedList(initial) {
        this.weights = {};
        this.data = {};
        this.length = 0;
        this.hasData = false;

        initial = typeof initial !== 'undefined' ? initial : [];

        if (Array.isArray(initial)) {
            for (var i = 0; i < initial.length; i++) {
                //var item = initial[i];
                //this.push(item[0], item[1], item[2]);
                this.push(initial[i]);
            }
        } else {
            throw new Error('Unknown object "' + initial.toString() + '" passed to ' +
                'WeightedList constructor! (Expected array or nothing)');
        }
    }

    _WeightedList.prototype = {
        /**
         * Add a single item to the list.  The parameter passed in represents a single
         * key, with a weight and optionally some data attached.
         *
         * The parameter to this function can either be a 2-3 element array of
         * [k, w, d] for key, weight and data (data is optional) or an object with the
         * values {'key': k, 'weight': w, 'data': d} where d is optional.
         */
        push: function(element) {
            var key, weight, data;

            if (Array.isArray(element)) {
                key = element[0], weight = element[1], data = element[2];
                if (typeof key === 'undefined') {
                    // Eg, wl.push([])
                    throw new Error('In WeightedList.push([ ... ]), need at least two elements');
                } else if (typeof weight === 'undefined') {
                    // I suppose we could default to 1 here, but the API is already too forgiving
                    throw new Error('In array passed to WeightedList.push([ ... ]), second ' +
                        'element is undefined!');
                }
            } else if (typeof element === 'object') {
                // We expect {"key": "zombies", "weight": 10, "data": {"fast": true}}
                key = element.key, weight = element.weight, data = element.data;
                if (typeof key === 'undefined') {
                    throw new Error("In WeightedList.push({ ... }), no {'key': 'xyzzy'} pair found");
                } else if (typeof weight === 'undefined') {
                    // I suppose we could default to 1 here, but the API is already too forgiving
                    throw new Error('In array passed to WeightedList.push({ ... }), no ' +
                        "{'weight': 42} pair found");
                }
            } else {
                // else what the heck were you trying to give me?
                throw new Error('WeightedList.push() passed unknown type "' + typeof element +
                    '", expected [key, weight] or {"key": k, "weight": w}');
            }
            return this._push_values(key, weight, data);

        },
        /**
         * Add an item to the list
         * @access private
         * @param {String} key the key under which this item is stored
         * @param {number} weight the weight to assign to this key
         * @param {?Object} data any optional data associated wth this key
         */
        _push_values: function(key, weight, data) {
            //console.debug('k:', key, 'w:', weight, 'd:', data);

            if (this.weights[key]) {
                throw new Error('');
            }
            if (typeof weight !== typeof 1) {
                throw new Error('Weight must be numeric (got ' + weight.toString() + ')');
            }
            if (weight <= 0)  {
                throw new Error('Weight must be >= 0 (got ' + weight + ')');
            }

            this.weights[key] = weight;

            if (typeof data !== 'undefined') {
                this.hasData = true;
                this.data[key] = data;
            }
            this.length++;
        },

        /**
         * Add the given weight to the list item with the given key.  Note that if
         * the key does not already exist, this operation will silently create it.
         *
         * @todo might be nice to have a version of this that would throw an error
         *       on an unknown key.
         */
        addWeight: function(key, weight) {
            this.weights[key] += weight;
        },

        /**
         * Select n random elements (without replacement), default 1.
         * If andRemove is true (default false), remove the elements
         * from the list.  (This is what the pop() method does.)
         */
        peek: function(n, andRemove) {
            if (typeof n === 'undefined') {
                n = 1;
            }
            andRemove = !!andRemove;

            if (this.length - n < 0) {
                throw new Error('Stack underflow! Tried to retrieve ' + n +
                    ' element' + (n === 1 ? '' : 's') +
                    ' from a list of ' + this.length);
            }

            var heap = this._buildWeightedHeap();
            //console.debug('heap:', heap);
            var result = [];

            for (var i = 0; i < n; i++) {
                var key = heap.pop();
                //console.debug('k:', key);
                if (this.hasData) {
                    result.push({key: key, data: this.data[key]});
                } else {
                    result.push(key);
                }
                if (andRemove) {
                    delete this.weights[key];
                    delete this.data[key];
                    this.length--;
                }
            }
            return result;
        },

        /**
         * Return the entire list in a random order (note that this does not mutate the list)
         */
        shuffle: function() {
            return this.peek(this.length);
        },

        /**
         *
         */
        pop: function(n) {
            return this.peek(n, true);
        },

        /**
         * Build a WeightedHeap instance based on the data we've got
         */
        _buildWeightedHeap: function() {
            var items = [];
            for (var key in this.weights) if (this.weights.hasOwnProperty(key)) {
                items.push([key, this.weights[key]]);
            }
            //console.log('items',items);
            return new _WeightedHeap(items);
        }
    };

    /**
     * This is a javascript implementation of the algorithm described by
     * Jason Orendorff here: http://stackoverflow.com/a/2149533/87990
     */
    function _HeapNode(weight, value, total) {
        this.weight = weight;
        this.value = value;
        this.total = total;  // Total weight of this node and its children
    }
    /**
     * Note, we're using a heap structure here for its tree properties, not as a
     * classic binary heap. A node heap[i] has children at heap[i<<1] and at
     * heap[(i<<1)+1]. Its parent is at h[i>>1]. Heap[0] is vacant.
     */
    function _WeightedHeap(items) {
        this.heap = [null];   // Math is easier to read if we index array from 1

        // First put everything on the heap
        for (var i = 0; i < items.length; i++) {
            var weight = items[i][1];
            var value = items[i][0];
            this.heap.push(new _HeapNode(weight, value, weight));
        }
        // Now go through the heap and add each node's weight to its parent
        for (i = this.heap.length - 1; i > 1; i--) {
            this.heap[i>>1].total += this.heap[i].total;
        }
        //console.debug('_Wh heap', this.heap);
    }

    _WeightedHeap.prototype = {
        pop: function() {
            // Start with a random amount of gas
            var gas = this.heap[1].total * Math.random();

            // Start driving at the root node
            var i = 1;

            // While we have enough gas to keep going past i:
            while (gas > this.heap[i].weight) {
                gas -= this.heap[i].weight;     // Drive past i
                i <<= 1;                        // Move to first child
                if (gas > this.heap[i].total) {
                    gas -= this.heap[i].total;    // Drive past first child and its descendants
                    i++;                          // Move on to second child
                }
            }
            // Out of gas - i is our selected node.
            var value = this.heap[i].value;
            var selectedWeight = this.heap[i].weight;

            this.heap[i].weight = 0;          // Make sure i isn't chosen again
            while (i > 0) {
                // Remove the weight from its parent's total
                this.heap[i].total -= selectedWeight;
                i >>= 1;  // Move to the next parent
            }
            return value;
        }
    };

    //  NB: another binary heap implementation is at
    // http://eloquentjavascript.net/appendix2.html

    return _WeightedList;
})();
/******/
}});

if(usesModule)
{
    exports.ValueTypeHelper = FBL.Firecrow.ValueTypeHelper;
}var usesModule = typeof module !== 'undefined' && module.exports;
var HtmlHelper;
if(usesModule || typeof FBL == "undefined")
{
    FBL =  { Firecrow: {}, ns:  function(namespaceFunction){ namespaceFunction(); }};

    if(typeof Components != "undefined")
    {
        var Cu = Components.utils;
        var Cc = Components.classes;

        var scriptLoader = Cc["@mozilla.org/moz/jssubscript-loader;1"].getService(Components.interfaces.mozIJSSubScriptLoader);

        scriptLoader.loadSubScript("chrome://Firecrow/content/helpers/ASTHelper.js", this, "UTF-8");
    }
}

FBL.ns(function () { with (FBL) {
/******/
Firecrow.htmlHelper = HtmlHelper =
{
    serializeToHtmlJSON: function(htmlDocument, scriptPathsAndModels, stylesPathsAndModels)
    {
        try
        {
            var serialized = { };

            var docType = this.getDocumentType(htmlDocument);
            var htmlElement = this.getHtmlElement(htmlDocument);

            this._lastUsedId = 0;

            serialized.docType = docType != null ? docType.systemId :"";
            serialized.htmlElement = htmlElement != null ? this.getSimplifiedElement(htmlElement, scriptPathsAndModels, stylesPathsAndModels)
                                                         : "null";

            serialized.pageUrl = htmlDocument.baseURI;

            return serialized;
        }
        catch(e) { Components.utils.reportError("Error when serializing to HTML JSON:" + e + " " + e.lineNumber);}
    },

    _lastUsedId: 0,

    getDocumentType: function(htmlDocument)
    {
        return htmlDocument.childNodes[0] != null && htmlDocument.childNodes[0].nodeType == 10
            ?  htmlDocument.childNodes[0]
            :  null;
    },

    getHtmlElement: function(htmlDocument)
    {
        for(var i = 0; i < htmlDocument.childNodes.length; i++)
        {
            if(htmlDocument.childNodes[i].tagName == "HTML")
            {
                return htmlDocument.childNodes[i];
            }
        }

        return null;
    },

    getSimplifiedElement: function(rootElement, scriptPathsAndModels, stylesPathsAndModels)
    {
        var elem =
        {
            type: rootElement.nodeType != 3 ? rootElement.localName : "textNode",
            attributes: this.getAttributes(rootElement),
            childNodes: this.getChildren(rootElement, scriptPathsAndModels, stylesPathsAndModels),
            nodeId: this._lastUsedId++
        };

        if(elem.type == null) { return null;}

        var that = this;

        if(rootElement.nodeType == 3 //is text node
        || rootElement.tagName == "SCRIPT")
        {
            elem.textContent = rootElement.textContent;
        }

        if(rootElement.tagName == "SCRIPT")
        {
            elem.pathAndModel = scriptPathsAndModels.splice(0,1)[0];

            Firecrow.ASTHelper.traverseAst(elem.pathAndModel.model, function (currentElement)
            {
                currentElement.nodeId = that._lastUsedId++;
            });
        }
        else if (rootElement.tagName == "STYLE"
              || (rootElement.tagName == "LINK" && rootElement.rel != "" && rootElement.rel.toLowerCase() == "stylesheet"))
        {
            elem.pathAndModel = stylesPathsAndModels.splice(0,1)[0];

            var model = elem.pathAndModel.model;

            var textContent = "";

            model.rules.forEach(function(rule)
            {
                rule.nodeId = that._lastUsedId++;
                textContent += rule.cssText + "\n";
            });

            elem.textContent = textContent;
        }

        return elem;
    },

    getAllNodes: function(rootElement)
    {
        var allNodes = [];

        if(rootElement == null || rootElement.childNodes == null) { return allNodes;}

        try
        {
            for(var i = 0; i < rootElement.childNodes.length;i++)
            {
                var currentNode = rootElement.childNodes[i];
                allNodes.push(currentNode);
                Firecrow.ValueTypeHelper.pushAll(allNodes, this.getAllNodes(currentNode));
            }
        }
        catch(e) { Cu.reportError("helpers.htmlHelper error when getting allNodes:" + e);}

        return allNodes;
    },

    getAttributes: function(element)
    {
        var attributes = [];

        try
        {
            if(element.attributes == null) { return attributes; }

            for(var i = 0; i < element.attributes.length; i++)
            {
                var currentAttribute = element.attributes[i];
                var value = currentAttribute.value;

                if(element.tagName == "IMG" && currentAttribute.name.toLowerCase() == "src")
                {
                    value = element.src;
                }

                attributes.push
                (
                    {
                        name: currentAttribute.name,
                        value: value
                    }
                );
            }
        }
        catch(e) { Cu.reportError("Attributes" + e);}

        return attributes;
    },

    getElementXPath: function(element)
    {
        var paths = [];

        for (; element && element.nodeType == 1; element = element.parentNode)
        {
            var index = 0;
            for (var sibling = element.previousSibling; sibling; sibling = sibling.previousSibling)
            {
                if (sibling.localName == element.localName)
                    ++index;
            }

            var tagName = element.localName.toLowerCase();
            var pathIndex = (index ? "[" + (index+1) + "]" : "");
            paths.splice(0, 0, tagName + pathIndex);
        }

        return paths.length ? "/" + paths.join("/") : "";
    },

    getChildren: function(rootElement, scriptPathsAndModels, stylesPathsAndModels)
    {
        var allNodes = [];

        if(rootElement.childNodes == null ||rootElement.tagName == "STYLE" || rootElement.tagName == "LINK") { return allNodes; }

        for(var i = 0; i < rootElement.childNodes.length;i++)
        {
            var simplifiedNode = this.getSimplifiedElement(rootElement.childNodes[i], scriptPathsAndModels, stylesPathsAndModels);

            if(simplifiedNode != null)
            {
                allNodes.push(simplifiedNode);
            }
        }

        return allNodes;
    }
};
}});

if(usesModule)
{
    exports.HtmlHelper = FBL.Firecrow.HtmlHelper;
}

var EXPORTED_SYMBOLS = ["HtmlHelper"];var usesModule = typeof module !== 'undefined' && module.exports;
var ASTHelper;
if(usesModule)
{
    FBL =  { Firecrow: {}, ns:  function(namespaceFunction){ namespaceFunction(); }};
}

FBL.ns(function () { with (FBL) {

Firecrow.ASTHelper = ASTHelper =
{
    parseSourceCodeToAST: function(sourceCode, sourceCodePath, startLine)
    {
        try
        {
            Components.utils.import("resource://gre/modules/reflect.jsm");

            var model = Reflect.parse(sourceCode);

            if(model != null)
            {
                if(model.loc == null)
                {
                    model.loc = { start: {line: startLine}, source: sourceCodePath};
                }

                if(model.loc.start.line != startLine)
                {
                    model.lineAdjuster = startLine;
                }
                else
                {
                    model.lineAdjuster = 0;
                }

                model.source = sourceCodePath;
            }

            return model;
        }
        catch(e) { Cu.reportError("Error while getting AST from source code@" + sourceCodePath + "; error: " + e); }
    },

    calculateCoverage: function(pageModel, scriptPathsToIgnore)
    {
        var scripts = ASTHelper.getScriptElements(pageModel.htmlElement);
        scriptPathsToIgnore = scriptPathsToIgnore || [];

        var totalNumberOfExpressions = 0;
        var executedNumberOfExpressions = 0;

        var totalNumberOfStatements = 0;
        var executedNumberOfStatements = 0;

        var totalNumberOfBranches = 0;
        var executedNumberOfBranches = 0;

        for(var i = 0; i < scripts.length; i++)
        {
            var script = scripts[i];
            if(scriptPathsToIgnore.indexOf(ASTHelper.getAttributeValue(script, "src")) != -1)
            {
                //console.log("Skipping when calculating coverage", ASTHelper.getAttributeValue(script, "src"));
                continue;
            }

            ASTHelper.traverseAst(script.pathAndModel.model, function(astElement)
            {
                if(ASTHelper.isExpression(astElement))
                {
                    totalNumberOfExpressions++;
                    if(astElement.hasBeenExecuted)
                    {
                        executedNumberOfExpressions++;
                    }
                }

                if(ASTHelper.isStatement(astElement) && !ASTHelper.isBlockStatement(astElement) && !ASTHelper.isEmptyStatement(astElement))
                {
                    totalNumberOfStatements++;

                    if(astElement.hasBeenExecuted)
                    {
                        executedNumberOfStatements++;
                    }
                }

                if(ASTHelper.isBranchExpression(astElement))
                {
                    if((ASTHelper.isIfStatement(astElement) && ASTHelper.isIfStatementBodyExecuted(astElement))
                    || (ASTHelper.isSwitchCase(astElement) && ASTHelper.isSwitchCaseExecuted(astElement))
                    || (ASTHelper.isLoopStatement(astElement) && ASTHelper.isLoopStatementExecuted(astElement)))
                    //|| (ASTHelper.isPureElseStatement(astElement) && ASTHelper._isElseStatementExecuted(astElement)))
                    {
                        executedNumberOfBranches++;
                    }
                    else if (ASTHelper.isConditionalExpression(astElement))
                    {
                        //has two alternatives - so maybe count it as two branches
                        totalNumberOfBranches++;

                        if(astElement.consequent.hasBeenExecuted) { executedNumberOfBranches++; }
                        if(astElement.alternate.hasBeenExecuted) { executedNumberOfBranches++; }
                    }

                    if(ASTHelper.isSwitchCase(astElement) && astElement.consequent.length == 0)
                    {
                        return;
                    }

                    totalNumberOfBranches++;
                }
            });
        }

        return {
            totalNumberOfExpressions: totalNumberOfExpressions,
            executedNumberOfExpressions: executedNumberOfExpressions,
            totalNumberOfStatements: totalNumberOfStatements,
            executedNumberOfStatements: executedNumberOfStatements,
            expressionCoverage: executedNumberOfExpressions/totalNumberOfExpressions,
            statementCoverage: executedNumberOfStatements/totalNumberOfStatements,
            totalNumberOfBranches: totalNumberOfBranches,
            executedNumberOfBranches: executedNumberOfBranches,
            branchCoverage:  totalNumberOfBranches != 0 ? executedNumberOfBranches/totalNumberOfBranches : 1
        };
    },

    isBranchExpression: function(element)
    {
        return this.isSwitchCase(element) || this.isIfStatement(element) || this.isLoopStatement(element)
            || this.isConditionalExpression(element);
    },

    isLoopStatementExecuted: function(element)
    {
        if(this.isBlockStatement(element.body))
        {
            return this._isBlockStatementExecuted(element.body);
        }

        return element.body.hasBeenExecuted;
    },

    _isLoopStatementEventExecuted: function(element, executionId)
    {
        if(executionId == null) { return this.isLoopStatementExecuted(element); }

        if(this.isBlockStatement(element.body))
        {
            return this._isBlockStatementEventExecuted(element.body, executionId);
        }

        return this._hasBeenExecutedByEvent(element.body, executionId);
    },

    isSwitchCaseExecuted: function(element)
    {
        for(var i = 0; i < element.consequent.length; i++)
        {
            if(element.consequent[i].hasBeenExecuted)
            {
                return true;
            }
        }

        return false;
    },

    _isSwitchCaseEventExecuted: function(element, executionId)
    {
        if(executionId == null) { return this.isSwitchCaseExecuted(element); }
        for(var i = 0; i < element.consequent.length; i++)
        {
            if(this._hasBeenExecutedByEvent(element.consequent[i], executionId))
            {
                return true;
            }
        }

        return false;
    },

    isIfStatementBodyExecuted: function(ifStatement)
    {
        if(this.isBlockStatement(ifStatement.consequent))
        {
            return this._isBlockStatementExecuted(ifStatement.consequent);
        }

        return ifStatement.consequent.hasBeenExecuted;
    },

    isIfStatementElseExecuted: function(ifStatement)
    {
        if(this.isBlockStatement(ifStatement.alternate))
        {
            return this._isBlockStatementExecuted(ifStatement.alternate);
        }

        return ifStatement.alternate.hasBeenExecuted;
    },

    _isElseStatementExecuted: function(elseConstruct)
    {
        debugger;
    },

    _isIfStatementBodyEventExecuted: function(ifStatement, executionId)
    {
        if(executionId == null) { return this.isIfStatementBodyExecuted(ifStatement);}

        if(this.isBlockStatement(ifStatement.consequent))
        {
            return this._isBlockStatementEventExecuted(ifStatement.consequent, executionId);
        }

        return this._hasBeenExecutedByEvent(ifStatement.consequent, executionId);
    },

    _isBlockStatementExecuted: function(blockStatement)
    {
        for(var i = 0; i < blockStatement.body.length; i++)
        {
            if(blockStatement.body[i].hasBeenExecuted)
            {
                return true;
            }
        }

        return false;
    },

    _isBlockStatementEventExecuted: function(blockStatement, executionId)
    {
        for(var i = 0; i < blockStatement.body.length; i++)
        {
            if(this._hasBeenExecutedByEvent(blockStatement.body[i], executionId))
            {
                return true;
            }
        }

        return false;
    },

    getNodeWithId: function(pageModel, nodeId)
    {
        var foundNode = null;
        this.traverseAst(pageModel, function(currentElement)
        {
            if(currentElement.nodeId == nodeId)
            {
                foundNode = currentElement;
            }
        });

        return foundNode;
    },

    getFunctionCoverageInfo: function(functionConstruct, executionId)
    {
        var totalNumberOfExpressions = 0;
        var executedNumberOfExpressions = 0;

        var totalNumberOfStatements = 0;
        var executedNumberOfStatements = 0;

        var totalNumberOfBranches = 0;
        var executedNumberOfBranches = 0;

        if(functionConstruct != null)
        {
            this.traverseAstWhileIgnoring(functionConstruct.body, function(astElement)
            {
                if(ASTHelper.isExpression(astElement))
                {
                    totalNumberOfExpressions++;
                    if(ASTHelper._hasBeenExecutedByEvent(astElement, executionId))
                    {
                        executedNumberOfExpressions++;
                    }
                }

                if(ASTHelper.isStatement(astElement) && !ASTHelper.isBlockStatement(astElement))
                {
                    totalNumberOfStatements++;

                    if(ASTHelper._hasBeenExecutedByEvent(astElement, executionId))
                    {
                        executedNumberOfStatements++;
                    }
                }

                if(ASTHelper.isBranchExpression(astElement))
                {
                    if((ASTHelper.isIfStatement(astElement) && ASTHelper._isIfStatementBodyEventExecuted(astElement, executionId))
                    || (ASTHelper.isSwitchCase(astElement) && ASTHelper._isSwitchCaseEventExecuted(astElement, executionId))
                    || (ASTHelper.isLoopStatement(astElement) && ASTHelper._isLoopStatementEventExecuted(astElement, executionId)))
                    {
                        executedNumberOfBranches++;
                    }
                    else if (ASTHelper.isConditionalExpression(astElement))
                    {
                        //has two alternatives - so maybe count it as two branches
                        totalNumberOfBranches++;

                        if(ASTHelper._hasBeenExecutedByEvent(astElement.consequent, executionId)) { executedNumberOfBranches++; }
                        if(ASTHelper._hasBeenExecutedByEvent(astElement.alternate, executionId)) { executedNumberOfBranches++; }
                    }

                    if(ASTHelper.isSwitchCase(astElement) && astElement.consequent.length == 0)
                    {
                        return;
                    }

                    totalNumberOfBranches++;
                }
            }, ["FunctionExpression", "FunctionDeclaration"]);
        }


        var branchCoverage = totalNumberOfBranches != 0 ? executedNumberOfBranches/totalNumberOfBranches
                                                        : 1;

         return {
            totalNumberOfExpressions: totalNumberOfExpressions,
            executedNumberOfExpressions: executedNumberOfExpressions,
            totalNumberOfStatements: totalNumberOfStatements,
            executedNumberOfStatements: executedNumberOfStatements,
            expressionCoverage: executedNumberOfExpressions/totalNumberOfExpressions,
            statementCoverage: executedNumberOfStatements/totalNumberOfStatements,
            totalNumberOfBranches: totalNumberOfBranches,
            executedNumberOfBranches: executedNumberOfBranches,
            branchCoverage: branchCoverage
        };
    },

    getLoopStatements: function(root)
    {
        var loops = [];
        ASTHelper.traverseDirectSourceElements(root, function(element)
        {
            if(ASTHelper.isLoopStatement(element))
            {
                loops.push(element)
            }
        }, false);

        return loops;
    },

    _hasBeenExecutedByEvent: function(astElement, executionId)
    {
        if(executionId == null) { return astElement.hasBeenExecuted; }

        return astElement.executorEventsMap != null && astElement.executorEventsMap[executionId];
    },

    setParentsChildRelationships: function(rootElement)
    {
        try
        {
            if(rootElement == null || rootElement.parentChildRelationshipsHaveBeenSet) { return; }

            var lineNumberAdjust = rootElement.lineAdjuster || 0;
            var source = rootElement.source || "";

            this.traverseAst(rootElement, function(currentElement, propertyName, parentElement)
            {
                if(currentElement != null)
                {
                    currentElement.parent = parentElement;
                }

                if(ASTHelper.isProgram(currentElement))
                {
                    lineNumberAdjust = currentElement.lineAdjuster || 0;
                    source = rootElement.source || "";
                }

                if(currentElement.loc != null)
                {
                    currentElement.loc.start.line += lineNumberAdjust;
                    currentElement.loc.end.line += lineNumberAdjust
                    currentElement.loc.source = source;
                }

                if(parentElement != null)
                {
                    if(parentElement.children == null) { parentElement.children = []; }

                    if(currentElement != null)
                    {
                        currentElement.indexInParent = parentElement.children.length;

                        if(ASTHelper.getFunctionParent(currentElement) != null)
                        {
                            for(var i = parentElement.children.length - 1; i >= 0; i--)
                            {
                                var child = parentElement.children[i];

                                if((ASTHelper.isLoopStatement(child) || ASTHelper.isIfStatement(child)))
                                {
                                    currentElement.previousCondition = child.test;
                                    break;
                                }
                            }

                            if(ASTHelper.isStatement(parentElement) && currentElement.previousCondition == null)
                            {
                                currentElement.previousCondition = parentElement.previousCondition;
                            }
                        }

                        parentElement.children.push(currentElement);
                    }
                }
            });

            rootElement.parentChildRelationshipsHaveBeenSet = true;
        }
        catch(e) { alert("Error when setting parent-child relationships:" + e); }
    },

    isAncestor: function(firstNode, secondNode)
    {
        var ancestor = firstNode;

        while(ancestor != null)
        {
            if(secondNode == ancestor) { return true; }
            ancestor = ancestor.parent;
        }

        return false;
    },

    getCssRules: function(codeModel)
    {
        var cssRules = [];

        var styleElements = this.getStyleElements(codeModel.htmlElement);

        for(var i = 0; i < styleElements.length; i++)
        {
            var cssElement = styleElements[i];

            var jCssRules = this.getCssRulesFromElement(cssElement);

            if(jCssRules == null) { continue; }

            for(var j = 0; j < jCssRules.length; j++)
            {
                var rule = jCssRules[j];
                var properties = [];

                for(var propName in rule.declarations)
                {
                    if(propName == "parent") { continue; }

                    properties.push({key: propName, value: rule.declarations[propName]});
                }

                cssRules.push({
                   selector: rule.selector,
                   properties: properties,
                   rule: rule
                });
            }
        }

        return cssRules;
    },

    getCssRulesFromElement: function(cssElement)
    {
        if(cssElement == null) { return null; }

        var pathAndModel = cssElement.pathAndModel;

        if(pathAndModel == null) { return null; }

        var model = pathAndModel.model;

        if(model == null) { return null; }

        return model.rules;
    },

    getCssFilePathFromDeclaration: function(cssDeclarationsObject)
    {
        if(cssDeclarationsObject == null || cssDeclarationsObject.parent == null
        || cssDeclarationsObject.parent.cssText == null || cssDeclarationsObject.parent.parent == null
        || cssDeclarationsObject.parent.parent.parent == null)
        {
            return null;
        }

        return cssDeclarationsObject.parent.parent.parent.path;
    },

    getStyleElements: function(element)
    {
        var styleElements = [];

        if(element == null) { return styleElements; }

        var elementType = element.type.toLowerCase();

        if(elementType == "style" || (elementType == "link" && this.hasAttribute(element, "rel", "stylesheet")))
        {
            styleElements.push(element);
        }
        else
        {
            var children = element.childNodes;

            for(var i = 0; i < children.length; i++)
            {
                ASTHelper._pushAll(styleElements, this.getStyleElements(children[i]));
            }
        }

        return styleElements;
    },

    getAllHtmlNodes: function(element)
    {
        var htmlElements = [];

        if(element == null || element.type == "textNode") { return htmlElements; }

        htmlElements.push(element);

        var children = element.childNodes;

        for(var i = 0; i < children.length; i++)
        {
            ASTHelper._pushAll(htmlElements, this.getAllHtmlNodes(children[i]));
        }

        return htmlElements;
    },

    getScriptElements: function(element)
    {
        var scriptElements = [];

        if(element == null) { return scriptElements; }

        if(element.type.toLowerCase() == "script")
        {
            scriptElements.push(element);
        }
        else
        {
            var children = element.childNodes;

            for(var i = 0; i < children.length; i++)
            {
                ASTHelper._pushAll(scriptElements, this.getScriptElements(children[i]));
            }
        }

        return scriptElements;
    },

    getAttributeValue: function(element, attributeName)
    {
        if(element == null || element.attributes == null) { return null; }

        var attributes = element.attributes;

        for(var i = 0; i < attributes.length; i++)
        {
            if(attributes[i].name === attributeName)
            {
                return attributes[i].value;
            }
        }

        return null;
    },

    hasAttribute: function(element, key, value)
    {
        if(element == null) { return false; }
        if(element.attributes == null) { return false; }

        var attributes = element.attributes;

        for(var i = 0; i < attributes.length; i++)
        {
            var attribute = attributes[i];

            if(attribute.name == key && attribute.value == value) { return true; }
        }

        return false;
    },

    getChildStatements: function(blockStatement)
    {
        if(this.isFunction(blockStatement))
        {
            return blockStatement.body.body;
        }
        else if (this.isIfStatement(blockStatement) || this.isLoopStatement(blockStatement))
        {
            var body = this.isIfStatement(blockStatement) ? blockStatement.consequent
                                                          : blockStatement.body;

            return body.body || [body];
        }
        else if (this.isBlockStatement(blockStatement) || this.isProgram(blockStatement))
        {
            return blockStatement.body;
        }
        else if (this.isObjectExpression(blockStatement))
        {
            return blockStatement.properties;
        }
        else if (this.isSwitchStatement(blockStatement))
        {
            var cases = blockStatement.cases;
            var items = [];

            for(var i = 0; i < cases.length; i++)
            {
                ASTHelper._pushAll(items, cases[i].consequent);
            }
        }
        else if (this.isTryStatement(blockStatement))
        {
            return blockStatement.block.body;
        }
        else if (this.isCatchClause(blockStatement))
        {
            return blockStatement.body.body;
        }
        else
        {
            alert("Unhandled block statement command");
        }

        return [];
    },

    getTypeExpressionsFromProgram: function(program, types)
    {
        try
        {
            var result = {};

            var traversalFunction = function(elementValue, elementName, parentObject)
            {
                types.forEach(function(type)
                {
                    if(elementName === "type" &&  elementValue === type)
                    {
                        if(result[type] == null) { result[type] = []; }

                        result[type].push(parentObject);
                    }
                });
            };

            this.traverseAst(program, traversalFunction);

            return result;
        }
        catch(e) { alert("Error while getting type expressions from program in ASTHelper: " + e);}
    },

    createCopy: function(programModel, copyOnlyUsedElements)
    {
        var newModel = {};

        newModel.type = programModel.type;

        var mapping = { };
        var that = this;

        this.traverseAst(programModel, function(propertyValue, propertyName, parentElement)
        {
            if(copyOnlyUsedElements
           && (!parentElement.shouldBeIncluded || !propertyValue.shouldBeIncluded)
           && parentElement.type != "Program" && propertyValue.RegExpBase64 == null)
            {
                return;
            }

            var mappedParentElement = parentElement.type == "Program" ? newModel
                                                                      : mapping[parentElement.nodeId];

            if(mappedParentElement == null) { return; }

            var isPropertyArray = ASTHelper._isArray(parentElement[propertyName]);

            if(mappedParentElement[propertyName] == null)
            {
                if(isPropertyArray)
                {
                    mappedParentElement[propertyName] = [];
                }
                else
                {
                    mappedParentElement[propertyName] = that._cloneShallowASTNode(propertyValue);
                    mapping[propertyValue.nodeId] = mappedParentElement[propertyName];
                }
            }

            var mappedElement = mapping[propertyValue.nodeId];

            if(mappedElement == null)
            {
                mappedElement = that._cloneShallowASTNode(propertyValue);
                mapping[propertyValue.nodeId] = mappedElement;
            }

            if(isPropertyArray)
            {
               mappedParentElement[propertyName].push(mappedElement);
            }
        });

        return newModel;
    },

    _cloneShallowASTNode: function(originalNode)
    {
        var clone = {};

        for(var prop in originalNode)
        {
            if(!ASTHelper._isObject(originalNode[prop]) || originalNode[prop] instanceof RegExp || prop == "comments")
            {
                clone[prop] = originalNode[prop];
            }
        }

        return clone;
    },

    traverseWholeAST: function(astElement, processElementFunction)
    {
        try
        {
            if(astElement == null) { return; }

            if(ASTHelper._isString(astElement)) { return; }

            for(var propName in astElement)
            {
                var propertyValue = astElement[propName];

                if(ASTHelper._isArray(propertyValue))
                {
                    for(var i = 0; i < propertyValue.length; i++)
                    {
                        processElementFunction(propertyValue[i], propName, astElement, i);
                        this.traverseWholeAST(propertyValue[i], processElementFunction);
                    }
                }
                else if(ASTHelper._isString(propertyValue))
                {
                    processElementFunction(propertyValue, propName, astElement);
                }
                else
                {
                    processElementFunction(propertyValue, propName, astElement);
                    this.traverseWholeAST(propertyValue, processElementFunction);
                }
            }
        }
        catch(e)
        {
            alert("Error while traversing whole AST in ASTHelper: " + e);
        }
    },

    traverseAst: function(astElement, processElementFunction, ignoreProperties)
    {
        if(!(ASTHelper._isObject(astElement))) { return; }
        if(astElement.addJsProperty != null)debugger;
        for(var propName in astElement)
        {
            if(!astElement.hasOwnProperty(propName)) { continue; }
            //Do not traverse the source code location properties and parents and graphNodes!
            if(propName == "loc"
                || propName == "parent"
                || propName == "graphNode"
                || propName == "children"
                || propName == "domElement"
                || propName == "graphNode"
                || propName == "htmlNode"
                || propName == "attributes"
                || propName == "previousCondition"
                || propName == "includesNodes"
                || propName == "includedByNodes"
                || propName == "type"
                || propName == "eventTraces"
                || propName == "inclusionDependencyConstraint"
                || propName == "blockStackConstructs"
                || propName == "executorEventsMap"
                || propName == "simpleDependencies"
                || propName == "match"
                || propName == "globalObject"
                || propName == "dependencies"
                || propName == "reverseDependencies"
                || (ignoreProperties && ignoreProperties.indexOf(propName) != -1)) { continue; }

            var propertyValue = astElement[propName];

            if(propertyValue == null) { continue; }

            if(ASTHelper._isArray(propertyValue))
            {
                for(var i = 0; i < propertyValue.length; i++)
                {
                    if(ASTHelper._isObject(propertyValue[i]))
                    {
                        processElementFunction(propertyValue[i], propName, astElement, i);
                        this.traverseAst(propertyValue[i], processElementFunction, ignoreProperties);
                    }
                }
            }
            else if (ASTHelper._isObject(propertyValue))
            {
                processElementFunction(propertyValue, propName, astElement);
                this.traverseAst(propertyValue, processElementFunction, ignoreProperties);
            }
        }
    },

    traverseAstWhileIgnoring: function(astElement, processElementFunction, ignoreElementTypes)
    {
        if(!(ASTHelper._isObject(astElement))) { return; }

        if(ignoreElementTypes != null && ignoreElementTypes.indexOf(astElement.type) != -1) { return; }

        for(var propName in astElement)
        {
            //Do not traverse the source code location properties and parents and graphNodes!
            if(propName == "loc"
                || propName == "parent"
                || propName == "graphNode"
                || propName == "children"
                || propName == "domElement"
                || propName == "graphNode"
                || propName == "htmlNode"
                || propName == "attributes"
                || propName == "previousCondition"
                || propName == "includesNodes"
                || propName == "includedByNodes"
                || propName == "type"
                || propName == "eventTraces"
                || propName == "inclusionDependencyConstraint"
                || propName == "blockStackConstructs"
                || propName == "simpleDependencies"
                || propName == "executorEventsMap") { continue; }

            var propertyValue = astElement[propName];

            if(propertyValue == null) { continue; }

            if(ASTHelper._isArray(propertyValue))
            {
                for(var i = 0; i < propertyValue.length; i++)
                {
                    if(ASTHelper._isObject(propertyValue[i]))
                    {
                        processElementFunction(propertyValue[i], propName, astElement, i);
                        this.traverseAstWhileIgnoring(propertyValue[i], processElementFunction, ignoreElementTypes);
                    }
                }
            }
            else if (ASTHelper._isObject(propertyValue))
            {
                if(ignoreElementTypes == null || ignoreElementTypes.indexOf(propertyValue.type) == -1)
                {
                    processElementFunction(propertyValue, propName, astElement);
                    this.traverseAstWhileIgnoring(propertyValue, processElementFunction, ignoreElementTypes);
                }
            }
        }
    },

    traverseDirectSourceElements: function(astElement, processSourceElementFunction, enterBranchAndLoops)
    {
        try
        {
            if((this.isStatement(astElement) || this.isFunctionDeclaration(astElement) || this.isVariableDeclaration(astElement)) && !this.isBlockStatement(astElement))
            {
                processSourceElementFunction(astElement);
            }

            if(this.isProgram(astElement) || this.isBlockStatement(astElement))
            {
                this.traverseArrayOfDirectStatements(astElement.body, astElement, processSourceElementFunction, enterBranchAndLoops);
            }
            else if (this.isIfStatement(astElement))
            {
                if(enterBranchAndLoops)
                {
                    this.traverseDirectSourceElements(astElement.consequent, processSourceElementFunction, enterBranchAndLoops);

                    if(astElement.alternate != null)
                    {
                        this.traverseDirectSourceElements(astElement.alternate, processSourceElementFunction, enterBranchAndLoops);
                    }
                }
            }
            else if (this.isLabeledStatement(astElement)
                || this.isLetStatement(astElement))
            {
                this.traverseDirectSourceElements(astElement.body, processSourceElementFunction, enterBranchAndLoops);
            }
            else if (this.isLoopStatement(astElement)
                || this.isWithStatement(astElement))
            {
                if(enterBranchAndLoops)
                {
                    this.traverseDirectSourceElements(astElement.body, processSourceElementFunction, enterBranchAndLoops);
                }
            }
            else if (this.isSwitchStatement(astElement))
            {
                if(enterBranchAndLoops)
                {
                    astElement.cases.forEach(function(switchCase)
                    {
                        this.traverseArrayOfDirectStatements
                        (
                            switchCase.consequent,
                            astElement,
                            processSourceElementFunction,
                            enterBranchAndLoops
                        );
                    }, this);
                }
            }
            else if(this.isTryStatement(astElement))
            {
                if(enterBranchAndLoops)
                {
                    this.traverseDirectSourceElements(astElement.block, processSourceElementFunction, enterBranchAndLoops);

                    var handlers = astElement.handlers || (ASTHelper._isArray(astElement.handler) ? astElement.handler : [astElement.handler]);

                    handlers.forEach(function(catchClause)
                    {
                        this.traverseDirectSourceElements(catchClause.body, processSourceElementFunction, enterBranchAndLoops);
                    }, this);
                }

                if(astElement.finalizer != null)
                {
                    this.traverseDirectSourceElements(astElement.finalizer, processSourceElementFunction, enterBranchAndLoops);
                }
            }
            else if (this.isBreakStatement(astElement)
                || this.isContinueStatement(astElement)
                || this.isReturnStatement(astElement)
                || this.isThrowStatement(astElement)
                || this.isDebuggerStatement(astElement)) { }
        }
        catch(e)
        {
            debugger;
            alert("Error while traversing direct source elements in ASTHelper: " + e);
        }
    },

    traverseArrayOfDirectStatements: function(statements, parentElement, processSourceElementFunction, enterBranchAndLoops)
    {
        try
        {
            statements.forEach(function(statement)
            {
                this.traverseDirectSourceElements(statement, processSourceElementFunction, enterBranchAndLoops);
            }, this);
        }
        catch(e) { debugger; alert("Error while traversing direct statements: " + e + " for " + JSON.stringify(parentElement));}
    },

    getParentOfTypes: function(codeConstruct, types)
    {
        if(codeConstruct == null) { return null; }

        var parent = codeConstruct.parent;

        while(parent != null)
        {
            for(var i = 0; i < types.length; i++)
            {
                if(parent.type === types[i]) { return parent; }
            }

            parent = parent.parent;
        }

        return parent;
    },

    getPropertyNameFromForInStatement: function(forInStatement)
    {
        if(!this.isForInStatement(forInStatement)) { return; }

        if(this.isVariableDeclaration(forInStatement.left))
        {
            return forInStatement.left.declarations[0].id.name;
        }
        else
        {
            return forInStatement.left.name;
        }
    },

    isBranchingConditionConstruct: function(codeConstruct)
    {
        var branchingParent = this.getBranchingParent(codeConstruct);

        if(branchingParent == null) { return false; }

        if(branchingParent.test != null)
        {
            return this.isAncestor(codeConstruct, branchingParent.test);
        }
        else if(branchingParent.discriminant != null)
        {
            return this.isAncestor(codeConstruct, branchingParent.discriminant);
        }

        return false;
    },

    isForStatementInit: function(codeConstruct)
    {
        if(codeConstruct == null) { return false; }

        var loopParent = this.getLoopParent(codeConstruct);

        if(loopParent == null) { return false; }

        if(this.isForStatement(loopParent)) { return loopParent.init == codeConstruct;}
        else if (this.isForInStatement(loopParent)) { return loopParent.left == codeConstruct; }

        return false;
    },

    isForStatementTest: function(codeConstruct)
    {
        if(codeConstruct == null) { return false; }

        var loopParent = this.getLoopParent(codeConstruct);

        if(loopParent == null) { return false; }

        if(this.isForStatement(loopParent)) { return loopParent.test == codeConstruct;}

        return false;
    },

    isPureElseStatement: function(codeConstruct)
    {
        if(codeConstruct == null) { return false; }

        return this.isIfStatement(codeConstruct.parent) && codeConstruct.parent.alternate == codeConstruct && !this.isIfStatement(codeConstruct);
    },

    isIfStatementCondition: function(codeConstruct)
    {
        if(codeConstruct == null) { return false; }

        return this.isIfStatement(codeConstruct.parent) && codeConstruct.parent.test == codeConstruct;
    },

    isElseIfStatement: function(codeConstruct)
    {
        if(!this.isIfStatement(codeConstruct)){ return false; }

        return this.isIfStatement(codeConstruct.parent) && codeConstruct.parent.alternate == codeConstruct;
    },

    isObjectExpressionPropertyValue: function(element)
    {
        if(element == null) { return false; }

        return this.isElementOfType(element, this.CONST.Property);
    },

    isFunctionExpressionBlockAsObjectProperty: function(element)
    {
        if(element == null) { return false; }
        if(element.parent == null) { return false; }

        return this.isFunctionExpression(element.parent) && this.isElementOfType(element.parent.parent, this.CONST.Property);
    },

    isCallExpressionCallee: function(element)
    {
        if(element == null) { return false; }

        return this.isCallExpression(element.parent) && element.parent.callee == element;
    },

    isLastPropertyInLeftHandAssignment: function(element)
    {
        if(element == null) { return false; }

        return this.isMemberExpression(element.parent) && this.isAssignmentExpression(element.parent.parent)
             && element.parent.parent.left == element.parent && element.parent.parent.operator.length == 1;
    },

    isIfTest: function(element)
    {
        if(element == null) { return false; }

        return ASTHelper.isIfStatement(element.parent) && element.parent.test == element;
    },

    isWhileTest: function(element)
    {
        if(element == null) { return false; }

        return ASTHelper.isWhileStatement(element.parent) && element.parent.test == element;
    },

    isDoWhileTest: function(element)
    {
        if(element == null) { return false; }

        return ASTHelper.isDoWhileStatement(element.parent) && element.parent.test == element;
    },

    isConditionalTest: function(element)
    {
        if(element == null) { return false; }

        return ASTHelper.isConditionalExpression(element.parent) && element.parent.test == element;
    },

    areRelated: function(statements1, statements2)
    {
        if(!ASTHelper._isArray(statements1) && !ASTHelper._isArray(statements2))
        {
            return this.isAncestor(statements1, statements2) || this.isAncestor(statements2, statements1)
        }

        for(var i = 0; i < statements1.length; i++)
        {
            var firstStatement = statements1[i];
            for(var j = 0; j < statements2.length; j++)
            {
                var secondStatement = statements2[j];

                if(this.isAncestor(firstStatement, secondStatement) || this.isAncestor(secondStatement, firstStatement))
                {
                    return true;
                }
            }
        }

        return false;
    },

    areAncestors: function(statements1, statements2)
    {
        for(var i = 0; i < statements1.length; i++)
        {
            var firstStatement = statements1[i];

            for(var j = 0; j < statements2.length; j++)
            {
                var secondStatement = statements2[j];

                if(this.isAncestor(firstStatement, secondStatement))
                {
                    return true;
                }
            }
        }

        return false;
    },

    getBreakContinueReturnImportantAncestor: function(codeConstruct)
    {
        if(this.isReturnStatement(codeConstruct))
        {
            return this.getFunctionParent(codeConstruct);
        }
        else if (this.isBreakStatement(codeConstruct))
        {
            return this.getLoopOrSwitchParent(codeConstruct);
        }
        else if(this.isContinueStatement(codeConstruct))
        {
            return this.getLoopParent(codeConstruct);
        }

        return null;
    },

    getFirstArgumentOfCallExpression: function(element)
    {
        if(!this.isCallExpression(element) || element.arguments == null) { return null;}

        return element.arguments[0];
    },

    getLastLoopOrBranchingConditionInFunctionBody: function(element)
    {
        if(!this.isFunction(element)){ return null; }

        var firstLevelStatements = element.body.body;

        for(var i = firstLevelStatements.length - 1; i >= 0; i--)
        {
            var statement = firstLevelStatements[i];
            if(this.isIfStatement(statement) || this.isLoopStatement(statement)){ return statement.test; }
            else if (this.isWithStatement(statement)) { return statement.object; }
            else if (this.isForInStatement(statement)) { return statement.right; }
        }

        return null;
    },

    getAllElementsOfType: function(codeElement, types)
    {
        var elementsOfType = [];

        this.traverseAst(codeElement, function(currentElement, propertyName, parentElement)
        {
            if(types.indexOf(currentElement.type) != -1)
            {
                elementsOfType.push(currentElement);
            }
        });

        return elementsOfType;
    },

    getDirectlyContainedReturnStatement: function(body)
    {
        var bodyStatements = this.isBlockStatement(body) ? body.body : [body];

        for(var i = 0; i < bodyStatements.length; i++)
        {
            if(this.isReturnStatement(bodyStatements[i])) { return bodyStatements[i]; }
        }

        return null;
    },

    containsCallOrUpdateOrAssignmentExpression: function(element)
    {
        if(element == null) { return false; }

        if(this.isCallExpression(element) || this.isUpdateExpression(element) || this.isAssignmentExpression(element)) { return true;}

        if(element.containsCallOrUpdateOrAssignmentExpression === true
        || element.containsCallOrUpdateOrAssignmentExpression === false)
        {
            return element.containsCallOrUpdateOrAssignmentExpression;
        }

        var containsCallOrUpdateOrAssignmentExpression = false;

        this.traverseAst(element, function(currentElement)
        {
            if(ASTHelper.isCallExpression(currentElement)
            || ASTHelper.isAssignmentExpression(currentElement)
            || ASTHelper.isUpdateExpression(currentElement))
            {
                containsCallOrUpdateOrAssignmentExpression = true;
            }
        });

        element.containsCallOrUpdateOrAssignmentExpression = containsCallOrUpdateOrAssignmentExpression;

        return containsCallOrUpdateOrAssignmentExpression;
    },

    getDeclarator: function(identifier)
    {
       if(!this.isIdentifier(identifier)) { return null; }

       var dependencies = identifier.graphNode != null ? identifier.graphNode.dataDependencies
                                                       : identifier.dependencies;

       if(dependencies == null) { return null; }

        for(var i = 0; i < dependencies.length; i++)
       {
           var destinationNode = dependencies[i].destinationNode.model || dependencies[i].destinationNode;

           if(this.isVariableDeclarator(destinationNode) && destinationNode.id.name == identifier.name)
           {
                return destinationNode;
           }
       }

       return null;
    },

    getValueLiteral: function(identifier)
    {
        if(!this.isIdentifier(identifier)) { return null; }

        var dependencies = identifier.dependencies;

        for(var i = 0; i < dependencies.length; i++)
        {
            var destinationNode = dependencies[i].destinationNode;

            if(this.isLiteral(destinationNode)) { return destinationNode; }
        }

        return null;
    },

    isIdentifierMemberOrCallExpression: function(element)
    {
        //HAS TO BE FAST!
        return element != null && (element.type == "Identifier" || element.type == "MemberExpression" || element.type == "CallExpression")
            && (element.parent == null || (element.parent.argument == null && element.parent.left == null)); // do not care about unary and binary expressions
    },

    isFunctionParameter: function(element)
    {
        if(!this.isIdentifier(element)){ return false; }
        if(!this.isFunction(element.parent)) { return false;}

        var functionParent = element.parent;
        var params = functionParent.params;

        for(var i = 0; i < params.length; i++)
        {
            if(params[i] ==  element) { return true;}
        }

        return false;
    },

    isDeleteExpression: function(element)
    {
        return this.isUnaryExpression(element) && element.operator == "delete";
    },

    isMemberExpressionObject: function(element)
    {
        if(element == null) { return false; }

        return this.isMemberExpression(element.parent) && element.parent.object == element;
    },

    isMemberExpressionProperty: function(element)
    {
        if(element == null) { return false; }

        return this.isMemberExpression(element.parent) && element.parent.property == element;
    },

    getParentStatementOrFunction: function(codeConstruct)
    {
        if(codeConstruct == null) { return null; }

        if(this.isStatement(codeConstruct)) { return codeConstruct; }

        return this.getParentOfTypes(codeConstruct, this.parentStatementOrFunctionTypes);
    },

    //Will be created at the end
    parentStatementOrFunctionTypes: [],

    getParentStatement: function(codeConstruct)
    {
        return this.getParentOfTypes
        (
            codeConstruct,
            [
                this.CONST.STATEMENT.ExpressionStatement,
                this.CONST.STATEMENT.IfStatement,
                this.CONST.STATEMENT.LabeledStatement,
                this.CONST.STATEMENT.BreakStatement,
                this.CONST.STATEMENT.ContinueStatement,
                this.CONST.STATEMENT.WithStatement,
                this.CONST.STATEMENT.SwitchStatement,
                this.CONST.STATEMENT.ReturnStatement,
                this.CONST.STATEMENT.ThrowStatement,
                this.CONST.STATEMENT.TryStatement,
                this.CONST.STATEMENT.WhileStatement,
                this.CONST.STATEMENT.DoWhileStatement,
                this.CONST.STATEMENT.ForStatement,
                this.CONST.STATEMENT.ForInStatement,
                this.CONST.STATEMENT.LetStatement,
                this.CONST.STATEMENT.DebuggerStatement,
                this.CONST.VariableDeclaration
            ]
        );
    },

    getParentAssignmentExpression: function(codeConstruct)
    {
        return this.getParentOfTypes
        (
            codeConstruct,
            [ this.CONST.EXPRESSION.AssignmentExpression ]
        );
    },

    getFunctionParent: function(codeConstruct)
    {
        return this.getParentOfTypes
        (
            codeConstruct,
            [
                this.CONST.FunctionDeclaration,
                this.CONST.EXPRESSION.FunctionExpression
            ]
        );
    },

    getLoopOrSwitchParent: function(codeConstruct)
    {
        return this.getParentOfTypes
        (
            codeConstruct,
            [
                this.CONST.STATEMENT.ForStatement,
                this.CONST.STATEMENT.ForInStatement,
                this.CONST.STATEMENT.WhileStatement,
                this.CONST.STATEMENT.DoWhileStatement,
                this.CONST.STATEMENT.SwitchStatement
            ]
        );
    },

    getBranchingParent: function(codeConstruct)
    {
        return this.getParentOfTypes
        (
            codeConstruct,
            [
                this.CONST.STATEMENT.ForStatement,
                this.CONST.STATEMENT.ForInStatement,
                this.CONST.STATEMENT.WhileStatement,
                this.CONST.STATEMENT.DoWhileStatement,
                this.CONST.STATEMENT.SwitchStatement,
                this.CONST.STATEMENT.IfStatement,
                this.CONST.EXPRESSION.ConditionalExpression
            ]
        );
    },

    getLoopParent: function(codeConstruct)
    {
        return this.getParentOfTypes
        (
            codeConstruct,
            [
                this.CONST.STATEMENT.ForStatement,
                this.CONST.STATEMENT.ForInStatement,
                this.CONST.STATEMENT.WhileStatement,
                this.CONST.STATEMENT.DoWhileStatement
            ]
        );
    },

    getParentLabelStatement: function(codeConstruct, labelName)
    {
        var labeledStatement = this.getParentOfTypes(codeConstruct, [this.CONST.STATEMENT.LabeledStatement]);

        if(labeledStatement == null || labeledStatement.label == null) { return null; }
        if(labeledStatement.label.name == labelName) { return labeledStatement; }

        return this.getParentLabelStatement(labeledStatement, labelName);
    },

    getSwitchParent: function(codeConstruct)
    {
        return this.getParentOfTypes
        (
            codeConstruct,
            [ this.CONST.STATEMENT.SwitchStatement ]
        );
    },

    getDescendantConditionsMap: function(codeConstruct)
    {
        var conditions = {};

        if(codeConstruct == null) { return conditions; }

        ASTHelper.traverseAst(codeConstruct, function(element)
        {
            //TODO - Do this for if, while, and conditional expressions
            //For and for-in are also possibilities, switch, but i'm not sure should i include them
            //This is a rare problem why i do this
            if(ASTHelper.isIfTest(element) || ASTHelper.isWhileTest(element)
            || ASTHelper.isDoWhileTest(element) || ASTHelper.isConditionalTest(element))
            {
                conditions[element.nodeId] = element;
            }
        });

        return conditions;
    },

    getHeadElement: function(model)
    {
        if(model == null) { return null; }
        if(model.htmlElement == null) { return null; }

        var children = model.htmlElement.childNodes;

        for(var i = 0; i < children.length; i++)
        {
            if(children[i].type === "head")
            {
                return children[i];
            }
        }

        return null;
    },

    getBodyElement: function(model)
    {
        if(model == null) { return null; }
        if(model.htmlElement == null) { return null; }

        var children = model.htmlElement.childNodes;

        for(var i = 0; i < children.length; i++)
        {
            if(children[i].type === "body")
            {
                return children[i];
            }
        }

        return null;
    },

    removeFromParent: function(node)
    {
        if(node == null) { return; }

        var parent = node.parent;

        if(parent == null || parent.children == null) { return; }

        ASTHelper._removeFromArrayByIndex(parent.children, parent.children.indexOf(node));

        if(parent.rules == null) { return; }
        ASTHelper._removeFromArrayByIndex(parent.rules, parent.rules.indexOf(node));
    },

    isElementOfType: function(element, type)
    {
        if(element == null) { return false; }

        return element.type === type;
    },

    isExpression: function(element)
    {
        return element != null ? this.CONST.EXPRESSION[element.type] != null
            : false;
    },

    isJsElement: function(element)
    {
        if(element == null || element.type == null) { return false; }

        return this.CONST[element.type] != null || this.CONST.STATEMENT[element.type] != null || this.CONST.EXPRESSION[element.type] != null;
    },

    isProgram: function(element) { return this.isElementOfType(element, this.CONST.Program); },
    isFunction: function(element) { return this.isFunctionDeclaration(element) || this.isFunctionExpression(element); },
    isFunctionDeclaration: function(element) { return this.isElementOfType(element, this.CONST.FunctionDeclaration); },
    isVariableDeclaration: function(element) { return this.isElementOfType(element, this.CONST.VariableDeclaration); },
    isVariableDeclarator: function(element) { return this.isElementOfType(element, this.CONST.VariableDeclarator); },
    isSwitchCase: function(element) { return this.isElementOfType(element, this.CONST.SwitchCase); },
    isCatchClause: function(element) { return this.isElementOfType(element, this.CONST.CatchClause); },
    isIdentifier: function(element) { return this.isElementOfType(element, this.CONST.Identifier); },
    isLiteral: function(element) { return this.isElementOfType(element, this.CONST.Literal); },
    isProperty: function(element) { return this.isElementOfType(element, this.CONST.Property); },
    isStringLiteral: function(element) { return this.isLiteral(element) && ASTHelper._isString(element.value);},

    isStatement: function(element)
    {
        return element != null ? this.CONST.STATEMENT[element.type] != null
            : false;
    },
    isEmptyStatement: function(element) { return this.isElementOfType(element, this.CONST.STATEMENT.EmptyStatement); },
    isBlockStatement: function(element) { return this.isElementOfType(element, this.CONST.STATEMENT.BlockStatement); },
    isExpressionStatement: function(element) { return this.isElementOfType(element, this.CONST.STATEMENT.ExpressionStatement); },
    isIfStatement: function(element) { return this.isElementOfType(element, this.CONST.STATEMENT.IfStatement); },
    isLabeledStatement: function(element) { return this.isElementOfType(element, this.CONST.STATEMENT.LabeledStatement); },
    isBreakStatement: function(element) { return this.isElementOfType(element, this.CONST.STATEMENT.BreakStatement); },
    isContinueStatement: function(element) { return this.isElementOfType(element, this.CONST.STATEMENT.ContinueStatement); },
    isWithStatement: function(element) { return this.isElementOfType(element, this.CONST.STATEMENT.WithStatement); },
    isSwitchStatement: function(element) { return this.isElementOfType(element, this.CONST.STATEMENT.SwitchStatement); },
    isReturnStatement: function(element) { return this.isElementOfType(element, this.CONST.STATEMENT.ReturnStatement); },
    isThrowStatement: function(element) { return this.isElementOfType(element, this.CONST.STATEMENT.ThrowStatement); },
    isTryStatement: function(element) { return this.isElementOfType(element, this.CONST.STATEMENT.TryStatement); },

    isLoopStatement: function(element)
    {
        return this.isWhileStatement(element)
            || this.isDoWhileStatement(element)
            || this.isForStatement(element)
            || this.isForInStatement(element);
    },

    isLoopStatementCondition: function(element)
    {
        return this.isLoopStatement(element.parent) && element.parent.test == element;
    },

    isWhileStatement: function(element) { return this.isElementOfType(element, this.CONST.STATEMENT.WhileStatement); },
    isDoWhileStatement: function(element) { return this.isElementOfType(element, this.CONST.STATEMENT.DoWhileStatement); },
    isForStatement: function(element) { return this.isElementOfType(element, this.CONST.STATEMENT.ForStatement); },
    isForInStatement: function(element) { return this.isElementOfType(element, this.CONST.STATEMENT.ForInStatement); },
    isLetStatement: function(element) { return this.isElementOfType(element, this.CONST.STATEMENT.LetStatement); },
    isDebuggerStatement: function(element) { return this.isElementOfType(element, this.CONST.STATEMENT.DebuggerStatement); },

    isThisExpression: function(element) { return this.isElementOfType(element, this.CONST.EXPRESSION.ThisExpression); },
    isArrayExpression: function(element) { return this.isElementOfType(element, this.CONST.EXPRESSION.ArrayExpression); },
    isObjectExpression: function(element) { return this.isElementOfType(element, this.CONST.EXPRESSION.ObjectExpression); },
    isFunctionExpression: function(element) { return this.isElementOfType(element, this.CONST.EXPRESSION.FunctionExpression); },
    isSequenceExpression: function(element) { return this.isElementOfType(element, this.CONST.EXPRESSION.SequenceExpression); },
    isUnaryExpression: function(element) { return this.isElementOfType(element, this.CONST.EXPRESSION.UnaryExpression); },
    isBinaryExpression: function(element) { return this.isElementOfType(element, this.CONST.EXPRESSION.BinaryExpression); },
    isAssignmentExpression: function(element) { return this.isElementOfType(element, this.CONST.EXPRESSION.AssignmentExpression); },
    isUpdateExpression: function(element) { return this.isElementOfType(element, this.CONST.EXPRESSION.UpdateExpression); },
    isLogicalExpression: function(element) { return this.isElementOfType(element, this.CONST.EXPRESSION.LogicalExpression); },
    isConditionalExpression: function(element) { return this.isElementOfType(element, this.CONST.EXPRESSION.ConditionalExpression); },
    isNewExpression: function(element) { return this.isElementOfType(element, this.CONST.EXPRESSION.NewExpression); },
    isCallExpression: function(element) { return this.isElementOfType(element, this.CONST.EXPRESSION.CallExpression); },
    isMemberExpression: function(element) { return this.isElementOfType(element, this.CONST.EXPRESSION.MemberExpression); },
    isYieldExpression: function(element) { return this.isElementOfType(element, this.CONST.EXPRESSION.YieldExpression); },
    isComprehensionExpression: function(element) { return this.isElementOfType(element, this.CONST.EXPRESSION.ComprehensionExpression); },
    isGeneratorExpression: function(element) { return this.isElementOfType(element, this.CONST.EXPRESSION.GeneratorExpression); },
    isLetExpression: function(element) { return this.isElementOfType(element, this.CONST.EXPRESSION.LetExpression); },

    isUnaryOperator: function(element) { return this.isElementOfType(element, this.CONST.OPERATOR.UnaryOperator); },
    isBinaryOperator: function(element) { return this.isElementOfType(element, this.CONST.OPERATOR.BinaryOperator); },
    isAssignmentOperator: function(element) { return this.isElementOfType(element, this.CONST.OPERATOR.AssignmentOperator); },
    isUpdateOperator: function(element) { return this.isElementOfType(element, this.CONST.OPERATOR.UpdateOperator); },
    isLogicalOperator: function(element) { return this.isElementOfType(element, this.CONST.OPERATOR.LogicalOperator); },

    isUnaryMathOperator: function(operator)
    {
        return operator == "-" || operator == "+";
    },

    isUnaryLogicalOperator: function(operator)
    {
        return operator == "!";
    },

    isUnaryBitOperator: function(operator)
    {
        return operator == "~";
    },

    isUnaryObjectOperator: function(operator)
    {
        return operator == "typeof" || operator == "void"
            || operator == "delete";
    },

    isBinaryEqualityOperator:function (element)
    {
        return element == "==" || element == "==="
            || element == "!=" || element == "!==";
    },

    isBinaryMathOperator:function (element)
    {
        return element == "+" || element == "-"
            || element == "*" || element == "/" || element == "%";
    },

    isBinaryRelationalOperator:function (element)
    {
        return element == "<" || element == "<="
            || element == ">" || element == ">=";
    },

    isBinaryBitOperator:function (element)
    {
        return element == "|" || element == "&"
            || element == "^"
            || element == "<<" || element == ">>"
            || element == ">>>";
    },

    isBinaryObjectOperator: function (element)
    {
        return element == "in" || element == "instanceof";
    },

    isBinaryXmlOperator: function (element)
    {
        return element == "..";
    },

    getSimpleSortingFunctionReturnArg: function(functionConstruct)
    {
        if(!this.isFunction(functionConstruct)) { return false; }

        if(functionConstruct.params.length != 2) { return false; }
        if(functionConstruct.body.body.length != 1) { return false; }

        if(!this.isReturnStatement(functionConstruct.body.body[0])) { return false; }

        var returnStatement = functionConstruct.body.body[0];

        if(!this.isBinaryExpression(returnStatement.argument)) { return false; }

        if(!this.isIdentifier(returnStatement.argument.left) || !this.isIdentifier(returnStatement.argument.right))
        {
            return false;
        }

        return returnStatement.argument;
    },
    
    _pushAll: function(baseArray, arrayWithItems)
    {
        if(baseArray == null || arrayWithItems == null) { return; }
        
        baseArray.push.apply(baseArray, arrayWithItems);    
    },

    _isArray: function(arrayOfElements)
    {
        return (typeof arrayOfElements) == "array" || arrayOfElements instanceof Array;
    },

    _isObject: function(potentialObject)
    {
        return 'object' == typeof potentialObject;
    },
    
    _isString: function(variable)
    {
        return (typeof variable) == "string" || variable instanceof String;   
    },

    _removeFromArrayByIndex: function(array, index)
    {
        if(array == null) { return null; }

        return array.splice(index, 1);
    },

    CONST :
    {
        Program: "Program",
        FunctionDeclaration: "FunctionDeclaration",
        VariableDeclaration: "VariableDeclaration",
        VariableDeclarator: "VariableDeclarator",
        SwitchCase: "SwitchCase",
        CatchClause: "CatchClause",
        Identifier: "Identifier",
        Literal: "Literal",
        Property: "Property",
        STATEMENT:
        {
            EmptyStatement: "EmptyStatement",
            BlockStatement: "BlockStatement",
            ExpressionStatement : "ExpressionStatement",
            IfStatement: "IfStatement",
            LabeledStatement: "LabeledStatement",
            BreakStatement: "BreakStatement",
            ContinueStatement: "ContinueStatement",
            WithStatement: "WithStatement",
            SwitchStatement: "SwitchStatement",
            ReturnStatement: "ReturnStatement",
            ThrowStatement: "ThrowStatement",
            TryStatement: "TryStatement",
            WhileStatement: "WhileStatement",
            DoWhileStatement: "DoWhileStatement",
            ForStatement: "ForStatement",
            ForInStatement: "ForInStatement",
            LetStatement: "LetStatement",
            DebuggerStatement: "DebuggerStatement"
        },
        EXPRESSION:
        {
            ThisExpression : "ThisExpression",
            ArrayExpression: "ArrayExpression",
            ObjectExpression: "ObjectExpression",
            FunctionExpression: "FunctionExpression",
            SequenceExpression: "SequenceExpression",
            UnaryExpression: "UnaryExpression",
            BinaryExpression: "BinaryExpression",
            AssignmentExpression: "AssignmentExpression",
            UpdateExpression: "UpdateExpression",
            LogicalExpression: "LogicalExpression",
            ConditionalExpression: "ConditionalExpression",
            NewExpression: "NewExpression",
            CallExpression: "CallExpression",
            MemberExpression: "MemberExpression",
            YieldExpression: "YieldExpression",
            ComprehensionExpression: "ComprehensionExpression",
            GeneratorExpression: "GeneratorExpression",
            LetExpression: "LetExpression"
        },
        OPERATOR:
        {
            UnaryOperator : "UnaryOperator",
            BinaryOperator: "BinaryOperator",
            AssignmentOperator: "AssignmentOperator",
            UpdateOperator: "UpdateOperator",
            LogicalOperator: "LogicalOperator"
        }
    }
};

Firecrow.ASTHelper.parentStatementOrFunctionTypes =
[
    Firecrow.ASTHelper.CONST.STATEMENT.ExpressionStatement,
    Firecrow.ASTHelper.CONST.STATEMENT.IfStatement,
    Firecrow.ASTHelper.CONST.STATEMENT.LabeledStatement,
    Firecrow.ASTHelper.CONST.STATEMENT.BreakStatement,
    Firecrow.ASTHelper.CONST.STATEMENT.ContinueStatement,
    Firecrow.ASTHelper.CONST.STATEMENT.WithStatement,
    Firecrow.ASTHelper.CONST.STATEMENT.SwitchStatement,
    Firecrow.ASTHelper.CONST.STATEMENT.ReturnStatement,
    Firecrow.ASTHelper.CONST.STATEMENT.ThrowStatement,
    Firecrow.ASTHelper.CONST.STATEMENT.TryStatement,
    Firecrow.ASTHelper.CONST.STATEMENT.WhileStatement,
    Firecrow.ASTHelper.CONST.STATEMENT.DoWhileStatement,
    Firecrow.ASTHelper.CONST.STATEMENT.ForStatement,
    Firecrow.ASTHelper.CONST.STATEMENT.ForInStatement,
    Firecrow.ASTHelper.CONST.STATEMENT.LetStatement,
    Firecrow.ASTHelper.CONST.STATEMENT.DebuggerStatement,
    Firecrow.ASTHelper.CONST.VariableDeclaration,
    Firecrow.ASTHelper.CONST.FunctionDeclaration
];
/******/
}});

if(usesModule)
{
    exports.ASTHelper = ASTHelper;
}var usesModule = typeof module !== 'undefined' && module.exports;
var HtmlHelper;
if(usesModule || typeof FBL == "undefined")
{
    FBL =  { Firecrow: {}, ns:  function(namespaceFunction){ namespaceFunction(); }};

    if(typeof Components != "undefined")
    {
        var Cu = Components.utils;
        var Cc = Components.classes;

        var scriptLoader = Cc["@mozilla.org/moz/jssubscript-loader;1"].getService(Components.interfaces.mozIJSSubScriptLoader);

        scriptLoader.loadSubScript("chrome://Firecrow/content/helpers/ASTHelper.js", this, "UTF-8");
    }
}

FBL.ns(function () { with (FBL) {
/******/
Firecrow.htmlHelper = HtmlHelper =
{
    serializeToHtmlJSON: function(htmlDocument, scriptPathsAndModels, stylesPathsAndModels)
    {
        try
        {
            var serialized = { };

            var docType = this.getDocumentType(htmlDocument);
            var htmlElement = this.getHtmlElement(htmlDocument);

            this._lastUsedId = 0;

            serialized.docType = docType != null ? docType.systemId :"";
            serialized.htmlElement = htmlElement != null ? this.getSimplifiedElement(htmlElement, scriptPathsAndModels, stylesPathsAndModels)
                                                         : "null";

            serialized.pageUrl = htmlDocument.baseURI;

            return serialized;
        }
        catch(e) { Components.utils.reportError("Error when serializing to HTML JSON:" + e + " " + e.lineNumber);}
    },

    _lastUsedId: 0,

    getDocumentType: function(htmlDocument)
    {
        return htmlDocument.childNodes[0] != null && htmlDocument.childNodes[0].nodeType == 10
            ?  htmlDocument.childNodes[0]
            :  null;
    },

    getHtmlElement: function(htmlDocument)
    {
        for(var i = 0; i < htmlDocument.childNodes.length; i++)
        {
            if(htmlDocument.childNodes[i].tagName == "HTML")
            {
                return htmlDocument.childNodes[i];
            }
        }

        return null;
    },

    getSimplifiedElement: function(rootElement, scriptPathsAndModels, stylesPathsAndModels)
    {
        var elem =
        {
            type: rootElement.nodeType != 3 ? rootElement.localName : "textNode",
            attributes: this.getAttributes(rootElement),
            childNodes: this.getChildren(rootElement, scriptPathsAndModels, stylesPathsAndModels),
            nodeId: this._lastUsedId++
        };

        if(elem.type == null) { return null;}

        var that = this;

        if(rootElement.nodeType == 3 //is text node
        || rootElement.tagName == "SCRIPT")
        {
            elem.textContent = rootElement.textContent;
        }

        if(rootElement.tagName == "SCRIPT")
        {
            elem.pathAndModel = scriptPathsAndModels.splice(0,1)[0];

            Firecrow.ASTHelper.traverseAst(elem.pathAndModel.model, function (currentElement)
            {
                currentElement.nodeId = that._lastUsedId++;
            });
        }
        else if (rootElement.tagName == "STYLE"
              || (rootElement.tagName == "LINK" && rootElement.rel != "" && rootElement.rel.toLowerCase() == "stylesheet"))
        {
            elem.pathAndModel = stylesPathsAndModels.splice(0,1)[0];

            var model = elem.pathAndModel.model;

            var textContent = "";

            model.rules.forEach(function(rule)
            {
                rule.nodeId = that._lastUsedId++;
                textContent += rule.cssText + "\n";
            });

            elem.textContent = textContent;
        }

        return elem;
    },

    getAllNodes: function(rootElement)
    {
        var allNodes = [];

        if(rootElement == null || rootElement.childNodes == null) { return allNodes;}

        try
        {
            for(var i = 0; i < rootElement.childNodes.length;i++)
            {
                var currentNode = rootElement.childNodes[i];
                allNodes.push(currentNode);
                Firecrow.ValueTypeHelper.pushAll(allNodes, this.getAllNodes(currentNode));
            }
        }
        catch(e) { Cu.reportError("helpers.htmlHelper error when getting allNodes:" + e);}

        return allNodes;
    },

    getAttributes: function(element)
    {
        var attributes = [];

        try
        {
            if(element.attributes == null) { return attributes; }

            for(var i = 0; i < element.attributes.length; i++)
            {
                var currentAttribute = element.attributes[i];
                var value = currentAttribute.value;

                if(element.tagName == "IMG" && currentAttribute.name.toLowerCase() == "src")
                {
                    value = element.src;
                }

                attributes.push
                (
                    {
                        name: currentAttribute.name,
                        value: value
                    }
                );
            }
        }
        catch(e) { Cu.reportError("Attributes" + e);}

        return attributes;
    },

    getElementXPath: function(element)
    {
        var paths = [];

        for (; element && element.nodeType == 1; element = element.parentNode)
        {
            var index = 0;
            for (var sibling = element.previousSibling; sibling; sibling = sibling.previousSibling)
            {
                if (sibling.localName == element.localName)
                    ++index;
            }

            var tagName = element.localName.toLowerCase();
            var pathIndex = (index ? "[" + (index+1) + "]" : "");
            paths.splice(0, 0, tagName + pathIndex);
        }

        return paths.length ? "/" + paths.join("/") : "";
    },

    getChildren: function(rootElement, scriptPathsAndModels, stylesPathsAndModels)
    {
        var allNodes = [];

        if(rootElement.childNodes == null ||rootElement.tagName == "STYLE" || rootElement.tagName == "LINK") { return allNodes; }

        for(var i = 0; i < rootElement.childNodes.length;i++)
        {
            var simplifiedNode = this.getSimplifiedElement(rootElement.childNodes[i], scriptPathsAndModels, stylesPathsAndModels);

            if(simplifiedNode != null)
            {
                allNodes.push(simplifiedNode);
            }
        }

        return allNodes;
    }
};
}});

if(usesModule)
{
    exports.HtmlHelper = FBL.Firecrow.HtmlHelper;
}

var EXPORTED_SYMBOLS = ["HtmlHelper"];var usesModule = typeof module !== 'undefined' && module.exports;
var UriHelper;
if(usesModule || typeof FBL == "undefined")
{
    FBL =  { Firecrow: {}, ns:  function(namespaceFunction){ namespaceFunction(); }};
}

FBL.ns(function () { with (FBL) {
/******/
Firecrow.UriHelper = UriHelper =
{
    URI: null,

    appendQuery: function(url, key, value)
    {
        if(url == null) { return null; }

        var uri = new this.URI(url);

        uri.addQuery(key, value);

        return uri.href();
    },

    getRequestAddress: function(url)
    {
        if(url == null) { return null; }

        var uri = new this.URI(url);

        var href = uri.href();

        var query = this.getQuery(url);

        var startOfQueryIndex = href.indexOf(query);

        if(startOfQueryIndex == -1) { return href; }

        return href.substring(0, startOfQueryIndex - 1);
    },

    getQuery: function(url)
    {
        if(url == null) { return null; }

        var uri = new this.URI(url);

        return uri.query();
    },

    getRelativeFrom: function(url, anchor)
    {
        if(url == null) { return null; }

        try
        {
            var uri = new this.URI(url);
            var anchorUri = new this.URI(anchor);

            return uri.relativeTo(anchorUri);
        }
        catch(e)
        {
            debugger;
            alert("Error when getting relative uri")
        }
    },

    getAbsoluteUrl: function(url, anchor)
    {
        if(url == null) { return null; }

        var uri = new this.URI(url);

        if(uri.is("absolute")) { return uri.build()._string; }

        var anchorUri = new this.URI(anchor);

        if(anchorUri.is("absolute"))
        {
            var absoluteUri = uri.absoluteTo(anchorUri);

            if(absoluteUri != null)
            {
                return absoluteUri._string;
            }
        }

        return url;
    },

    areOnSameDomain: function(url1, url2)
    {
        var uri1 = new this.URI(url1);
        var uri2 = new this.URI(url2);

        return uri1.hostname() == uri2.hostname() && uri2.hostname() != "";
    }
};

/*!
 * URI.js - Mutating URLs
 *
 * Version: 1.7.4
 *
 * Author: Rodney Rehm
 * Web: http://medialize.github.com/URI.js/
 *
 * Licensed under
 *   MIT License http://www.opensource.org/licenses/mit-license
 *   GPL v3 http://opensource.org/licenses/GPL-3.0
 *
 */

(function(undefined) {

    var _use_module = false,
        _load_module = function(module) {
            return _use_module ? require('./' + module) : this[module];
        },
        punycode = _load_module('punycode'),
        IPv6 = _load_module('IPv6'),
        SLD = _load_module('SecondLevelDomains'),
        URI = function(url, base) {
            // Allow instantiation without the 'new' keyword
            if (!(this instanceof URI)) {
                return new URI(url, base);
            }

            if (url === undefined) {
                if (typeof location !== 'undefined') {
                    url = location.href + "";
                } else {
                    url = "";
                }
            }

            this.href(url);

            // resolve to base according to http://dvcs.w3.org/hg/url/raw-file/tip/Overview.html#constructor
            if (base !== undefined) {
                return this.absoluteTo(base);
            }

            return this;
        },
        p = URI.prototype;

    function escapeRegEx(string) {
        // https://github.com/medialize/URI.js/commit/85ac21783c11f8ccab06106dba9735a31a86924d#commitcomment-821963
        return string.replace(/([.*+?^=!:${}()|[\]\/\\])/g, '\\$1');
    }

    function isArray(obj) {
        return String(Object.prototype.toString.call(obj)) === "[object Array]";
    }

    function filterArrayValues(data, value) {
        var lookup = {},
            i, length;

        if (isArray(value)) {
            for (i = 0, length = value.length; i < length; i++) {
                lookup[value[i]] = true;
            }
        } else {
            lookup[value] = true;
        }

        for (i = 0, length = data.length; i < length; i++) {
            if (lookup[data[i]] !== undefined) {
                data.splice(i, 1);
                length--;
                i--;
            }
        }

        return data;
    }

// static properties
    URI.protocol_expression = /^[a-z][a-z0-9-+-]*$/i;
    URI.idn_expression = /[^a-z0-9\.-]/i;
    URI.punycode_expression = /(xn--)/i;
// well, 333.444.555.666 matches, but it sure ain't no IPv4 - do we care?
    URI.ip4_expression = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/;
// credits to Rich Brown
// source: http://forums.intermapper.com/viewtopic.php?p=1096#1096
// specification: http://www.ietf.org/rfc/rfc4291.txt
    URI.ip6_expression = /^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$/ ;
// gruber revised expression - http://rodneyrehm.de/t/url-regex.html
    URI.find_uri_expression = /\b((?:[a-z][\w-]+:(?:\/{1,3}|[a-z0-9%])|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]+|\(([^\s()<>]+|(\([^\s()<>]+\)))*\))+(?:\(([^\s()<>]+|(\([^\s()<>]+\)))*\)|[^\s`!()\[\]{};:'".,<>?]))/ig;
// http://www.iana.org/assignments/uri-schemes.html
// http://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#Well-known_ports
    URI.defaultPorts = {
        http: "80",
        https: "443",
        ftp: "21"
    };
// allowed hostname characters according to RFC 3986
// ALPHA DIGIT "-" "." "_" "~" "!" "$" "&" "'" "(" ")" "*" "+" "," ";" "=" %encoded
// I've never seen a (non-IDN) hostname other than: ALPHA DIGIT . -
    URI.invalid_hostname_characters = /[^a-zA-Z0-9\.-]/;
// encoding / decoding according to RFC3986
    function strictEncodeURIComponent(string) {
        // see https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/encodeURIComponent
        return encodeURIComponent(string)
            .replace(/[!'()*]/g, escape)
            .replace(/\*/g, "%2A");
    }
    URI.encode = strictEncodeURIComponent;
    URI.decode = decodeURIComponent;
    URI.iso8859 = function() {
        URI.encode = escape;
        URI.decode = unescape;
    };
    URI.unicode = function() {
        URI.encode = strictEncodeURIComponent;
        URI.decode = decodeURIComponent;
    };
    URI.characters = {
        pathname: {
            encode: {
                // RFC3986 2.1: For consistency, URI producers and normalizers should
                // use uppercase hexadecimal digits for all percent-encodings.
                expression: /%(24|26|2B|2C|3B|3D|3A|40)/ig,
                map: {
                    // -._~!'()*
                    "%24": "$",
                    "%26": "&",
                    "%2B": "+",
                    "%2C": ",",
                    "%3B": ";",
                    "%3D": "=",
                    "%3A": ":",
                    "%40": "@"
                }
            },
            decode: {
                expression: /[\/\?#]/g,
                map: {
                    "/": "%2F",
                    "?": "%3F",
                    "#": "%23"
                }
            }
        },
        reserved: {
            encode: {
                // RFC3986 2.1: For consistency, URI producers and normalizers should
                // use uppercase hexadecimal digits for all percent-encodings.
                expression: /%(21|23|24|26|27|28|29|2A|2B|2C|2F|3A|3B|3D|3F|40|5B|5D)/ig,
                map: {
                    // gen-delims
                    "%3A": ":",
                    "%2F": "/",
                    "%3F": "?",
                    "%23": "#",
                    "%5B": "[",
                    "%5D": "]",
                    "%40": "@",
                    // sub-delims
                    "%21": "!",
                    "%24": "$",
                    "%26": "&",
                    "%27": "'",
                    "%28": "(",
                    "%29": ")",
                    "%2A": "*",
                    "%2B": "+",
                    "%2C": ",",
                    "%3B": ";",
                    "%3D": "="
                }
            }
        }
    };
    URI.encodeQuery = function(string) {
        return URI.encode(string + "").replace(/%20/g, '+');
    };
    URI.decodeQuery = function(string) {
        return URI.decode((string + "").replace(/\+/g, '%20'));
    };
    URI.recodePath = function(string) {
        var segments = (string + "").split('/');
        for (var i = 0, length = segments.length; i < length; i++) {
            segments[i] = URI.encodePathSegment(URI.decode(segments[i]));
        }

        return segments.join('/');
    };
    URI.decodePath = function(string) {
        var segments = (string + "").split('/');
        for (var i = 0, length = segments.length; i < length; i++) {
            segments[i] = URI.decodePathSegment(segments[i]);
        }

        return segments.join('/');
    };
// generate encode/decode path functions
    var _parts = {'encode':'encode', 'decode':'decode'},
        _part,
        generateAccessor = function(_group, _part){
            return function(string) {
                return URI[_part](string + "").replace(URI.characters[_group][_part].expression, function(c) {
                    return URI.characters[_group][_part].map[c];
                });
            };
        };

    for (_part in _parts) {
        URI[_part + "PathSegment"] = generateAccessor("pathname", _parts[_part]);
    }

    URI.encodeReserved = generateAccessor("reserved", "encode");

    URI.parse = function(string) {
        var pos, t, parts = {};
        // [protocol"://"[username[":"password]"@"]hostname[":"port]"/"?][path]["?"querystring]["#"fragment]

        // extract fragment
        pos = string.indexOf('#');
        if (pos > -1) {
            // escaping?
            parts.fragment = string.substring(pos + 1) || null;
            string = string.substring(0, pos);
        }

        // extract query
        pos = string.indexOf('?');
        if (pos > -1) {
            // escaping?
            parts.query = string.substring(pos + 1) || null;
            string = string.substring(0, pos);
        }

        // extract protocol
        if (string.substring(0, 2) === '//') {
            // relative-scheme
            parts.protocol = '';
            string = string.substring(2);
            // extract "user:pass@host:port"
            string = URI.parseAuthority(string, parts);
        } else {
            pos = string.indexOf(':');
            if (pos > -1) {
                parts.protocol = string.substring(0, pos);
                if (parts.protocol && !parts.protocol.match(URI.protocol_expression)) {
                    // : may be within the path
                    parts.protocol = undefined;
                } else if (string.substring(pos + 1, pos + 3) === '//') {
                    string = string.substring(pos + 3);

                    // extract "user:pass@host:port"
                    string = URI.parseAuthority(string, parts);
                } else {
                    string = string.substring(pos + 1);
                    parts.urn = true;
                }
            }
        }

        // what's left must be the path
        parts.path = string;

        // and we're done
        return parts;
    };
    URI.parseHost = function(string, parts) {
        // extract host:port
        var pos = string.indexOf('/'),
            t;

        if (pos === -1) {
            pos = string.length;
        }

        if (string[0] === "[") {
            // IPv6 host - http://tools.ietf.org/html/draft-ietf-6man-text-addr-representation-04#section-6
            // I claim most client software breaks on IPv6 anyways. To simplify things, URI only accepts
            // IPv6+port in the format [2001:db8::1]:80 (for the time being)
            var bracketPos = string.indexOf(']');
            parts.hostname = string.substring(1, bracketPos) || null;
            parts.port = string.substring(bracketPos+2, pos) || null;
        } else if (string.indexOf(':') !== string.lastIndexOf(':')) {
            // IPv6 host contains multiple colons - but no port
            // this notation is actually not allowed by RFC 3986, but we're a liberal parser
            parts.hostname = string.substring(0, pos) || null;
            parts.port = null;
        } else {
            t = string.substring(0, pos).split(':');
            parts.hostname = t[0] || null;
            parts.port = t[1] || null;
        }

        if (parts.hostname && string.substring(pos)[0] !== '/') {
            pos++;
            string = "/" + string;
        }

        return string.substring(pos) || '/';
    };
    URI.parseAuthority = function(string, parts) {
        string = URI.parseUserinfo(string, parts);
        return URI.parseHost(string, parts);
    };
    URI.parseUserinfo = function(string, parts) {
        // extract username:password
        var pos = string.indexOf('@'),
            firstSlash = string.indexOf('/'),
            t;

        // authority@ must come before /path
        if (pos > -1 && (firstSlash === -1 || pos < firstSlash)) {
            t = string.substring(0, pos).split(':');
            parts.username = t[0] ? URI.decode(t[0]) : null;
            parts.password = t[1] ? URI.decode(t[1]) : null;
            string = string.substring(pos + 1);
        } else {
            parts.username = null;
            parts.password = null;
        }

        return string;
    };
    URI.parseQuery = function(string) {
        if (!string) {
            return {};
        }

        // throw out the funky business - "?"[name"="value"&"]+
        string = string.replace(/&+/g, '&').replace(/^\?*&*|&+$/g, '');

        if (!string) {
            return {};
        }

        var items = {},
            splits = string.split('&'),
            length = splits.length;

        for (var i = 0; i < length; i++) {
            var v = splits[i].split('='),
                name = URI.decodeQuery(v.shift()),
            // no "=" is null according to http://dvcs.w3.org/hg/url/raw-file/tip/Overview.html#collect-url-parameters
                value = v.length ? URI.decodeQuery(v.join('=')) : null;

            if (items[name]) {
                if (typeof items[name] === "string") {
                    items[name] = [items[name]];
                }

                items[name].push(value);
            } else {
                items[name] = value;
            }
        }

        return items;
    };

    URI.build = function(parts) {
        var t = '';

        if (parts.protocol) {
            t += parts.protocol + ":";
        }

        if (!parts.urn && (t || parts.hostname)) {
            t += '//';
        }

        t += (URI.buildAuthority(parts) || '');

        if (typeof parts.path === "string") {
            if (parts.path[0] !== '/' && typeof parts.hostname === "string") {
                t += '/';
            }

            t += parts.path;
        }

        if (typeof parts.query === "string") {
            t += '?' + parts.query;
        }

        if (typeof parts.fragment === "string") {
            t += '#' + parts.fragment;
        }
        return t;
    };
    URI.buildHost = function(parts) {
        var t = '';

        if (!parts.hostname) {
            return '';
        } else if (URI.ip6_expression.test(parts.hostname)) {
            if (parts.port) {
                t += "[" + parts.hostname + "]:" + parts.port;
            } else {
                // don't know if we should always wrap IPv6 in []
                // the RFC explicitly says SHOULD, not MUST.
                t += parts.hostname;
            }
        } else {
            t += parts.hostname;
            if (parts.port) {
                t += ':' + parts.port;
            }
        }

        return t;
    };
    URI.buildAuthority = function(parts) {
        return URI.buildUserinfo(parts) + URI.buildHost(parts);
    };
    URI.buildUserinfo = function(parts) {
        var t = '';

        if (parts.username) {
            t += URI.encode(parts.username);

            if (parts.password) {
                t += ':' + URI.encode(parts.password);
            }

            t += "@";
        }

        return t;
    };
    URI.buildQuery = function(data, duplicates) {
        // according to http://tools.ietf.org/html/rfc3986 or http://labs.apache.org/webarch/uri/rfc/rfc3986.html
        // being -._~!$&'()*+,;=:@/? %HEX and alnum are allowed
        // the RFC explicitly states ?/foo being a valid use case, no mention of parameter syntax!
        // URI.js treats the query string as being application/x-www-form-urlencoded
        // see http://www.w3.org/TR/REC-html40/interact/forms.html#form-content-type

        var t = "";
        for (var key in data) {
            if (Object.hasOwnProperty.call(data, key) && key) {
                if (isArray(data[key])) {
                    var unique = {};
                    for (var i = 0, length = data[key].length; i < length; i++) {
                        if (data[key][i] !== undefined && unique[data[key][i] + ""] === undefined) {
                            t += "&" + URI.buildQueryParameter(key, data[key][i]);
                            if (duplicates !== true) {
                                unique[data[key][i] + ""] = true;
                            }
                        }
                    }
                } else if (data[key] !== undefined) {
                    t += '&' + URI.buildQueryParameter(key, data[key]);
                }
            }
        }

        return t.substring(1);
    };
    URI.buildQueryParameter = function(name, value) {
        // http://www.w3.org/TR/REC-html40/interact/forms.html#form-content-type -- application/x-www-form-urlencoded
        // don't append "=" for null values, according to http://dvcs.w3.org/hg/url/raw-file/tip/Overview.html#url-parameter-serialization
        return URI.encodeQuery(name) + (value !== null ? "=" + URI.encodeQuery(value) : "");
    };

    URI.addQuery = function(data, name, value) {
        if (typeof name === "object") {
            for (var key in name) {
                if (Object.prototype.hasOwnProperty.call(name, key)) {
                    URI.addQuery(data, key, name[key]);
                }
            }
        } else if (typeof name === "string") {
            if (data[name] === undefined) {
                data[name] = value;
                return;
            } else if (typeof data[name] === "string") {
                data[name] = [data[name]];
            }

            if (!isArray(value)) {
                value = [value];
            }

            data[name] = data[name].concat(value);
        } else {
            throw new TypeError("URI.addQuery() accepts an object, string as the name parameter");
        }
    };
    URI.removeQuery = function(data, name, value) {
        if (isArray(name)) {
            for (var i = 0, length = name.length; i < length; i++) {
                data[name[i]] = undefined;
            }
        } else if (typeof name === "object") {
            for (var key in name) {
                if (Object.prototype.hasOwnProperty.call(name, key)) {
                    URI.removeQuery(data, key, name[key]);
                }
            }
        } else if (typeof name === "string") {
            if (value !== undefined) {
                if (data[name] === value) {
                    data[name] = undefined;
                } else if (isArray(data[name])) {
                    data[name] = filterArrayValues(data[name], value);
                }
            } else {
                data[name] = undefined;
            }
        } else {
            throw new TypeError("URI.addQuery() accepts an object, string as the first parameter");
        }
    };

    URI.commonPath = function(one, two) {
        var length = Math.min(one.length, two.length),
            pos;

        // find first non-matching character
        for (pos = 0; pos < length; pos++) {
            if (one[pos] !== two[pos]) {
                pos--;
                break;
            }
        }

        if (pos < 1) {
            return one[0] === two[0] && one[0] === '/' ? '/' : '';
        }

        // revert to last /
        if (one[pos] !== '/') {
            pos = one.substring(0, pos).lastIndexOf('/');
        }

        return one.substring(0, pos + 1);
    };

    URI.withinString = function(string, callback) {
        // expression used is "gruber revised" (@gruber v2) determined to be the best solution in
        // a regex sprint we did a couple of ages ago at
        // * http://mathiasbynens.be/demo/url-regex
        // * http://rodneyrehm.de/t/url-regex.html

        return string.replace(URI.find_uri_expression, callback);
    };

    URI.ensureValidHostname = function(v) {
        // Theoretically URIs allow percent-encoding in Hostnames (according to RFC 3986)
        // they are not part of DNS and therefore ignored by URI.js

        if (v.match(URI.invalid_hostname_characters)) {
            // test punycode
            if (!punycode) {
                throw new TypeError("Hostname '" + v + "' contains characters other than [A-Z0-9.-] and Punycode.js is not available");
            }

            if (punycode.toASCII(v).match(URI.invalid_hostname_characters)) {
                throw new TypeError("Hostname '" + v + "' contains characters other than [A-Z0-9.-]");
            }
        }
    };

    p.build = function(deferBuild) {
        if (deferBuild === true) {
            this._deferred_build = true;
        } else if (deferBuild === undefined || this._deferred_build) {
            this._string = URI.build(this._parts);
            this._deferred_build = false;
        }

        return this;
    };

    p.clone = function() {
        return new URI(this);
    };

    p.toString = function() {
        return this.build(false)._string;
    };
    p.valueOf = function() {
        return this.toString();
    };

// generate simple accessors
    _parts = {protocol: 'protocol', username: 'username', password: 'password', hostname: 'hostname',  port: 'port'};
    generateAccessor = function(_part){
        return function(v, build) {
            if (v === undefined) {
                return this._parts[_part] || "";
            } else {
                this._parts[_part] = v;
                this.build(!build);
                return this;
            }
        };
    };

    for (_part in _parts) {
        p[_part] = generateAccessor(_parts[_part]);
    }

// generate accessors with optionally prefixed input
    _parts = {query: '?', fragment: '#'};
    generateAccessor = function(_part, _key){
        return function(v, build) {
            if (v === undefined) {
                return this._parts[_part] || "";
            } else {
                if (v !== null) {
                    v = v + "";
                    if (v[0] === _key) {
                        v = v.substring(1);
                    }
                }

                this._parts[_part] = v;
                this.build(!build);
                return this;
            }
        };
    };

    for (_part in _parts) {
        p[_part] = generateAccessor(_part, _parts[_part]);
    }

// generate accessors with prefixed output
    _parts = {search: ['?', 'query'], hash: ['#', 'fragment']};
    generateAccessor = function(_part, _key){
        return function(v, build) {
            var t = this[_part](v, build);
            return typeof t === "string" && t.length ? (_key + t) : t;
        };
    };

    for (_part in _parts) {
        p[_part] = generateAccessor(_parts[_part][1], _parts[_part][0]);
    }

    p.pathname = function(v, build) {
        if (v === undefined || v === true) {
            var res = this._parts.path || (this._parts.urn ? '' : '/');
            return v ? URI.decodePath(res) : res;
        } else {
            this._parts.path = v ? URI.recodePath(v) : "/";
            this.build(!build);
            return this;
        }
    };
    p.path = p.pathname;
    p.href = function(href, build) {
        if (href === undefined) {
            return this.toString();
        } else {
            this._string = "";
            this._parts = {
                protocol: null,
                username: null,
                password: null,
                hostname: null,
                urn: null,
                port: null,
                path: null,
                query: null,
                fragment: null
            };

            var _URI = href instanceof URI,
                _object = typeof href === "object" && (href.hostname || href.path),
                key;

            if (typeof href === "string") {
                this._parts = URI.parse(href);
            } else if (_URI || _object) {
                var src = _URI ? href._parts : href;
                for (key in src) {
                    if (Object.hasOwnProperty.call(this._parts, key)) {
                        this._parts[key] = src[key];
                    }
                }
            } else {
                throw new TypeError("invalid input");
            }

            this.build(!build);
            return this;
        }
    };

// identification accessors
    p.is = function(what) {
        var ip = false,
            ip4 = false,
            ip6 = false,
            name = false,
            sld = false,
            idn = false,
            punycode = false,
            relative = !this._parts.urn;

        if (this._parts.hostname) {
            relative = false;
            ip4 = URI.ip4_expression.test(this._parts.hostname);
            ip6 = URI.ip6_expression.test(this._parts.hostname);
            ip = ip4 || ip6;
            name = !ip;
            sld = name && SLD && SLD.has(this._parts.hostname);
            idn = name && URI.idn_expression.test(this._parts.hostname);
            punycode = name && URI.punycode_expression.test(this._parts.hostname);
        }

        //jomaras add
        if(this._parts.protocol == "file")
        {
            relative = false;
        }

        switch (what.toLowerCase()) {
            case 'relative':
                return relative;

            case 'absolute':
                return !relative;

            // hostname identification
            case 'domain':
            case 'name':
                return name;

            case 'sld':
                return sld;

            case 'ip':
                return ip;

            case 'ip4':
            case 'ipv4':
            case 'inet4':
                return ip4;

            case 'ip6':
            case 'ipv6':
            case 'inet6':
                return ip6;

            case 'idn':
                return idn;

            case 'url':
                return !this._parts.urn;

            case 'urn':
                return !!this._parts.urn;

            case 'punycode':
                return punycode;
        }

        return null;
    };

// component specific input validation
    var _protocol = p.protocol,
        _port = p.port,
        _hostname = p.hostname;

    p.protocol = function(v, build) {
        if (v !== undefined) {
            if (v) {
                // accept trailing ://
                v = v.replace(/:(\/\/)?$/, '');

                if (v.match(/[^a-zA-z0-9\.+-]/)) {
                    throw new TypeError("Protocol '" + v + "' contains characters other than [A-Z0-9.+-]");
                }
            }
        }
        return _protocol.call(this, v, build);
    };
    p.scheme = p.protocol;
    p.port = function(v, build) {
        if (this._parts.urn) {
            return v === undefined ? '' : this;
        }

        if (v !== undefined) {
            if (v === 0) {
                v = null;
            }

            if (v) {
                v += "";
                if (v[0] === ":") {
                    v = v.substring(1);
                }

                if (v.match(/[^0-9]/)) {
                    throw new TypeError("Port '" + v + "' contains characters other than [0-9]");
                }
            }
        }
        return _port.call(this, v, build);
    };
    p.hostname = function(v, build) {
        if (this._parts.urn) {
            return v === undefined ? '' : this;
        }

        if (v !== undefined) {
            var x = {};
            URI.parseHost(v, x);
            v = x.hostname;
        }
        return _hostname.call(this, v, build);
    };

// combination accessors
    p.host = function(v, build) {
        if (this._parts.urn) {
            return v === undefined ? '' : this;
        }

        if (v === undefined) {
            return this._parts.hostname ? URI.buildHost(this._parts) : "";
        } else {
            URI.parseHost(v, this._parts);
            this.build(!build);
            return this;
        }
    };
    p.authority = function(v, build) {
        if (this._parts.urn) {
            return v === undefined ? '' : this;
        }

        if (v === undefined) {
            return this._parts.hostname ? URI.buildAuthority(this._parts) : "";
        } else {
            URI.parseAuthority(v, this._parts);
            this.build(!build);
            return this;
        }
    };
    p.userinfo = function(v, build) {
        if (this._parts.urn) {
            return v === undefined ? '' : this;
        }

        if (v === undefined) {
            if (!this._parts.username) {
                return "";
            }

            var t = URI.buildUserinfo(this._parts);
            return t.substring(0, t.length -1);
        } else {
            if (v[v.length-1] !== '@') {
                v += '@';
            }

            URI.parseUserinfo(v, this._parts);
            this.build(!build);
            return this;
        }
    };

// fraction accessors
    p.subdomain = function(v, build) {
        if (this._parts.urn) {
            return v === undefined ? '' : this;
        }

        // convenience, return "www" from "www.example.org"
        if (v === undefined) {
            if (!this._parts.hostname || this.is('IP')) {
                return "";
            }

            // grab domain and add another segment
            var end = this._parts.hostname.length - this.domain().length - 1;
            return this._parts.hostname.substring(0, end) || "";
        } else {
            var e = this._parts.hostname.length - this.domain().length,
                sub = this._parts.hostname.substring(0, e),
                replace = new RegExp('^' + escapeRegEx(sub));

            if (v && v[v.length - 1] !== '.') {
                v += ".";
            }

            if (v) {
                URI.ensureValidHostname(v);
            }

            this._parts.hostname = this._parts.hostname.replace(replace, v);
            this.build(!build);
            return this;
        }
    };
    p.domain = function(v, build) {
        if (this._parts.urn) {
            return v === undefined ? '' : this;
        }

        if (typeof v === 'boolean') {
            build = v;
            v = undefined;
        }

        // convenience, return "example.org" from "www.example.org"
        if (v === undefined) {
            if (!this._parts.hostname || this.is('IP')) {
                return "";
            }

            // if hostname consists of 1 or 2 segments, it must be the domain
            var t = this._parts.hostname.match(/\./g);
            if (t && t.length < 2) {
                return this._parts.hostname;
            }

            // grab tld and add another segment
            var end = this._parts.hostname.length - this.tld(build).length - 1;
            end = this._parts.hostname.lastIndexOf('.', end -1) + 1;
            return this._parts.hostname.substring(end) || "";
        } else {
            if (!v) {
                throw new TypeError("cannot set domain empty");
            }

            URI.ensureValidHostname(v);

            if (!this._parts.hostname || this.is('IP')) {
                this._parts.hostname = v;
            } else {
                var replace = new RegExp(escapeRegEx(this.domain()) + "$");
                this._parts.hostname = this._parts.hostname.replace(replace, v);
            }

            this.build(!build);
            return this;
        }
    };
    p.tld = function(v, build) {
        if (this._parts.urn) {
            return v === undefined ? '' : this;
        }

        if (typeof v === 'boolean') {
            build = v;
            v = undefined;
        }

        // return "org" from "www.example.org"
        if (v === undefined) {
            if (!this._parts.hostname || this.is('IP')) {
                return "";
            }

            var pos = this._parts.hostname.lastIndexOf('.'),
                tld = this._parts.hostname.substring(pos + 1);

            if (build !== true && SLD && SLD.list[tld.toLowerCase()]) {
                return SLD.get(this._parts.hostname) || tld;
            }

            return tld;
        } else {
            var replace;
            if (!v) {
                throw new TypeError("cannot set TLD empty");
            } else if (v.match(/[^a-zA-Z0-9-]/)) {
                if (SLD && SLD.is(v)) {
                    replace = new RegExp(escapeRegEx(this.tld()) + "$");
                    this._parts.hostname = this._parts.hostname.replace(replace, v);
                } else {
                    throw new TypeError("TLD '" + v + "' contains characters other than [A-Z0-9]");
                }
            } else if (!this._parts.hostname || this.is('IP')) {
                throw new ReferenceError("cannot set TLD on non-domain host");
            } else {
                replace = new RegExp(escapeRegEx(this.tld()) + "$");
                this._parts.hostname = this._parts.hostname.replace(replace, v);
            }

            this.build(!build);
            return this;
        }
    };
    p.directory = function(v, build) {
        if (this._parts.urn) {
            return v === undefined ? '' : this;
        }

        if (v === undefined || v === true) {
            if (!this._parts.path && !this._parts.hostname) {
                return '';
            }

            if (this._parts.path === '/') {
                return '/';
            }

            var end = this._parts.path.length - this.filename().length - 1,
                res = this._parts.path.substring(0, end) || (this._parts.hostname ? "/" : "");

            return v ? URI.decodePath(res) : res;

        } else {
            var e = this._parts.path.length - this.filename().length,
                directory = this._parts.path.substring(0, e),
                replace = new RegExp('^' + escapeRegEx(directory));

            // fully qualifier directories begin with a slash
            if (!this.is('relative')) {
                if (!v) {
                    v = '/';
                }

                if (v[0] !== '/') {
                    v = "/" + v;
                }
            }

            // directories always end with a slash
            if (v && v[v.length - 1] !== '/') {
                v += '/';
            }

            v = URI.recodePath(v);
            this._parts.path = this._parts.path.replace(replace, v);
            this.build(!build);
            return this;
        }
    };
    p.filename = function(v, build) {
        if (this._parts.urn) {
            return v === undefined ? '' : this;
        }

        if (v === undefined || v === true) {
            if (!this._parts.path || this._parts.path === '/') {
                return "";
            }

            var pos = this._parts.path.lastIndexOf('/'),
                res = this._parts.path.substring(pos+1);

            return v ? URI.decodePathSegment(res) : res;
        } else {
            var mutatedDirectory = false;
            if (v[0] === '/') {
                v = v.substring(1);
            }

            if (v.match(/\.?\//)) {
                mutatedDirectory = true;
            }

            var replace = new RegExp(escapeRegEx(this.filename()) + "$");
            v = URI.recodePath(v);
            this._parts.path = this._parts.path.replace(replace, v);

            if (mutatedDirectory) {
                this.normalizePath(build);
            } else {
                this.build(!build);
            }

            return this;
        }
    };
    p.suffix = function(v, build) {
        if (this._parts.urn) {
            return v === undefined ? '' : this;
        }

        if (v === undefined || v === true) {
            if (!this._parts.path || this._parts.path === '/') {
                return "";
            }

            var filename = this.filename(),
                pos = filename.lastIndexOf('.'),
                s, res;

            if (pos === -1) {
                return "";
            }

            // suffix may only contain alnum characters (yup, I made this up.)
            s = filename.substring(pos+1);
            res = (/^[a-z0-9%]+$/i).test(s) ? s : "";
            return v ? URI.decodePathSegment(res) : res;
        } else {
            if (v[0] === '.') {
                v = v.substring(1);
            }

            var suffix = this.suffix(),
                replace;

            if (!suffix) {
                if (!v) {
                    return this;
                }

                this._parts.path += '.' + URI.recodePath(v);
            } else if (!v) {
                replace = new RegExp(escapeRegEx("." + suffix) + "$");
            } else {
                replace = new RegExp(escapeRegEx(suffix) + "$");
            }

            if (replace) {
                v = URI.recodePath(v);
                this._parts.path = this._parts.path.replace(replace, v);
            }

            this.build(!build);
            return this;
        }
    };
    p.segment = function(segment, v, build) {
        var separator = this._parts.urn ? ':' : '/',
            path = this.path(),
            absolute = path.substring(0, 1) === '/',
            segments = path.split(separator);

        if (typeof segment !== 'number') {
            build = v;
            v = segment;
            segment = undefined;
        }

        if (segment !== undefined && typeof segment !== 'number') {
            throw new Error("Bad segment '" + segment + "', must be 0-based integer");
        }

        if (absolute) {
            segments.shift();
        }

        if (segment < 0) {
            // allow negative indexes to address from the end
            segment = Math.max(segments.length + segment, 0);
        }

        if (v === undefined) {
            return segment === undefined
                ? segments
                : segments[segment];
        } else if (segment === null || segments[segment] === undefined) {
            if (isArray(v)) {
                segments = v;
            } else if (v || (typeof v === "string" && v.length)) {
                if (segments[segments.length -1] === "") {
                    // empty trailing elements have to be overwritten
                    // to prefent results such as /foo//bar
                    segments[segments.length -1] = v;
                } else {
                    segments.push(v);
                }
            }
        } else {
            if (v || (typeof v === "string" && v.length)) {
                segments[segment] = v;
            } else {
                segments.splice(segment, 1);
            }
        }

        if (absolute) {
            segments.unshift("");
        }

        return this.path(segments.join(separator), build);
    };

// mutating query string
    var q = p.query;
    p.query = function(v, build) {
        if (v === true) {
            return URI.parseQuery(this._parts.query);
        } else if (v !== undefined && typeof v !== "string") {
            this._parts.query = URI.buildQuery(v);
            this.build(!build);
            return this;
        } else {
            return q.call(this, v, build);
        }
    };
    p.addQuery = function(name, value, build) {
        var data = URI.parseQuery(this._parts.query);
        URI.addQuery(data, name, value);
        this._parts.query = URI.buildQuery(data);
        if (typeof name !== "string") {
            build = value;
        }

        this.build(!build);
        return this;
    };
    p.removeQuery = function(name, value, build) {
        var data = URI.parseQuery(this._parts.query);
        URI.removeQuery(data, name, value);
        this._parts.query = URI.buildQuery(data);
        if (typeof name !== "string") {
            build = value;
        }

        this.build(!build);
        return this;
    };
    p.addSearch = p.addQuery;
    p.removeSearch = p.removeQuery;

// sanitizing URLs
    p.normalize = function() {
        if (this._parts.urn) {
            return this
                .normalizeProtocol(false)
                .normalizeQuery(false)
                .normalizeFragment(false)
                .build();
        }

        return this
            .normalizeProtocol(false)
            .normalizeHostname(false)
            .normalizePort(false)
            .normalizePath(false)
            .normalizeQuery(false)
            .normalizeFragment(false)
            .build();
    };
    p.normalizeProtocol = function(build) {
        if (typeof this._parts.protocol === "string") {
            this._parts.protocol = this._parts.protocol.toLowerCase();
            this.build(!build);
        }

        return this;
    };
    p.normalizeHostname = function(build) {
        if (this._parts.hostname) {
            if (this.is('IDN') && punycode) {
                this._parts.hostname = punycode.toASCII(this._parts.hostname);
            } else if (this.is('IPv6') && IPv6) {
                this._parts.hostname = IPv6.best(this._parts.hostname);
            }

            this._parts.hostname = this._parts.hostname.toLowerCase();
            this.build(!build);
        }

        return this;
    };
    p.normalizePort = function(build) {
        // remove port of it's the protocol's default
        if (typeof this._parts.protocol === "string" && this._parts.port === URI.defaultPorts[this._parts.protocol]) {
            this._parts.port = null;
            this.build(!build);
        }

        return this;
    };
    p.normalizePath = function(build) {
        if (this._parts.urn) {
            return this;
        }

        if (!this._parts.path || this._parts.path === '/') {
            return this;
        }

        var _was_relative,
            _was_relative_prefix,
            _path = this._parts.path,
            _parent, _pos;

        // handle relative paths
        if (_path[0] !== '/') {
            if (_path[0] === '.') {
                _was_relative_prefix = _path.substring(0, _path.indexOf('/'));
            }
            _was_relative = true;
            _path = '/' + _path;
        }
        // resolve simples
        _path = _path.replace(/(\/(\.\/)+)|\/{2,}/g, '/');
        // resolve parents
        while (true) {
            _parent = _path.indexOf('/../');
            if (_parent === -1) {
                // no more ../ to resolve
                break;
            } else if (_parent === 0) {
                // top level cannot be relative...
                _path = _path.substring(3);
                break;
            }

            _pos = _path.substring(0, _parent).lastIndexOf('/');
            if (_pos === -1) {
                _pos = _parent;
            }
            _path = _path.substring(0, _pos) + _path.substring(_parent + 3);
        }
        // revert to relative
        if (_was_relative && this.is('relative')) {
            if (_was_relative_prefix){
                _path = _was_relative_prefix + _path;
            } else {
                _path = _path.substring(1);
            }
        }

        _path = URI.recodePath(_path);
        this._parts.path = _path;
        this.build(!build);
        return this;
    };
    p.normalizePathname = p.normalizePath;
    p.normalizeQuery = function(build) {
        if (typeof this._parts.query === "string") {
            if (!this._parts.query.length) {
                this._parts.query = null;
            } else {
                this.query(URI.parseQuery(this._parts.query));
            }

            this.build(!build);
        }

        return this;
    };
    p.normalizeFragment = function(build) {
        if (!this._parts.fragment) {
            this._parts.fragment = null;
            this.build(!build);
        }

        return this;
    };
    p.normalizeSearch = p.normalizeQuery;
    p.normalizeHash = p.normalizeFragment;

    p.iso8859 = function() {
        // expect unicode input, iso8859 output
        var e = URI.encode,
            d = URI.decode;

        URI.encode = escape;
        URI.decode = decodeURIComponent;
        this.normalize();
        URI.encode = e;
        URI.decode = d;
        return this;
    };

    p.unicode = function() {
        // expect iso8859 input, unicode output
        var e = URI.encode,
            d = URI.decode;

        URI.encode = strictEncodeURIComponent;
        URI.decode = unescape;
        this.normalize();
        URI.encode = e;
        URI.decode = d;
        return this;
    };

    p.readable = function() {
        var uri = this.clone();
        // removing username, password, because they shouldn't be displayed according to RFC 3986
        uri.username("").password("").normalize();
        var t = '';
        if (uri._parts.protocol) {
            t += uri._parts.protocol + '://';
        }

        if (uri._parts.hostname) {
            if (uri.is('punycode') && punycode) {
                t += punycode.toUnicode(uri._parts.hostname);
                if (uri._parts.port) {
                    t += ":" + uri._parts.port;
                }
            } else {
                t += uri.host();
            }
        }

        if (uri._parts.hostname && uri._parts.path && uri._parts.path[0] !== '/') {
            t += '/';
        }

        t += uri.path(true);
        if (uri._parts.query) {
            var q = '';
            for (var i = 0, qp = uri._parts.query.split('&'), l = qp.length; i < l; i++) {
                var kv = (qp[i] || "").split('=');
                q += '&' + URI.decodeQuery(kv[0])
                    .replace(/&/g, '%26');

                if (kv[1] !== undefined) {
                    q += "=" + URI.decodeQuery(kv[1])
                        .replace(/&/g, '%26');
                }
            }
            t += '?' + q.substring(1);
        }

        t += uri.hash();
        return t;
    };

// resolving relative and absolute URLs
    p.absoluteTo = function(base) {
        var resolved = this.clone(),
            properties = ['protocol', 'username', 'password', 'hostname', 'port'],
            basedir, i, p;

        if (this._parts.urn) {
            throw new Error('URNs do not have any generally defined hierachical components');
        }

        if (this._parts.hostname) {
            return resolved;
        }

        if (!(base instanceof URI)) {
            base = new URI(base);
        }

        for (i = 0, p; p = properties[i]; i++) {
            resolved._parts[p] = base._parts[p];
        }

        properties = ['query', 'path'];
        for (i = 0, p; p = properties[i]; i++) {
            if (!resolved._parts[p] && base._parts[p]) {
                resolved._parts[p] = base._parts[p];
            }
        }

        if (resolved.path()[0] !== '/') {
            basedir = base.directory();
            resolved._parts.path = (basedir ? (basedir + '/') : '') + resolved._parts.path;
            resolved.normalizePath();
        }

        resolved.build();
        return resolved;
    };
    p.relativeTo = function(base) {
        var relative = this.clone(),
            properties = ['protocol', 'username', 'password', 'hostname', 'port'],
            common,
            _base;

        if (this._parts.urn) {
            throw new Error('URNs do not have any generally defined hierachical components');
        }

        if (!(base instanceof URI)) {
            base = new URI(base);
        }

        if (this.path()[0] !== '/' || base.path()[0] !== '/') {
            throw new Error('Cannot calculate common path from non-relative URLs');
        }

        common = URI.commonPath(relative.path(), base.path());
        _base = base.directory();

        for (var i = 0, p; p = properties[i]; i++) {
            relative._parts[p] = null;
        }

        if (!common || common === '/') {
            return relative;
        }

        if(this._parts.protocol === "file" && base._parts.protocol === "file")
        {
            return this._relativeToOnFilePaths(base, common);
        }

        if (_base + '/' === common) {
            relative._parts.path = './' + relative.filename();
        } else {
            var parents = '../',
                _common = new RegExp('^' + escapeRegEx(common)),
                _parents = _base.replace(_common, '/').match(/\//g).length -1;

            while (_parents--) {
                parents += '../';
            }

            relative._parts.path = relative._parts.path.replace(_common, parents);
        }

        relative.build();
        return relative;
    };

    //jomaras - badly
    p._relativeToOnFilePaths = function(base, common)
    {
        var thisWithoutCommonUri = new URI(this._parts.path.replace(common, ""));
        var baseWithoutCommonUri = new URI(base._parts.path.replace(common, ""));

        if(baseWithoutCommonUri.directory() == "")
        {
            return thisWithoutCommonUri;
        }

        var thisPath = thisWithoutCommonUri.build();

        thisPath = thisPath._string.replace(/[^\/]*\//gi, "../");

        return new URI(thisPath).directory() + "/" + baseWithoutCommonUri.directory() + "/" + thisWithoutCommonUri.filename();
    }

// comparing URIs
    p.equals = function(uri) {
        var one = this.clone(),
            two = new URI(uri),
            one_map = {},
            two_map = {},
            checked = {},
            one_query,
            two_query,
            key;

        one.normalize();
        two.normalize();

        // exact match
        if (one.toString() === two.toString()) {
            return true;
        }

        // extract query string
        one_query = one.query();
        two_query = two.query();
        one.query("");
        two.query("");

        // definitely not equal if not even non-query parts match
        if (one.toString() !== two.toString()) {
            return false;
        }

        // query parameters have the same length, even if they're permutated
        if (one_query.length !== two_query.length) {
            return false;
        }

        one_map = URI.parseQuery(one_query);
        two_map = URI.parseQuery(two_query);

        for (key in one_map) {
            if (Object.prototype.hasOwnProperty.call(one_map, key)) {
                if (!isArray(one_map[key])) {
                    if (one_map[key] !== two_map[key]) {
                        return false;
                    }
                } else {
                    if (!isArray(two_map[key])) {
                        return false;
                    }

                    // arrays can't be equal if they have different amount of content
                    if (one_map[key].length !== two_map[key].length) {
                        return false;
                    }

                    one_map[key].sort();
                    two_map[key].sort();

                    for (var i = 0, l = one_map[key].length; i < l; i++) {
                        if (one_map[key][i] !== two_map[key][i]) {
                            return false;
                        }
                    }
                }

                checked[key] = true;
            }
        }

        for (key in two_map) {
            if (Object.prototype.hasOwnProperty.call(two_map, key)) {
                if (!checked[key]) {
                    // two contains a parameter not present in one
                    return false;
                }
            }
        }

        return true;
    };
    if(Firecrow != null && Firecrow.UriHelper != null)
        Firecrow.UriHelper.URI = URI
    /*(typeof module !== 'undefined' && module.exports
        ? module.exports = URI
        : Firecrow.UriHelper.URI = URI);*/

})();

/******/
}});

if(usesModule)
{
    exports.UriHelper = FBL.Firecrow.UriHelper;
}

var EXPORTED_SYMBOLS = ["UriHelper"];
FBL.ns(function () { with (FBL) {
/*************************************************************/
Firecrow.TimerHelper =
{
    createTimer: function()
    {
        return new Firecrow.TimerHelper.Timer();
    }
};

Firecrow.TimerHelper.Timer = function()
{
    this.startTime = new Date();
};

Firecrow.TimerHelper.Timer.prototype =
{
    getElapsedTimeInSeconds: function()
    {
        if(this.startTime == null) { return -1; }

        return Math.round((new Date() - this.startTime)/1000); //take ms away
    },

    hasMoreThanSecondsElapsed: function(seconds)
    {
        return this.getElapsedTimeInSeconds() > seconds;
    }
};
}});/*
 Copyright (C) 2013 Ariya Hidayat <ariya.hidayat@gmail.com>
 Copyright (C) 2013 Thaddee Tyl <thaddee.tyl@gmail.com>
 Copyright (C) 2013 Mathias Bynens <mathias@qiwi.be>
 Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>
 Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>
 Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>
 Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>
 Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>
 Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>
 Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com>

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 * Redistributions of source code must retain the above copyright
 notice, this list of conditions and the following disclaimer.
 * Redistributions in binary form must reproduce the above copyright
 notice, this list of conditions and the following disclaimer in the
 documentation and/or other materials provided with the distribution.

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
 DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*jslint bitwise:true plusplus:true */
/*global esprima:true, define:true, exports:true, window: true,
 createLocationMarker: true,
 throwError: true, generateStatement: true, peek: true,
 parseAssignmentExpression: true, parseBlock: true, parseExpression: true,
 parseFunctionDeclaration: true, parseFunctionExpression: true,
 parseFunctionSourceElements: true, parseVariableIdentifier: true,
 parseLeftHandSideExpression: true,
 parseUnaryExpression: true,
 parseStatement: true, parseSourceElement: true */

(function (root, factory) {
    'use strict';

    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,
    // Rhino, and plain browser loading.
    if (typeof define === 'function' && define.amd) {
        define(['exports'], factory);
    } else if (typeof exports !== 'undefined') {
        factory(exports);
    } else {
        factory((root.esprima = {}));
    }
}(this, function (exports) {
    'use strict';

    var Token,
        TokenName,
        FnExprTokens,
        Syntax,
        PropertyKind,
        Messages,
        Regex,
        SyntaxTreeDelegate,
        source,
        strict,
        index,
        lineNumber,
        lineStart,
        length,
        delegate,
        lookahead,
        state,
        extra;

    Token = {
        BooleanLiteral: 1,
        EOF: 2,
        Identifier: 3,
        Keyword: 4,
        NullLiteral: 5,
        NumericLiteral: 6,
        Punctuator: 7,
        StringLiteral: 8,
        RegularExpression: 9
    };

    TokenName = {};
    TokenName[Token.BooleanLiteral] = 'Boolean';
    TokenName[Token.EOF] = '<end>';
    TokenName[Token.Identifier] = 'Identifier';
    TokenName[Token.Keyword] = 'Keyword';
    TokenName[Token.NullLiteral] = 'Null';
    TokenName[Token.NumericLiteral] = 'Numeric';
    TokenName[Token.Punctuator] = 'Punctuator';
    TokenName[Token.StringLiteral] = 'String';
    TokenName[Token.RegularExpression] = 'RegularExpression';

    // A function following one of those tokens is an expression.
    FnExprTokens = ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new',
        'return', 'case', 'delete', 'throw', 'void',
        // assignment operators
        '=', '+=', '-=', '*=', '/=', '%=', '<<=', '>>=', '>>>=',
        '&=', '|=', '^=', ',',
        // binary/unary operators
        '+', '-', '*', '/', '%', '++', '--', '<<', '>>', '>>>', '&',
        '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=',
        '<=', '<', '>', '!=', '!=='];

    Syntax = {
        AssignmentExpression: 'AssignmentExpression',
        ArrayExpression: 'ArrayExpression',
        BlockStatement: 'BlockStatement',
        BinaryExpression: 'BinaryExpression',
        BreakStatement: 'BreakStatement',
        CallExpression: 'CallExpression',
        CatchClause: 'CatchClause',
        ConditionalExpression: 'ConditionalExpression',
        ContinueStatement: 'ContinueStatement',
        DoWhileStatement: 'DoWhileStatement',
        DebuggerStatement: 'DebuggerStatement',
        EmptyStatement: 'EmptyStatement',
        ExpressionStatement: 'ExpressionStatement',
        ForStatement: 'ForStatement',
        ForInStatement: 'ForInStatement',
        FunctionDeclaration: 'FunctionDeclaration',
        FunctionExpression: 'FunctionExpression',
        Identifier: 'Identifier',
        IfStatement: 'IfStatement',
        Literal: 'Literal',
        LabeledStatement: 'LabeledStatement',
        LogicalExpression: 'LogicalExpression',
        MemberExpression: 'MemberExpression',
        NewExpression: 'NewExpression',
        ObjectExpression: 'ObjectExpression',
        Program: 'Program',
        Property: 'Property',
        ReturnStatement: 'ReturnStatement',
        SequenceExpression: 'SequenceExpression',
        SwitchStatement: 'SwitchStatement',
        SwitchCase: 'SwitchCase',
        ThisExpression: 'ThisExpression',
        ThrowStatement: 'ThrowStatement',
        TryStatement: 'TryStatement',
        UnaryExpression: 'UnaryExpression',
        UpdateExpression: 'UpdateExpression',
        VariableDeclaration: 'VariableDeclaration',
        VariableDeclarator: 'VariableDeclarator',
        WhileStatement: 'WhileStatement',
        WithStatement: 'WithStatement'
    };

    PropertyKind = {
        Data: 1,
        Get: 2,
        Set: 4
    };

    // Error messages should be identical to V8.
    Messages = {
        UnexpectedToken:  'Unexpected token %0',
        UnexpectedNumber:  'Unexpected number',
        UnexpectedString:  'Unexpected string',
        UnexpectedIdentifier:  'Unexpected identifier',
        UnexpectedReserved:  'Unexpected reserved word',
        UnexpectedEOS:  'Unexpected end of input',
        NewlineAfterThrow:  'Illegal newline after throw',
        InvalidRegExp: 'Invalid regular expression',
        UnterminatedRegExp:  'Invalid regular expression: missing /',
        InvalidLHSInAssignment:  'Invalid left-hand side in assignment',
        InvalidLHSInForIn:  'Invalid left-hand side in for-in',
        MultipleDefaultsInSwitch: 'More than one default clause in switch statement',
        NoCatchOrFinally:  'Missing catch or finally after try',
        UnknownLabel: 'Undefined label \'%0\'',
        Redeclaration: '%0 \'%1\' has already been declared',
        IllegalContinue: 'Illegal continue statement',
        IllegalBreak: 'Illegal break statement',
        IllegalReturn: 'Illegal return statement',
        StrictModeWith:  'Strict mode code may not include a with statement',
        StrictCatchVariable:  'Catch variable may not be eval or arguments in strict mode',
        StrictVarName:  'Variable name may not be eval or arguments in strict mode',
        StrictParamName:  'Parameter name eval or arguments is not allowed in strict mode',
        StrictParamDupe: 'Strict mode function may not have duplicate parameter names',
        StrictFunctionName:  'Function name may not be eval or arguments in strict mode',
        StrictOctalLiteral:  'Octal literals are not allowed in strict mode.',
        StrictDelete:  'Delete of an unqualified identifier in strict mode.',
        StrictDuplicateProperty:  'Duplicate data property in object literal not allowed in strict mode',
        AccessorDataProperty:  'Object literal may not have data and accessor property with the same name',
        AccessorGetSet:  'Object literal may not have multiple get/set accessors with the same name',
        StrictLHSAssignment:  'Assignment to eval or arguments is not allowed in strict mode',
        StrictLHSPostfix:  'Postfix increment/decrement may not have eval or arguments operand in strict mode',
        StrictLHSPrefix:  'Prefix increment/decrement may not have eval or arguments operand in strict mode',
        StrictReservedWord:  'Use of future reserved word in strict mode'
    };

    // See also tools/generate-unicode-regex.py.
    Regex = {
        NonAsciiIdentifierStart: new RegExp('[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F0\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]'),
        NonAsciiIdentifierPart: new RegExp('[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0\u08A2-\u08AC\u08E4-\u08FE\u0900-\u0963\u0966-\u096F\u0971-\u0977\u0979-\u097F\u0981-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C01-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C82\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D02\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F0\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191C\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1D00-\u1DE6\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA697\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A\uAA7B\uAA80-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE26\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]')
    };

    // Ensure the condition is true, otherwise throw an error.
    // This is only to have a better contract semantic, i.e. another safety net
    // to catch a logic error. The condition shall be fulfilled in normal case.
    // Do NOT use this to enforce a certain condition on any user input.

    function assert(condition, message) {
        if (!condition) {
            throw new Error('ASSERT: ' + message);
        }
    }

    function isDecimalDigit(ch) {
        return (ch >= 48 && ch <= 57);   // 0..9
    }

    function isHexDigit(ch) {
        return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;
    }

    function isOctalDigit(ch) {
        return '01234567'.indexOf(ch) >= 0;
    }


    // 7.2 White Space

    function isWhiteSpace(ch) {
        return (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) ||
            (ch >= 0x1680 && [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(ch) >= 0);
    }

    // 7.3 Line Terminators

    function isLineTerminator(ch) {
        return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029);
    }

    // 7.6 Identifier Names and Identifiers

    function isIdentifierStart(ch) {
        return (ch === 36) || (ch === 95) ||  // $ (dollar) and _ (underscore)
            (ch >= 65 && ch <= 90) ||         // A..Z
            (ch >= 97 && ch <= 122) ||        // a..z
            (ch === 92) ||                    // \ (backslash)
            ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch)));
    }

    function isIdentifierPart(ch) {
        return (ch === 36) || (ch === 95) ||  // $ (dollar) and _ (underscore)
            (ch >= 65 && ch <= 90) ||         // A..Z
            (ch >= 97 && ch <= 122) ||        // a..z
            (ch >= 48 && ch <= 57) ||         // 0..9
            (ch === 92) ||                    // \ (backslash)
            ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch)));
    }

    // 7.6.1.2 Future Reserved Words

    function isFutureReservedWord(id) {
        switch (id) {
            case 'class':
            case 'enum':
            case 'export':
            case 'extends':
            case 'import':
            case 'super':
                return true;
            default:
                return false;
        }
    }

    function isStrictModeReservedWord(id) {
        switch (id) {
            case 'implements':
            case 'interface':
            case 'package':
            case 'private':
            case 'protected':
            case 'public':
            case 'static':
            case 'yield':
            case 'let':
                return true;
            default:
                return false;
        }
    }

    function isRestrictedWord(id) {
        return id === 'eval' || id === 'arguments';
    }

    // 7.6.1.1 Keywords

    function isKeyword(id) {
        if (strict && isStrictModeReservedWord(id)) {
            return true;
        }

        // 'const' is specialized as Keyword in V8.
        // 'yield' and 'let' are for compatiblity with SpiderMonkey and ES.next.
        // Some others are from future reserved words.

        switch (id.length) {
            case 2:
                return (id === 'if') || (id === 'in') || (id === 'do');
            case 3:
                return (id === 'var') || (id === 'for') || (id === 'new') ||
                    (id === 'try') || (id === 'let');
            case 4:
                return (id === 'this') || (id === 'else') || (id === 'case') ||
                    (id === 'void') || (id === 'with') || (id === 'enum');
            case 5:
                return (id === 'while') || (id === 'break') || (id === 'catch') ||
                    (id === 'throw') || (id === 'const') || (id === 'yield') ||
                    (id === 'class') || (id === 'super');
            case 6:
                return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
                    (id === 'switch') || (id === 'export') || (id === 'import');
            case 7:
                return (id === 'default') || (id === 'finally') || (id === 'extends');
            case 8:
                return (id === 'function') || (id === 'continue') || (id === 'debugger');
            case 10:
                return (id === 'instanceof');
            default:
                return false;
        }
    }

    // 7.4 Comments

    function addComment(type, value, start, end, loc) {
        var comment, attacher;

        assert(typeof start === 'number', 'Comment must have valid position');

        // Because the way the actual token is scanned, often the comments
        // (if any) are skipped twice during the lexical analysis.
        // Thus, we need to skip adding a comment if the comment array already
        // handled it.
        if (state.lastCommentStart >= start) {
            return;
        }
        state.lastCommentStart = start;

        comment = {
            type: type,
            value: value
        };
        if (extra.range) {
            comment.range = [start, end];
        }
        if (extra.loc) {
            comment.loc = loc;
        }
        extra.comments.push(comment);

        if (extra.attachComment) {
            attacher = {
                comment: comment,
                leading: null,
                trailing: null,
                range: [start, end]
            };
            extra.pendingComments.push(attacher);
        }
    }

    function skipSingleLineComment() {
        var start, loc, ch, comment;

        start = index - 2;
        loc = {
            start: {
                line: lineNumber,
                column: index - lineStart - 2
            }
        };

        while (index < length) {
            ch = source.charCodeAt(index);
            ++index;
            if (isLineTerminator(ch)) {
                if (extra.comments) {
                    comment = source.slice(start + 2, index - 1);
                    loc.end = {
                        line: lineNumber,
                        column: index - lineStart - 1
                    };
                    addComment('Line', comment, start, index - 1, loc);
                }
                if (ch === 13 && source.charCodeAt(index) === 10) {
                    ++index;
                }
                ++lineNumber;
                lineStart = index;
                return;
            }
        }

        if (extra.comments) {
            comment = source.slice(start + 2, index);
            loc.end = {
                line: lineNumber,
                column: index - lineStart
            };
            addComment('Line', comment, start, index, loc);
        }
    }

    function skipMultiLineComment() {
        var start, loc, ch, comment;

        if (extra.comments) {
            start = index - 2;
            loc = {
                start: {
                    line: lineNumber,
                    column: index - lineStart - 2
                }
            };
        }

        while (index < length) {
            ch = source.charCodeAt(index);
            if (isLineTerminator(ch)) {
                if (ch === 13 && source.charCodeAt(index + 1) === 10) {
                    ++index;
                }
                ++lineNumber;
                ++index;
                lineStart = index;
                if (index >= length) {
                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                }
            } else if (ch === 42) {
                // Block comment ends with '*/' (char #42, char #47).
                if (source.charCodeAt(index + 1) === 47) {
                    ++index;
                    ++index;
                    if (extra.comments) {
                        comment = source.slice(start + 2, index - 2);
                        loc.end = {
                            line: lineNumber,
                            column: index - lineStart
                        };
                        addComment('Block', comment, start, index, loc);
                    }
                    return;
                }
                ++index;
            } else {
                ++index;
            }
        }

        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
    }

    function skipComment() {
        var ch, start;

        start = (index === 0);
        while (index < length) {
            ch = source.charCodeAt(index);

            if (isWhiteSpace(ch)) {
                ++index;
            } else if (isLineTerminator(ch)) {
                ++index;
                if (ch === 13 && source.charCodeAt(index) === 10) {
                    ++index;
                }
                ++lineNumber;
                lineStart = index;
                start = true;
            } else if (ch === 47) { // 47 is '/'
                ch = source.charCodeAt(index + 1);
                if (ch === 47) {
                    ++index;
                    ++index;
                    skipSingleLineComment();
                    start = true;
                } else if (ch === 42) {  // 42 is '*'
                    ++index;
                    ++index;
                    skipMultiLineComment();
                } else {
                    break;
                }
            } else if (start && ch === 45) { // 45 is '-'
                // 62 is '>'
                if ((source.charCodeAt(index + 1) === 45) && (source.charCodeAt(index + 2) === 62)) {
                    // '-->' is a single-line comment
                    index += 3;
                    skipSingleLineComment();
                } else {
                    break;
                }
            } else if (ch === 60) { // 60 is '<'
                if (source.slice(index + 1, index + 4) === '!--') {
                    ++index; // `<`
                    ++index; // `!`
                    ++index; // `-`
                    ++index; // `-`
                    skipSingleLineComment();
                } else {
                    break;
                }
            } else {
                break;
            }
        }
    }

    function scanHexEscape(prefix) {
        var i, len, ch, code = 0;

        len = (prefix === 'u') ? 4 : 2;
        for (i = 0; i < len; ++i) {
            if (index < length && isHexDigit(source[index])) {
                ch = source[index++];
                code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
            } else {
                return '';
            }
        }
        return String.fromCharCode(code);
    }

    function getEscapedIdentifier() {
        var ch, id;

        ch = source.charCodeAt(index++);
        id = String.fromCharCode(ch);

        // '\u' (char #92, char #117) denotes an escaped character.
        if (ch === 92) {
            if (source.charCodeAt(index) !== 117) {
                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
            }
            ++index;
            ch = scanHexEscape('u');
            if (!ch || ch === '\\' || !isIdentifierStart(ch.charCodeAt(0))) {
                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
            }
            id = ch;
        }

        while (index < length) {
            ch = source.charCodeAt(index);
            if (!isIdentifierPart(ch)) {
                break;
            }
            ++index;
            id += String.fromCharCode(ch);

            // '\u' (char #92, char #117) denotes an escaped character.
            if (ch === 92) {
                id = id.substr(0, id.length - 1);
                if (source.charCodeAt(index) !== 117) {
                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                }
                ++index;
                ch = scanHexEscape('u');
                if (!ch || ch === '\\' || !isIdentifierPart(ch.charCodeAt(0))) {
                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                }
                id += ch;
            }
        }

        return id;
    }

    function getIdentifier() {
        var start, ch;

        start = index++;
        while (index < length) {
            ch = source.charCodeAt(index);
            if (ch === 92) {
                // Blackslash (char #92) marks Unicode escape sequence.
                index = start;
                return getEscapedIdentifier();
            }
            if (isIdentifierPart(ch)) {
                ++index;
            } else {
                break;
            }
        }

        return source.slice(start, index);
    }

    function scanIdentifier() {
        var start, id, type;

        start = index;

        // Backslash (char #92) starts an escaped character.
        id = (source.charCodeAt(index) === 92) ? getEscapedIdentifier() : getIdentifier();

        // There is no keyword or literal with only one character.
        // Thus, it must be an identifier.
        if (id.length === 1) {
            type = Token.Identifier;
        } else if (isKeyword(id)) {
            type = Token.Keyword;
        } else if (id === 'null') {
            type = Token.NullLiteral;
        } else if (id === 'true' || id === 'false') {
            type = Token.BooleanLiteral;
        } else {
            type = Token.Identifier;
        }

        return {
            type: type,
            value: id,
            lineNumber: lineNumber,
            lineStart: lineStart,
            range: [start, index]
        };
    }


    // 7.7 Punctuators

    function scanPunctuator() {
        var start = index,
            code = source.charCodeAt(index),
            code2,
            ch1 = source[index],
            ch2,
            ch3,
            ch4;

        switch (code) {

            // Check for most common single-character punctuators.
            case 46:   // . dot
            case 40:   // ( open bracket
            case 41:   // ) close bracket
            case 59:   // ; semicolon
            case 44:   // , comma
            case 123:  // { open curly brace
            case 125:  // } close curly brace
            case 91:   // [
            case 93:   // ]
            case 58:   // :
            case 63:   // ?
            case 126:  // ~
                ++index;
                if (extra.tokenize) {
                    if (code === 40) {
                        extra.openParenToken = extra.tokens.length;
                    } else if (code === 123) {
                        extra.openCurlyToken = extra.tokens.length;
                    }
                }
                return {
                    type: Token.Punctuator,
                    value: String.fromCharCode(code),
                    lineNumber: lineNumber,
                    lineStart: lineStart,
                    range: [start, index]
                };

            default:
                code2 = source.charCodeAt(index + 1);

                // '=' (char #61) marks an assignment or comparison operator.
                if (code2 === 61) {
                    switch (code) {
                        case 37:  // %
                        case 38:  // &
                        case 42:  // *:
                        case 43:  // +
                        case 45:  // -
                        case 47:  // /
                        case 60:  // <
                        case 62:  // >
                        case 94:  // ^
                        case 124: // |
                            index += 2;
                            return {
                                type: Token.Punctuator,
                                value: String.fromCharCode(code) + String.fromCharCode(code2),
                                lineNumber: lineNumber,
                                lineStart: lineStart,
                                range: [start, index]
                            };

                        case 33: // !
                        case 61: // =
                            index += 2;

                            // !== and ===
                            if (source.charCodeAt(index) === 61) {
                                ++index;
                            }
                            return {
                                type: Token.Punctuator,
                                value: source.slice(start, index),
                                lineNumber: lineNumber,
                                lineStart: lineStart,
                                range: [start, index]
                            };
                        default:
                            break;
                    }
                }
                break;
        }

        // Peek more characters.

        ch2 = source[index + 1];
        ch3 = source[index + 2];
        ch4 = source[index + 3];

        // 4-character punctuator: >>>=

        if (ch1 === '>' && ch2 === '>' && ch3 === '>') {
            if (ch4 === '=') {
                index += 4;
                return {
                    type: Token.Punctuator,
                    value: '>>>=',
                    lineNumber: lineNumber,
                    lineStart: lineStart,
                    range: [start, index]
                };
            }
        }

        // 3-character punctuators: === !== >>> <<= >>=

        if (ch1 === '>' && ch2 === '>' && ch3 === '>') {
            index += 3;
            return {
                type: Token.Punctuator,
                value: '>>>',
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        if (ch1 === '<' && ch2 === '<' && ch3 === '=') {
            index += 3;
            return {
                type: Token.Punctuator,
                value: '<<=',
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        if (ch1 === '>' && ch2 === '>' && ch3 === '=') {
            index += 3;
            return {
                type: Token.Punctuator,
                value: '>>=',
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        // Other 2-character punctuators: ++ -- << >> && ||

        if (ch1 === ch2 && ('+-<>&|'.indexOf(ch1) >= 0)) {
            index += 2;
            return {
                type: Token.Punctuator,
                value: ch1 + ch2,
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {
            ++index;
            return {
                type: Token.Punctuator,
                value: ch1,
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
    }

    // 7.8.3 Numeric Literals

    function scanHexLiteral(start) {
        var number = '';

        while (index < length) {
            if (!isHexDigit(source[index])) {
                break;
            }
            number += source[index++];
        }

        if (number.length === 0) {
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }

        if (isIdentifierStart(source.charCodeAt(index))) {
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }

        return {
            type: Token.NumericLiteral,
            value: parseInt('0x' + number, 16),
            lineNumber: lineNumber,
            lineStart: lineStart,
            range: [start, index]
        };
    }

    function scanOctalLiteral(start) {
        var number = '0' + source[index++];
        while (index < length) {
            if (!isOctalDigit(source[index])) {
                break;
            }
            number += source[index++];
        }

        if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }

        return {
            type: Token.NumericLiteral,
            value: parseInt(number, 8),
            octal: true,
            lineNumber: lineNumber,
            lineStart: lineStart,
            range: [start, index]
        };
    }

    function scanNumericLiteral() {
        var number, start, ch;

        ch = source[index];
        assert(isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'),
            'Numeric literal must start with a decimal digit or a decimal point');

        start = index;
        number = '';
        if (ch !== '.') {
            number = source[index++];
            ch = source[index];

            // Hex number starts with '0x'.
            // Octal number starts with '0'.
            if (number === '0') {
                if (ch === 'x' || ch === 'X') {
                    ++index;
                    return scanHexLiteral(start);
                }
                if (isOctalDigit(ch)) {
                    return scanOctalLiteral(start);
                }

                // decimal number starts with '0' such as '09' is illegal.
                if (ch && isDecimalDigit(ch.charCodeAt(0))) {
                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                }
            }

            while (isDecimalDigit(source.charCodeAt(index))) {
                number += source[index++];
            }
            ch = source[index];
        }

        if (ch === '.') {
            number += source[index++];
            while (isDecimalDigit(source.charCodeAt(index))) {
                number += source[index++];
            }
            ch = source[index];
        }

        if (ch === 'e' || ch === 'E') {
            number += source[index++];

            ch = source[index];
            if (ch === '+' || ch === '-') {
                number += source[index++];
            }
            if (isDecimalDigit(source.charCodeAt(index))) {
                while (isDecimalDigit(source.charCodeAt(index))) {
                    number += source[index++];
                }
            } else {
                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
            }
        }

        if (isIdentifierStart(source.charCodeAt(index))) {
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }

        return {
            type: Token.NumericLiteral,
            value: parseFloat(number),
            lineNumber: lineNumber,
            lineStart: lineStart,
            range: [start, index]
        };
    }

    // 7.8.4 String Literals

    function scanStringLiteral() {
        var str = '', quote, start, ch, code, unescaped, restore, octal = false;

        quote = source[index];
        assert((quote === '\'' || quote === '"'),
            'String literal must starts with a quote');

        start = index;
        ++index;

        while (index < length) {
            ch = source[index++];

            if (ch === quote) {
                quote = '';
                break;
            } else if (ch === '\\') {
                ch = source[index++];
                if (!ch || !isLineTerminator(ch.charCodeAt(0))) {
                    switch (ch) {
                        case 'n':
                            str += '\n';
                            break;
                        case 'r':
                            str += '\r';
                            break;
                        case 't':
                            str += '\t';
                            break;
                        case 'u':
                        case 'x':
                            restore = index;
                            unescaped = scanHexEscape(ch);
                            if (unescaped) {
                                str += unescaped;
                            } else {
                                index = restore;
                                str += ch;
                            }
                            break;
                        case 'b':
                            str += '\b';
                            break;
                        case 'f':
                            str += '\f';
                            break;
                        case 'v':
                            str += '\x0B';
                            break;

                        default:
                            if (isOctalDigit(ch)) {
                                code = '01234567'.indexOf(ch);

                                // \0 is not octal escape sequence
                                if (code !== 0) {
                                    octal = true;
                                }

                                if (index < length && isOctalDigit(source[index])) {
                                    octal = true;
                                    code = code * 8 + '01234567'.indexOf(source[index++]);

                                    // 3 digits are only allowed when string starts
                                    // with 0, 1, 2, 3
                                    if ('0123'.indexOf(ch) >= 0 &&
                                        index < length &&
                                        isOctalDigit(source[index])) {
                                        code = code * 8 + '01234567'.indexOf(source[index++]);
                                    }
                                }
                                str += String.fromCharCode(code);
                            } else {
                                str += ch;
                            }
                            break;
                    }
                } else {
                    ++lineNumber;
                    if (ch ===  '\r' && source[index] === '\n') {
                        ++index;
                    }
                }
            } else if (isLineTerminator(ch.charCodeAt(0))) {
                break;
            } else {
                str += ch;
            }
        }

        if (quote !== '') {
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }

        return {
            type: Token.StringLiteral,
            value: str,
            octal: octal,
            lineNumber: lineNumber,
            lineStart: lineStart,
            range: [start, index]
        };
    }

    function scanRegExp() {
        var str, ch, start, pattern, flags, value, classMarker = false, restore, terminated = false;

        lookahead = null;
        skipComment();

        start = index;
        ch = source[index];
        assert(ch === '/', 'Regular expression literal must start with a slash');
        str = source[index++];

        while (index < length) {
            ch = source[index++];
            str += ch;
            if (ch === '\\') {
                ch = source[index++];
                // ECMA-262 7.8.5
                if (isLineTerminator(ch.charCodeAt(0))) {
                    throwError({}, Messages.UnterminatedRegExp);
                }
                str += ch;
            } else if (isLineTerminator(ch.charCodeAt(0))) {
                throwError({}, Messages.UnterminatedRegExp);
            } else if (classMarker) {
                if (ch === ']') {
                    classMarker = false;
                }
            } else {
                if (ch === '/') {
                    terminated = true;
                    break;
                } else if (ch === '[') {
                    classMarker = true;
                }
            }
        }

        if (!terminated) {
            throwError({}, Messages.UnterminatedRegExp);
        }

        // Exclude leading and trailing slash.
        pattern = str.substr(1, str.length - 2);

        flags = '';
        while (index < length) {
            ch = source[index];
            if (!isIdentifierPart(ch.charCodeAt(0))) {
                break;
            }

            ++index;
            if (ch === '\\' && index < length) {
                ch = source[index];
                if (ch === 'u') {
                    ++index;
                    restore = index;
                    ch = scanHexEscape('u');
                    if (ch) {
                        flags += ch;
                        for (str += '\\u'; restore < index; ++restore) {
                            str += source[restore];
                        }
                    } else {
                        index = restore;
                        flags += 'u';
                        str += '\\u';
                    }
                } else {
                    str += '\\';
                }
            } else {
                flags += ch;
                str += ch;
            }
        }

        try {
            value = new RegExp(pattern, flags);
        } catch (e) {
            throwError({}, Messages.InvalidRegExp);
        }



        if (extra.tokenize) {
            return {
                type: Token.RegularExpression,
                value: value,
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }
        return {
            literal: str,
            value: value,
            range: [start, index]
        };
    }

    function collectRegex() {
        var pos, loc, regex, token;

        skipComment();

        pos = index;
        loc = {
            start: {
                line: lineNumber,
                column: index - lineStart
            }
        };

        regex = scanRegExp();
        loc.end = {
            line: lineNumber,
            column: index - lineStart
        };

        if (!extra.tokenize) {
            // Pop the previous token, which is likely '/' or '/='
            if (extra.tokens.length > 0) {
                token = extra.tokens[extra.tokens.length - 1];
                if (token.range[0] === pos && token.type === 'Punctuator') {
                    if (token.value === '/' || token.value === '/=') {
                        extra.tokens.pop();
                    }
                }
            }

            extra.tokens.push({
                type: 'RegularExpression',
                value: regex.literal,
                range: [pos, index],
                loc: loc
            });
        }

        return regex;
    }

    function isIdentifierName(token) {
        return token.type === Token.Identifier ||
            token.type === Token.Keyword ||
            token.type === Token.BooleanLiteral ||
            token.type === Token.NullLiteral;
    }

    function advanceSlash() {
        var prevToken,
            checkToken;
        // Using the following algorithm:
        // https://github.com/mozilla/sweet.js/wiki/design
        prevToken = extra.tokens[extra.tokens.length - 1];
        if (!prevToken) {
            // Nothing before that: it cannot be a division.
            return collectRegex();
        }
        if (prevToken.type === 'Punctuator') {
            if (prevToken.value === ')') {
                checkToken = extra.tokens[extra.openParenToken - 1];
                if (checkToken &&
                    checkToken.type === 'Keyword' &&
                    (checkToken.value === 'if' ||
                        checkToken.value === 'while' ||
                        checkToken.value === 'for' ||
                        checkToken.value === 'with')) {
                    return collectRegex();
                }
                return scanPunctuator();
            }
            if (prevToken.value === '}') {
                // Dividing a function by anything makes little sense,
                // but we have to check for that.
                if (extra.tokens[extra.openCurlyToken - 3] &&
                    extra.tokens[extra.openCurlyToken - 3].type === 'Keyword') {
                    // Anonymous function.
                    checkToken = extra.tokens[extra.openCurlyToken - 4];
                    if (!checkToken) {
                        return scanPunctuator();
                    }
                } else if (extra.tokens[extra.openCurlyToken - 4] &&
                    extra.tokens[extra.openCurlyToken - 4].type === 'Keyword') {
                    // Named function.
                    checkToken = extra.tokens[extra.openCurlyToken - 5];
                    if (!checkToken) {
                        return collectRegex();
                    }
                } else {
                    return scanPunctuator();
                }
                // checkToken determines whether the function is
                // a declaration or an expression.
                if (FnExprTokens.indexOf(checkToken.value) >= 0) {
                    // It is an expression.
                    return scanPunctuator();
                }
                // It is a declaration.
                return collectRegex();
            }
            return collectRegex();
        }
        if (prevToken.type === 'Keyword') {
            return collectRegex();
        }
        return scanPunctuator();
    }

    function advance() {
        var ch;

        skipComment();

        if (index >= length) {
            return {
                type: Token.EOF,
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [index, index]
            };
        }

        ch = source.charCodeAt(index);

        // Very common: ( and ) and ;
        if (ch === 40 || ch === 41 || ch === 58) {
            return scanPunctuator();
        }

        // String literal starts with single quote (#39) or double quote (#34).
        if (ch === 39 || ch === 34) {
            return scanStringLiteral();
        }

        if (isIdentifierStart(ch)) {
            return scanIdentifier();
        }

        // Dot (.) char #46 can also start a floating-point number, hence the need
        // to check the next character.
        if (ch === 46) {
            if (isDecimalDigit(source.charCodeAt(index + 1))) {
                return scanNumericLiteral();
            }
            return scanPunctuator();
        }

        if (isDecimalDigit(ch)) {
            return scanNumericLiteral();
        }

        // Slash (/) char #47 can also start a regex.
        if (extra.tokenize && ch === 47) {
            return advanceSlash();
        }

        return scanPunctuator();
    }

    function collectToken() {
        var start, loc, token, range, value;

        skipComment();
        start = index;
        loc = {
            start: {
                line: lineNumber,
                column: index - lineStart
            }
        };

        token = advance();
        loc.end = {
            line: lineNumber,
            column: index - lineStart
        };

        if (token.type !== Token.EOF) {
            range = [token.range[0], token.range[1]];
            value = source.slice(token.range[0], token.range[1]);
            extra.tokens.push({
                type: TokenName[token.type],
                value: value,
                range: range,
                loc: loc
            });
        }

        return token;
    }

    function lex() {
        var token;

        token = lookahead;
        index = token.range[1];
        lineNumber = token.lineNumber;
        lineStart = token.lineStart;

        lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();

        index = token.range[1];
        lineNumber = token.lineNumber;
        lineStart = token.lineStart;

        return token;
    }

    function peek() {
        var pos, line, start;

        pos = index;
        line = lineNumber;
        start = lineStart;
        lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();
        index = pos;
        lineNumber = line;
        lineStart = start;
    }

    SyntaxTreeDelegate = {

        name: 'SyntaxTree',

        markStart: function () {
            if (extra.loc) {
                state.markerStack.push(index - lineStart);
                state.markerStack.push(lineNumber);
            }
            if (extra.range) {
                state.markerStack.push(index);
            }
        },

        processComment: function (node) {
            var i, attacher, pos, len, candidate;

            if (typeof node.type === 'undefined' || node.type === Syntax.Program) {
                return;
            }

            // Check for possible additional trailing comments.
            peek();

            for (i = 0; i < extra.pendingComments.length; ++i) {
                attacher = extra.pendingComments[i];
                if (node.range[0] >= attacher.comment.range[1]) {
                    candidate = attacher.leading;
                    if (candidate) {
                        pos = candidate.range[0];
                        len = candidate.range[1] - pos;
                        if (node.range[0] <= pos && (node.range[1] - node.range[0] >= len)) {
                            attacher.leading = node;
                        }
                    } else {
                        attacher.leading = node;
                    }
                }
                if (node.range[1] <= attacher.comment.range[0]) {
                    candidate = attacher.trailing;
                    if (candidate) {
                        pos = candidate.range[0];
                        len = candidate.range[1] - pos;
                        if (node.range[0] <= pos && (node.range[1] - node.range[0] >= len)) {
                            attacher.trailing = node;
                        }
                    } else {
                        attacher.trailing = node;
                    }
                }
            }
        },

        markEnd: function (node) {
            if (extra.range) {
                node.range = [state.markerStack.pop(), index];
            }
            if (extra.loc) {
                node.loc = {
                    start: {
                        line: state.markerStack.pop(),
                        column: state.markerStack.pop()
                    },
                    end: {
                        line: lineNumber,
                        column: index - lineStart
                    }
                };
                this.postProcess(node);
            }
            if (extra.attachComment) {
                this.processComment(node);
            }
            return node;
        },

        markEndIf: function (node) {
            if (node.range || node.loc) {
                if (extra.loc) {
                    state.markerStack.pop();
                    state.markerStack.pop();
                }
                if (extra.range) {
                    state.markerStack.pop();
                }
            } else {
                this.markEnd(node);
            }
            return node;
        },

        postProcess: function (node) {
            if (extra.source) {
                node.loc.source = extra.source;
            }
            return node;
        },

        createArrayExpression: function (elements) {
            return {
                type: Syntax.ArrayExpression,
                elements: elements
            };
        },

        createAssignmentExpression: function (operator, left, right) {
            return {
                type: Syntax.AssignmentExpression,
                operator: operator,
                left: left,
                right: right
            };
        },

        createBinaryExpression: function (operator, left, right) {
            var type = (operator === '||' || operator === '&&') ? Syntax.LogicalExpression :
                Syntax.BinaryExpression;
            return {
                type: type,
                operator: operator,
                left: left,
                right: right
            };
        },

        createBlockStatement: function (body) {
            return {
                type: Syntax.BlockStatement,
                body: body
            };
        },

        createBreakStatement: function (label) {
            return {
                type: Syntax.BreakStatement,
                label: label
            };
        },

        createCallExpression: function (callee, args) {
            return {
                type: Syntax.CallExpression,
                callee: callee,
                'arguments': args
            };
        },

        createCatchClause: function (param, body) {
            return {
                type: Syntax.CatchClause,
                param: param,
                body: body
            };
        },

        createConditionalExpression: function (test, consequent, alternate) {
            return {
                type: Syntax.ConditionalExpression,
                test: test,
                consequent: consequent,
                alternate: alternate
            };
        },

        createContinueStatement: function (label) {
            return {
                type: Syntax.ContinueStatement,
                label: label
            };
        },

        createDebuggerStatement: function () {
            return {
                type: Syntax.DebuggerStatement
            };
        },

        createDoWhileStatement: function (body, test) {
            return {
                type: Syntax.DoWhileStatement,
                body: body,
                test: test
            };
        },

        createEmptyStatement: function () {
            return {
                type: Syntax.EmptyStatement
            };
        },

        createExpressionStatement: function (expression) {
            return {
                type: Syntax.ExpressionStatement,
                expression: expression
            };
        },

        createForStatement: function (init, test, update, body) {
            return {
                type: Syntax.ForStatement,
                init: init,
                test: test,
                update: update,
                body: body
            };
        },

        createForInStatement: function (left, right, body) {
            return {
                type: Syntax.ForInStatement,
                left: left,
                right: right,
                body: body,
                each: false
            };
        },

        createFunctionDeclaration: function (id, params, defaults, body) {
            return {
                type: Syntax.FunctionDeclaration,
                id: id,
                params: params,
                defaults: defaults,
                body: body,
                rest: null,
                generator: false,
                expression: false
            };
        },

        createFunctionExpression: function (id, params, defaults, body) {
            return {
                type: Syntax.FunctionExpression,
                id: id,
                params: params,
                defaults: defaults,
                body: body,
                rest: null,
                generator: false,
                expression: false
            };
        },

        createIdentifier: function (name) {
            return {
                type: Syntax.Identifier,
                name: name
            };
        },

        createIfStatement: function (test, consequent, alternate) {
            return {
                type: Syntax.IfStatement,
                test: test,
                consequent: consequent,
                alternate: alternate
            };
        },

        createLabeledStatement: function (label, body) {
            return {
                type: Syntax.LabeledStatement,
                label: label,
                body: body
            };
        },

        createLiteral: function (token) {
            return {
                type: Syntax.Literal,
                value: token.value,
                raw: source.slice(token.range[0], token.range[1])
            };
        },

        createMemberExpression: function (accessor, object, property) {
            return {
                type: Syntax.MemberExpression,
                computed: accessor === '[',
                object: object,
                property: property
            };
        },

        createNewExpression: function (callee, args) {
            return {
                type: Syntax.NewExpression,
                callee: callee,
                'arguments': args
            };
        },

        createObjectExpression: function (properties) {
            return {
                type: Syntax.ObjectExpression,
                properties: properties
            };
        },

        createPostfixExpression: function (operator, argument) {
            return {
                type: Syntax.UpdateExpression,
                operator: operator,
                argument: argument,
                prefix: false
            };
        },

        createProgram: function (body) {
            return {
                type: Syntax.Program,
                body: body
            };
        },

        createProperty: function (kind, key, value) {
            return {
                type: Syntax.Property,
                key: key,
                value: value,
                kind: kind
            };
        },

        createReturnStatement: function (argument) {
            return {
                type: Syntax.ReturnStatement,
                argument: argument
            };
        },

        createSequenceExpression: function (expressions) {
            return {
                type: Syntax.SequenceExpression,
                expressions: expressions
            };
        },

        createSwitchCase: function (test, consequent) {
            return {
                type: Syntax.SwitchCase,
                test: test,
                consequent: consequent
            };
        },

        createSwitchStatement: function (discriminant, cases) {
            return {
                type: Syntax.SwitchStatement,
                discriminant: discriminant,
                cases: cases
            };
        },

        createThisExpression: function () {
            return {
                type: Syntax.ThisExpression
            };
        },

        createThrowStatement: function (argument) {
            return {
                type: Syntax.ThrowStatement,
                argument: argument
            };
        },

        createTryStatement: function (block, guardedHandlers, handlers, finalizer) {
            return {
                type: Syntax.TryStatement,
                block: block,
                guardedHandlers: guardedHandlers,
                handlers: handlers,
                finalizer: finalizer
            };
        },

        createUnaryExpression: function (operator, argument) {
            if (operator === '++' || operator === '--') {
                return {
                    type: Syntax.UpdateExpression,
                    operator: operator,
                    argument: argument,
                    prefix: true
                };
            }
            return {
                type: Syntax.UnaryExpression,
                operator: operator,
                argument: argument,
                prefix: true
            };
        },

        createVariableDeclaration: function (declarations, kind) {
            return {
                type: Syntax.VariableDeclaration,
                declarations: declarations,
                kind: kind
            };
        },

        createVariableDeclarator: function (id, init) {
            return {
                type: Syntax.VariableDeclarator,
                id: id,
                init: init
            };
        },

        createWhileStatement: function (test, body) {
            return {
                type: Syntax.WhileStatement,
                test: test,
                body: body
            };
        },

        createWithStatement: function (object, body) {
            return {
                type: Syntax.WithStatement,
                object: object,
                body: body
            };
        }
    };

    // Return true if there is a line terminator before the next token.

    function peekLineTerminator() {
        var pos, line, start, found;

        pos = index;
        line = lineNumber;
        start = lineStart;
        skipComment();
        found = lineNumber !== line;
        index = pos;
        lineNumber = line;
        lineStart = start;

        return found;
    }

    // Throw an exception

    function throwError(token, messageFormat) {
        var error,
            args = Array.prototype.slice.call(arguments, 2),
            msg = messageFormat.replace(
                /%(\d)/g,
                function (whole, index) {
                    assert(index < args.length, 'Message reference must be in range');
                    return args[index];
                }
            );

        if (typeof token.lineNumber === 'number') {
            error = new Error('Line ' + token.lineNumber + ': ' + msg);
            error.index = token.range[0];
            error.lineNumber = token.lineNumber;
            error.column = token.range[0] - lineStart + 1;
        } else {
            error = new Error('Line ' + lineNumber + ': ' + msg);
            error.index = index;
            error.lineNumber = lineNumber;
            error.column = index - lineStart + 1;
        }

        error.description = msg;
        throw error;
    }

    function throwErrorTolerant() {
        try {
            throwError.apply(null, arguments);
        } catch (e) {
            if (extra.errors) {
                extra.errors.push(e);
            } else {
                throw e;
            }
        }
    }


    // Throw an exception because of the token.

    function throwUnexpected(token) {
        if (token.type === Token.EOF) {
            throwError(token, Messages.UnexpectedEOS);
        }

        if (token.type === Token.NumericLiteral) {
            throwError(token, Messages.UnexpectedNumber);
        }

        if (token.type === Token.StringLiteral) {
            throwError(token, Messages.UnexpectedString);
        }

        if (token.type === Token.Identifier) {
            throwError(token, Messages.UnexpectedIdentifier);
        }

        if (token.type === Token.Keyword) {
            if (isFutureReservedWord(token.value)) {
                throwError(token, Messages.UnexpectedReserved);
            } else if (strict && isStrictModeReservedWord(token.value)) {
                throwErrorTolerant(token, Messages.StrictReservedWord);
                return;
            }
            throwError(token, Messages.UnexpectedToken, token.value);
        }

        // BooleanLiteral, NullLiteral, or Punctuator.
        throwError(token, Messages.UnexpectedToken, token.value);
    }

    // Expect the next token to match the specified punctuator.
    // If not, an exception will be thrown.

    function expect(value) {
        var token = lex();
        if (token.type !== Token.Punctuator || token.value !== value) {
            throwUnexpected(token);
        }
    }

    // Expect the next token to match the specified keyword.
    // If not, an exception will be thrown.

    function expectKeyword(keyword) {
        var token = lex();
        if (token.type !== Token.Keyword || token.value !== keyword) {
            throwUnexpected(token);
        }
    }

    // Return true if the next token matches the specified punctuator.

    function match(value) {
        return lookahead.type === Token.Punctuator && lookahead.value === value;
    }

    // Return true if the next token matches the specified keyword

    function matchKeyword(keyword) {
        return lookahead.type === Token.Keyword && lookahead.value === keyword;
    }

    // Return true if the next token is an assignment operator

    function matchAssign() {
        var op;

        if (lookahead.type !== Token.Punctuator) {
            return false;
        }
        op = lookahead.value;
        return op === '=' ||
            op === '*=' ||
            op === '/=' ||
            op === '%=' ||
            op === '+=' ||
            op === '-=' ||
            op === '<<=' ||
            op === '>>=' ||
            op === '>>>=' ||
            op === '&=' ||
            op === '^=' ||
            op === '|=';
    }

    function consumeSemicolon() {
        var line;

        // Catch the very common case first: immediately a semicolon (char #59).
        if (source.charCodeAt(index) === 59) {
            lex();
            return;
        }

        line = lineNumber;
        skipComment();
        if (lineNumber !== line) {
            return;
        }

        if (match(';')) {
            lex();
            return;
        }

        if (lookahead.type !== Token.EOF && !match('}')) {
            throwUnexpected(lookahead);
        }
    }

    // Return true if provided expression is LeftHandSideExpression

    function isLeftHandSide(expr) {
        return expr.type === Syntax.Identifier || expr.type === Syntax.MemberExpression;
    }

    // 11.1.4 Array Initialiser

    function parseArrayInitialiser() {
        var elements = [];

        expect('[');

        while (!match(']')) {
            if (match(',')) {
                lex();
                elements.push(null);
            } else {
                elements.push(parseAssignmentExpression());

                if (!match(']')) {
                    expect(',');
                }
            }
        }

        expect(']');

        return delegate.createArrayExpression(elements);
    }

    // 11.1.5 Object Initialiser

    function parsePropertyFunction(param, first) {
        var previousStrict, body;

        previousStrict = strict;
        skipComment();
        delegate.markStart();
        body = parseFunctionSourceElements();
        if (first && strict && isRestrictedWord(param[0].name)) {
            throwErrorTolerant(first, Messages.StrictParamName);
        }
        strict = previousStrict;
        return delegate.markEnd(delegate.createFunctionExpression(null, param, [], body));
    }

    function parseObjectPropertyKey() {
        var token;

        skipComment();
        delegate.markStart();
        token = lex();

        // Note: This function is called only from parseObjectProperty(), where
        // EOF and Punctuator tokens are already filtered out.

        if (token.type === Token.StringLiteral || token.type === Token.NumericLiteral) {
            if (strict && token.octal) {
                throwErrorTolerant(token, Messages.StrictOctalLiteral);
            }
            return delegate.markEnd(delegate.createLiteral(token));
        }

        return delegate.markEnd(delegate.createIdentifier(token.value));
    }

    function parseObjectProperty() {
        var token, key, id, value, param;

        token = lookahead;
        skipComment();
        delegate.markStart();

        if (token.type === Token.Identifier) {

            id = parseObjectPropertyKey();

            // Property Assignment: Getter and Setter.

            if (token.value === 'get' && !match(':')) {
                key = parseObjectPropertyKey();
                expect('(');
                expect(')');
                value = parsePropertyFunction([]);
                return delegate.markEnd(delegate.createProperty('get', key, value));
            }
            if (token.value === 'set' && !match(':')) {
                key = parseObjectPropertyKey();
                expect('(');
                token = lookahead;
                if (token.type !== Token.Identifier) {
                    expect(')');
                    throwErrorTolerant(token, Messages.UnexpectedToken, token.value);
                    value = parsePropertyFunction([]);
                } else {
                    param = [ parseVariableIdentifier() ];
                    expect(')');
                    value = parsePropertyFunction(param, token);
                }
                return delegate.markEnd(delegate.createProperty('set', key, value));
            }
            expect(':');
            value = parseAssignmentExpression();
            return delegate.markEnd(delegate.createProperty('init', id, value));
        }
        if (token.type === Token.EOF || token.type === Token.Punctuator) {
            throwUnexpected(token);
        } else {
            key = parseObjectPropertyKey();
            expect(':');
            value = parseAssignmentExpression();
            return delegate.markEnd(delegate.createProperty('init', key, value));
        }
    }

    function parseObjectInitialiser() {
        var properties = [], property, name, key, kind, map = {}, toString = String;

        expect('{');

        while (!match('}')) {
            property = parseObjectProperty();

            if (property.key.type === Syntax.Identifier) {
                name = property.key.name;
            } else {
                name = toString(property.key.value);
            }
            kind = (property.kind === 'init') ? PropertyKind.Data : (property.kind === 'get') ? PropertyKind.Get : PropertyKind.Set;

            key = '$' + name;
            if (Object.prototype.hasOwnProperty.call(map, key)) {
                if (map[key] === PropertyKind.Data) {
                    if (strict && kind === PropertyKind.Data) {
                        throwErrorTolerant({}, Messages.StrictDuplicateProperty);
                    } else if (kind !== PropertyKind.Data) {
                        throwErrorTolerant({}, Messages.AccessorDataProperty);
                    }
                } else {
                    if (kind === PropertyKind.Data) {
                        throwErrorTolerant({}, Messages.AccessorDataProperty);
                    } else if (map[key] & kind) {
                        throwErrorTolerant({}, Messages.AccessorGetSet);
                    }
                }
                map[key] |= kind;
            } else {
                map[key] = kind;
            }

            properties.push(property);

            if (!match('}')) {
                expect(',');
            }
        }

        expect('}');

        return delegate.createObjectExpression(properties);
    }

    // 11.1.6 The Grouping Operator

    function parseGroupExpression() {
        var expr;

        expect('(');

        expr = parseExpression();

        expect(')');

        return expr;
    }


    // 11.1 Primary Expressions

    function parsePrimaryExpression() {
        var type, token, expr;

        if (match('(')) {
            return parseGroupExpression();
        }

        type = lookahead.type;
        delegate.markStart();

        if (type === Token.Identifier) {
            expr =  delegate.createIdentifier(lex().value);
        } else if (type === Token.StringLiteral || type === Token.NumericLiteral) {
            if (strict && lookahead.octal) {
                throwErrorTolerant(lookahead, Messages.StrictOctalLiteral);
            }
            expr = delegate.createLiteral(lex());
        } else if (type === Token.Keyword) {
            if (matchKeyword('this')) {
                lex();
                expr = delegate.createThisExpression();
            } else if (matchKeyword('function')) {
                expr = parseFunctionExpression();
            }
        } else if (type === Token.BooleanLiteral) {
            token = lex();
            token.value = (token.value === 'true');
            expr = delegate.createLiteral(token);
        } else if (type === Token.NullLiteral) {
            token = lex();
            token.value = null;
            expr = delegate.createLiteral(token);
        } else if (match('[')) {
            expr = parseArrayInitialiser();
        } else if (match('{')) {
            expr = parseObjectInitialiser();
        } else if (match('/') || match('/=')) {
            if (typeof extra.tokens !== 'undefined') {
                expr = delegate.createLiteral(collectRegex());
            } else {
                expr = delegate.createLiteral(scanRegExp());
            }
            peek();
        }

        if (expr) {
            return delegate.markEnd(expr);
        }

        throwUnexpected(lex());
    }

    // 11.2 Left-Hand-Side Expressions

    function parseArguments() {
        var args = [];

        expect('(');

        if (!match(')')) {
            while (index < length) {
                args.push(parseAssignmentExpression());
                if (match(')')) {
                    break;
                }
                expect(',');
            }
        }

        expect(')');

        return args;
    }

    function parseNonComputedProperty() {
        var token;

        delegate.markStart();
        token = lex();

        if (!isIdentifierName(token)) {
            throwUnexpected(token);
        }

        return delegate.markEnd(delegate.createIdentifier(token.value));
    }

    function parseNonComputedMember() {
        expect('.');

        return parseNonComputedProperty();
    }

    function parseComputedMember() {
        var expr;

        expect('[');

        expr = parseExpression();

        expect(']');

        return expr;
    }

    function parseNewExpression() {
        var callee, args;

        delegate.markStart();
        expectKeyword('new');
        callee = parseLeftHandSideExpression();
        args = match('(') ? parseArguments() : [];

        return delegate.markEnd(delegate.createNewExpression(callee, args));
    }

    function parseLeftHandSideExpressionAllowCall() {
        var marker, previousAllowIn, expr, args, property;

        marker = createLocationMarker();

        previousAllowIn = state.allowIn;
        state.allowIn = true;
        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();
        state.allowIn = previousAllowIn;

        while (match('.') || match('[') || match('(')) {
            if (match('(')) {
                args = parseArguments();
                expr = delegate.createCallExpression(expr, args);
            } else if (match('[')) {
                property = parseComputedMember();
                expr = delegate.createMemberExpression('[', expr, property);
            } else {
                property = parseNonComputedMember();
                expr = delegate.createMemberExpression('.', expr, property);
            }
            if (marker) {
                marker.end();
                marker.apply(expr);
            }
        }

        return expr;
    }

    function parseLeftHandSideExpression() {
        var marker, previousAllowIn, expr, property;

        marker = createLocationMarker();

        previousAllowIn = state.allowIn;
        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();
        state.allowIn = previousAllowIn;

        while (match('.') || match('[')) {
            if (match('[')) {
                property = parseComputedMember();
                expr = delegate.createMemberExpression('[', expr, property);
            } else {
                property = parseNonComputedMember();
                expr = delegate.createMemberExpression('.', expr, property);
            }
            if (marker) {
                marker.end();
                marker.apply(expr);
            }
        }

        return expr;
    }

    // 11.3 Postfix Expressions

    function parsePostfixExpression() {
        var expr, token;

        delegate.markStart();
        expr = parseLeftHandSideExpressionAllowCall();

        if (lookahead.type === Token.Punctuator) {
            if ((match('++') || match('--')) && !peekLineTerminator()) {
                // 11.3.1, 11.3.2
                if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
                    throwErrorTolerant({}, Messages.StrictLHSPostfix);
                }

                if (!isLeftHandSide(expr)) {
                    throwErrorTolerant({}, Messages.InvalidLHSInAssignment);
                }

                token = lex();
                expr = delegate.createPostfixExpression(token.value, expr);
            }
        }

        return delegate.markEndIf(expr);
    }

    // 11.4 Unary Operators

    function parseUnaryExpression() {
        var token, expr;

        delegate.markStart();

        if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {
            expr = parsePostfixExpression();
        } else if (match('++') || match('--')) {
            token = lex();
            expr = parseUnaryExpression();
            // 11.4.4, 11.4.5
            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
                throwErrorTolerant({}, Messages.StrictLHSPrefix);
            }

            if (!isLeftHandSide(expr)) {
                throwErrorTolerant({}, Messages.InvalidLHSInAssignment);
            }

            expr = delegate.createUnaryExpression(token.value, expr);
        } else if (match('+') || match('-') || match('~') || match('!')) {
            token = lex();
            expr = parseUnaryExpression();
            expr = delegate.createUnaryExpression(token.value, expr);
        } else if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {
            token = lex();
            expr = parseUnaryExpression();
            expr = delegate.createUnaryExpression(token.value, expr);
            if (strict && expr.operator === 'delete' && expr.argument.type === Syntax.Identifier) {
                throwErrorTolerant({}, Messages.StrictDelete);
            }
        } else {
            expr = parsePostfixExpression();
        }

        return delegate.markEndIf(expr);
    }

    function binaryPrecedence(token, allowIn) {
        var prec = 0;

        if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {
            return 0;
        }

        switch (token.value) {
            case '||':
                prec = 1;
                break;

            case '&&':
                prec = 2;
                break;

            case '|':
                prec = 3;
                break;

            case '^':
                prec = 4;
                break;

            case '&':
                prec = 5;
                break;

            case '==':
            case '!=':
            case '===':
            case '!==':
                prec = 6;
                break;

            case '<':
            case '>':
            case '<=':
            case '>=':
            case 'instanceof':
                prec = 7;
                break;

            case 'in':
                prec = allowIn ? 7 : 0;
                break;

            case '<<':
            case '>>':
            case '>>>':
                prec = 8;
                break;

            case '+':
            case '-':
                prec = 9;
                break;

            case '*':
            case '/':
            case '%':
                prec = 11;
                break;

            default:
                break;
        }

        return prec;
    }

    // 11.5 Multiplicative Operators
    // 11.6 Additive Operators
    // 11.7 Bitwise Shift Operators
    // 11.8 Relational Operators
    // 11.9 Equality Operators
    // 11.10 Binary Bitwise Operators
    // 11.11 Binary Logical Operators

    function parseBinaryExpression() {
        var marker, markers, expr, token, prec, stack, right, operator, left, i;

        marker = createLocationMarker();
        left = parseUnaryExpression();

        token = lookahead;
        prec = binaryPrecedence(token, state.allowIn);
        if (prec === 0) {
            return left;
        }
        token.prec = prec;
        lex();

        markers = [marker, createLocationMarker()];
        right = parseUnaryExpression();

        stack = [left, token, right];

        while ((prec = binaryPrecedence(lookahead, state.allowIn)) > 0) {

            // Reduce: make a binary expression from the three topmost entries.
            while ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {
                right = stack.pop();
                operator = stack.pop().value;
                left = stack.pop();
                expr = delegate.createBinaryExpression(operator, left, right);
                markers.pop();
                marker = markers.pop();
                if (marker) {
                    marker.end();
                    marker.apply(expr);
                }
                stack.push(expr);
                markers.push(marker);
            }

            // Shift.
            token = lex();
            token.prec = prec;
            stack.push(token);
            markers.push(createLocationMarker());
            expr = parseUnaryExpression();
            stack.push(expr);
        }

        // Final reduce to clean-up the stack.
        i = stack.length - 1;
        expr = stack[i];
        markers.pop();
        while (i > 1) {
            expr = delegate.createBinaryExpression(stack[i - 1].value, stack[i - 2], expr);
            i -= 2;
            marker = markers.pop();
            if (marker) {
                marker.end();
                marker.apply(expr);
            }
        }

        return expr;
    }


    // 11.12 Conditional Operator

    function parseConditionalExpression() {
        var expr, previousAllowIn, consequent, alternate;

        delegate.markStart();
        expr = parseBinaryExpression();

        if (match('?')) {
            lex();
            previousAllowIn = state.allowIn;
            state.allowIn = true;
            consequent = parseAssignmentExpression();
            state.allowIn = previousAllowIn;
            expect(':');
            alternate = parseAssignmentExpression();

            expr = delegate.markEnd(delegate.createConditionalExpression(expr, consequent, alternate));
        } else {
            delegate.markEnd({});
        }

        return expr;
    }

    // 11.13 Assignment Operators

    function parseAssignmentExpression() {
        var token, left, right, node;

        token = lookahead;
        delegate.markStart();
        node = left = parseConditionalExpression();

        if (matchAssign()) {
            // LeftHandSideExpression
            if (!isLeftHandSide(left)) {
                throwErrorTolerant({}, Messages.InvalidLHSInAssignment);
            }

            // 11.13.1
            if (strict && left.type === Syntax.Identifier && isRestrictedWord(left.name)) {
                throwErrorTolerant(token, Messages.StrictLHSAssignment);
            }

            token = lex();
            right = parseAssignmentExpression();
            node = delegate.createAssignmentExpression(token.value, left, right);
        }

        return delegate.markEndIf(node);
    }

    // 11.14 Comma Operator

    function parseExpression() {
        var expr;

        delegate.markStart();
        expr = parseAssignmentExpression();

        if (match(',')) {
            expr = delegate.createSequenceExpression([ expr ]);

            while (index < length) {
                if (!match(',')) {
                    break;
                }
                lex();
                expr.expressions.push(parseAssignmentExpression());
            }
        }

        return delegate.markEndIf(expr);
    }

    // 12.1 Block

    function parseStatementList() {
        var list = [],
            statement;

        while (index < length) {
            if (match('}')) {
                break;
            }
            statement = parseSourceElement();
            if (typeof statement === 'undefined') {
                break;
            }
            list.push(statement);
        }

        return list;
    }

    function parseBlock() {
        var block;

        skipComment();
        delegate.markStart();
        expect('{');

        block = parseStatementList();

        expect('}');

        return delegate.markEnd(delegate.createBlockStatement(block));
    }

    // 12.2 Variable Statement

    function parseVariableIdentifier() {
        var token;

        skipComment();
        delegate.markStart();
        token = lex();

        if (token.type !== Token.Identifier) {
            throwUnexpected(token);
        }

        return delegate.markEnd(delegate.createIdentifier(token.value));
    }

    function parseVariableDeclaration(kind) {
        var init = null, id;

        skipComment();
        delegate.markStart();
        id = parseVariableIdentifier();

        // 12.2.1
        if (strict && isRestrictedWord(id.name)) {
            throwErrorTolerant({}, Messages.StrictVarName);
        }

        if (kind === 'const') {
            expect('=');
            init = parseAssignmentExpression();
        } else if (match('=')) {
            lex();
            init = parseAssignmentExpression();
        }

        return delegate.markEnd(delegate.createVariableDeclarator(id, init));
    }

    function parseVariableDeclarationList(kind) {
        var list = [];

        do {
            list.push(parseVariableDeclaration(kind));
            if (!match(',')) {
                break;
            }
            lex();
        } while (index < length);

        return list;
    }

    function parseVariableStatement() {
        var declarations;

        expectKeyword('var');

        declarations = parseVariableDeclarationList();

        consumeSemicolon();

        return delegate.createVariableDeclaration(declarations, 'var');
    }

    // kind may be `const` or `let`
    // Both are experimental and not in the specification yet.
    // see http://wiki.ecmascript.org/doku.php?id=harmony:const
    // and http://wiki.ecmascript.org/doku.php?id=harmony:let
    function parseConstLetDeclaration(kind) {
        var declarations;

        skipComment();
        delegate.markStart();

        expectKeyword(kind);

        declarations = parseVariableDeclarationList(kind);

        consumeSemicolon();

        return delegate.markEnd(delegate.createVariableDeclaration(declarations, kind));
    }

    // 12.3 Empty Statement

    function parseEmptyStatement() {
        expect(';');
        return delegate.createEmptyStatement();
    }

    // 12.4 Expression Statement

    function parseExpressionStatement() {
        var expr = parseExpression();
        consumeSemicolon();
        return delegate.createExpressionStatement(expr);
    }

    // 12.5 If statement

    function parseIfStatement() {
        var test, consequent, alternate;

        expectKeyword('if');

        expect('(');

        test = parseExpression();

        expect(')');

        consequent = parseStatement();

        if (matchKeyword('else')) {
            lex();
            alternate = parseStatement();
        } else {
            alternate = null;
        }

        return delegate.createIfStatement(test, consequent, alternate);
    }

    // 12.6 Iteration Statements

    function parseDoWhileStatement() {
        var body, test, oldInIteration;

        expectKeyword('do');

        oldInIteration = state.inIteration;
        state.inIteration = true;

        body = parseStatement();

        state.inIteration = oldInIteration;

        expectKeyword('while');

        expect('(');

        test = parseExpression();

        expect(')');

        if (match(';')) {
            lex();
        }

        return delegate.createDoWhileStatement(body, test);
    }

    function parseWhileStatement() {
        var test, body, oldInIteration;

        expectKeyword('while');

        expect('(');

        test = parseExpression();

        expect(')');

        oldInIteration = state.inIteration;
        state.inIteration = true;

        body = parseStatement();

        state.inIteration = oldInIteration;

        return delegate.createWhileStatement(test, body);
    }

    function parseForVariableDeclaration() {
        var token, declarations;

        delegate.markStart();
        token = lex();
        declarations = parseVariableDeclarationList();

        return delegate.markEnd(delegate.createVariableDeclaration(declarations, token.value));
    }

    function parseForStatement() {
        var init, test, update, left, right, body, oldInIteration;

        init = test = update = null;

        expectKeyword('for');

        expect('(');

        if (match(';')) {
            lex();
        } else {
            if (matchKeyword('var') || matchKeyword('let')) {
                state.allowIn = false;
                init = parseForVariableDeclaration();
                state.allowIn = true;

                if (init.declarations.length === 1 && matchKeyword('in')) {
                    lex();
                    left = init;
                    right = parseExpression();
                    init = null;
                }
            } else {
                state.allowIn = false;
                init = parseExpression();
                state.allowIn = true;

                if (matchKeyword('in')) {
                    // LeftHandSideExpression
                    if (!isLeftHandSide(init)) {
                        throwErrorTolerant({}, Messages.InvalidLHSInForIn);
                    }

                    lex();
                    left = init;
                    right = parseExpression();
                    init = null;
                }
            }

            if (typeof left === 'undefined') {
                expect(';');
            }
        }

        if (typeof left === 'undefined') {

            if (!match(';')) {
                test = parseExpression();
            }
            expect(';');

            if (!match(')')) {
                update = parseExpression();
            }
        }

        expect(')');

        oldInIteration = state.inIteration;
        state.inIteration = true;

        body = parseStatement();

        state.inIteration = oldInIteration;

        return (typeof left === 'undefined') ?
            delegate.createForStatement(init, test, update, body) :
            delegate.createForInStatement(left, right, body);
    }

    // 12.7 The continue statement

    function parseContinueStatement() {
        var label = null, key;

        expectKeyword('continue');

        // Optimize the most common form: 'continue;'.
        if (source.charCodeAt(index) === 59) {
            lex();

            if (!state.inIteration) {
                throwError({}, Messages.IllegalContinue);
            }

            return delegate.createContinueStatement(null);
        }

        if (peekLineTerminator()) {
            if (!state.inIteration) {
                throwError({}, Messages.IllegalContinue);
            }

            return delegate.createContinueStatement(null);
        }

        if (lookahead.type === Token.Identifier) {
            label = parseVariableIdentifier();

            key = '$' + label.name;
            if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
                throwError({}, Messages.UnknownLabel, label.name);
            }
        }

        consumeSemicolon();

        if (label === null && !state.inIteration) {
            throwError({}, Messages.IllegalContinue);
        }

        return delegate.createContinueStatement(label);
    }

    // 12.8 The break statement

    function parseBreakStatement() {
        var label = null, key;

        expectKeyword('break');

        // Catch the very common case first: immediately a semicolon (char #59).
        if (source.charCodeAt(index) === 59) {
            lex();

            if (!(state.inIteration || state.inSwitch)) {
                throwError({}, Messages.IllegalBreak);
            }

            return delegate.createBreakStatement(null);
        }

        if (peekLineTerminator()) {
            if (!(state.inIteration || state.inSwitch)) {
                throwError({}, Messages.IllegalBreak);
            }

            return delegate.createBreakStatement(null);
        }

        if (lookahead.type === Token.Identifier) {
            label = parseVariableIdentifier();

            key = '$' + label.name;
            if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
                throwError({}, Messages.UnknownLabel, label.name);
            }
        }

        consumeSemicolon();

        if (label === null && !(state.inIteration || state.inSwitch)) {
            throwError({}, Messages.IllegalBreak);
        }

        return delegate.createBreakStatement(label);
    }

    // 12.9 The return statement

    function parseReturnStatement() {
        var argument = null;

        expectKeyword('return');

        if (!state.inFunctionBody) {
            throwErrorTolerant({}, Messages.IllegalReturn);
        }

        // 'return' followed by a space and an identifier is very common.
        if (source.charCodeAt(index) === 32) {
            if (isIdentifierStart(source.charCodeAt(index + 1))) {
                argument = parseExpression();
                consumeSemicolon();
                return delegate.createReturnStatement(argument);
            }
        }

        if (peekLineTerminator()) {
            return delegate.createReturnStatement(null);
        }

        if (!match(';')) {
            if (!match('}') && lookahead.type !== Token.EOF) {
                argument = parseExpression();
            }
        }

        consumeSemicolon();

        return delegate.createReturnStatement(argument);
    }

    // 12.10 The with statement

    function parseWithStatement() {
        var object, body;

        if (strict) {
            throwErrorTolerant({}, Messages.StrictModeWith);
        }

        expectKeyword('with');

        expect('(');

        object = parseExpression();

        expect(')');

        body = parseStatement();

        return delegate.createWithStatement(object, body);
    }

    // 12.10 The swith statement

    function parseSwitchCase() {
        var test,
            consequent = [],
            statement;

        skipComment();
        delegate.markStart();
        if (matchKeyword('default')) {
            lex();
            test = null;
        } else {
            expectKeyword('case');
            test = parseExpression();
        }
        expect(':');

        while (index < length) {
            if (match('}') || matchKeyword('default') || matchKeyword('case')) {
                break;
            }
            statement = parseStatement();
            consequent.push(statement);
        }

        return delegate.markEnd(delegate.createSwitchCase(test, consequent));
    }

    function parseSwitchStatement() {
        var discriminant, cases, clause, oldInSwitch, defaultFound;

        expectKeyword('switch');

        expect('(');

        discriminant = parseExpression();

        expect(')');

        expect('{');

        cases = [];

        if (match('}')) {
            lex();
            return delegate.createSwitchStatement(discriminant, cases);
        }

        oldInSwitch = state.inSwitch;
        state.inSwitch = true;
        defaultFound = false;

        while (index < length) {
            if (match('}')) {
                break;
            }
            clause = parseSwitchCase();
            if (clause.test === null) {
                if (defaultFound) {
                    throwError({}, Messages.MultipleDefaultsInSwitch);
                }
                defaultFound = true;
            }
            cases.push(clause);
        }

        state.inSwitch = oldInSwitch;

        expect('}');

        return delegate.createSwitchStatement(discriminant, cases);
    }

    // 12.13 The throw statement

    function parseThrowStatement() {
        var argument;

        expectKeyword('throw');

        if (peekLineTerminator()) {
            throwError({}, Messages.NewlineAfterThrow);
        }

        argument = parseExpression();

        consumeSemicolon();

        return delegate.createThrowStatement(argument);
    }

    // 12.14 The try statement

    function parseCatchClause() {
        var param, body;

        skipComment();
        delegate.markStart();
        expectKeyword('catch');

        expect('(');
        if (match(')')) {
            throwUnexpected(lookahead);
        }

        param = parseVariableIdentifier();
        // 12.14.1
        if (strict && isRestrictedWord(param.name)) {
            throwErrorTolerant({}, Messages.StrictCatchVariable);
        }

        expect(')');
        body = parseBlock();
        return delegate.markEnd(delegate.createCatchClause(param, body));
    }

    function parseTryStatement() {
        var block, handlers = [], finalizer = null;

        expectKeyword('try');

        block = parseBlock();

        if (matchKeyword('catch')) {
            handlers.push(parseCatchClause());
        }

        if (matchKeyword('finally')) {
            lex();
            finalizer = parseBlock();
        }

        if (handlers.length === 0 && !finalizer) {
            throwError({}, Messages.NoCatchOrFinally);
        }

        return delegate.createTryStatement(block, [], handlers, finalizer);
    }

    // 12.15 The debugger statement

    function parseDebuggerStatement() {
        expectKeyword('debugger');

        consumeSemicolon();

        return delegate.createDebuggerStatement();
    }

    // 12 Statements

    function parseStatement() {
        var type = lookahead.type,
            expr,
            labeledBody,
            key;

        if (type === Token.EOF) {
            throwUnexpected(lookahead);
        }

        skipComment();
        delegate.markStart();

        if (type === Token.Punctuator) {
            switch (lookahead.value) {
                case ';':
                    return delegate.markEnd(parseEmptyStatement());
                case '{':
                    return delegate.markEnd(parseBlock());
                case '(':
                    return delegate.markEnd(parseExpressionStatement());
                default:
                    break;
            }
        }

        if (type === Token.Keyword) {
            switch (lookahead.value) {
                case 'break':
                    return delegate.markEnd(parseBreakStatement());
                case 'continue':
                    return delegate.markEnd(parseContinueStatement());
                case 'debugger':
                    return delegate.markEnd(parseDebuggerStatement());
                case 'do':
                    return delegate.markEnd(parseDoWhileStatement());
                case 'for':
                    return delegate.markEnd(parseForStatement());
                case 'function':
                    return delegate.markEnd(parseFunctionDeclaration());
                case 'if':
                    return delegate.markEnd(parseIfStatement());
                case 'return':
                    return delegate.markEnd(parseReturnStatement());
                case 'switch':
                    return delegate.markEnd(parseSwitchStatement());
                case 'throw':
                    return delegate.markEnd(parseThrowStatement());
                case 'try':
                    return delegate.markEnd(parseTryStatement());
                case 'var':
                    return delegate.markEnd(parseVariableStatement());
                case 'while':
                    return delegate.markEnd(parseWhileStatement());
                case 'with':
                    return delegate.markEnd(parseWithStatement());
                default:
                    break;
            }
        }

        expr = parseExpression();

        // 12.12 Labelled Statements
        if ((expr.type === Syntax.Identifier) && match(':')) {
            lex();

            key = '$' + expr.name;
            if (Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
                throwError({}, Messages.Redeclaration, 'Label', expr.name);
            }

            state.labelSet[key] = true;
            labeledBody = parseStatement();
            delete state.labelSet[key];
            return delegate.markEnd(delegate.createLabeledStatement(expr, labeledBody));
        }

        consumeSemicolon();

        return delegate.markEnd(delegate.createExpressionStatement(expr));
    }

    // 13 Function Definition

    function parseFunctionSourceElements() {
        var sourceElement, sourceElements = [], token, directive, firstRestricted,
            oldLabelSet, oldInIteration, oldInSwitch, oldInFunctionBody;

        skipComment();
        delegate.markStart();
        expect('{');

        while (index < length) {
            if (lookahead.type !== Token.StringLiteral) {
                break;
            }
            token = lookahead;

            sourceElement = parseSourceElement();
            sourceElements.push(sourceElement);
            if (sourceElement.expression.type !== Syntax.Literal) {
                // this is not directive
                break;
            }
            directive = source.slice(token.range[0] + 1, token.range[1] - 1);
            if (directive === 'use strict') {
                strict = true;
                if (firstRestricted) {
                    throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);
                }
            } else {
                if (!firstRestricted && token.octal) {
                    firstRestricted = token;
                }
            }
        }

        oldLabelSet = state.labelSet;
        oldInIteration = state.inIteration;
        oldInSwitch = state.inSwitch;
        oldInFunctionBody = state.inFunctionBody;

        state.labelSet = {};
        state.inIteration = false;
        state.inSwitch = false;
        state.inFunctionBody = true;

        while (index < length) {
            if (match('}')) {
                break;
            }
            sourceElement = parseSourceElement();
            if (typeof sourceElement === 'undefined') {
                break;
            }
            sourceElements.push(sourceElement);
        }

        expect('}');

        state.labelSet = oldLabelSet;
        state.inIteration = oldInIteration;
        state.inSwitch = oldInSwitch;
        state.inFunctionBody = oldInFunctionBody;

        return delegate.markEnd(delegate.createBlockStatement(sourceElements));
    }

    function parseParams(firstRestricted) {
        var param, params = [], token, stricted, paramSet, key, message;
        expect('(');

        if (!match(')')) {
            paramSet = {};
            while (index < length) {
                token = lookahead;
                param = parseVariableIdentifier();
                key = '$' + token.value;
                if (strict) {
                    if (isRestrictedWord(token.value)) {
                        stricted = token;
                        message = Messages.StrictParamName;
                    }
                    if (Object.prototype.hasOwnProperty.call(paramSet, key)) {
                        stricted = token;
                        message = Messages.StrictParamDupe;
                    }
                } else if (!firstRestricted) {
                    if (isRestrictedWord(token.value)) {
                        firstRestricted = token;
                        message = Messages.StrictParamName;
                    } else if (isStrictModeReservedWord(token.value)) {
                        firstRestricted = token;
                        message = Messages.StrictReservedWord;
                    } else if (Object.prototype.hasOwnProperty.call(paramSet, key)) {
                        firstRestricted = token;
                        message = Messages.StrictParamDupe;
                    }
                }
                params.push(param);
                paramSet[key] = true;
                if (match(')')) {
                    break;
                }
                expect(',');
            }
        }

        expect(')');

        return {
            params: params,
            stricted: stricted,
            firstRestricted: firstRestricted,
            message: message
        };
    }

    function parseFunctionDeclaration() {
        var id, params = [], body, token, stricted, tmp, firstRestricted, message, previousStrict;

        skipComment();
        delegate.markStart();

        expectKeyword('function');
        token = lookahead;
        id = parseVariableIdentifier();
        if (strict) {
            if (isRestrictedWord(token.value)) {
                throwErrorTolerant(token, Messages.StrictFunctionName);
            }
        } else {
            if (isRestrictedWord(token.value)) {
                firstRestricted = token;
                message = Messages.StrictFunctionName;
            } else if (isStrictModeReservedWord(token.value)) {
                firstRestricted = token;
                message = Messages.StrictReservedWord;
            }
        }

        tmp = parseParams(firstRestricted);
        params = tmp.params;
        stricted = tmp.stricted;
        firstRestricted = tmp.firstRestricted;
        if (tmp.message) {
            message = tmp.message;
        }

        previousStrict = strict;
        body = parseFunctionSourceElements();
        if (strict && firstRestricted) {
            throwError(firstRestricted, message);
        }
        if (strict && stricted) {
            throwErrorTolerant(stricted, message);
        }
        strict = previousStrict;

        return delegate.markEnd(delegate.createFunctionDeclaration(id, params, [], body));
    }

    function parseFunctionExpression() {
        var token, id = null, stricted, firstRestricted, message, tmp, params = [], body, previousStrict;

        delegate.markStart();
        expectKeyword('function');

        if (!match('(')) {
            token = lookahead;
            id = parseVariableIdentifier();
            if (strict) {
                if (isRestrictedWord(token.value)) {
                    throwErrorTolerant(token, Messages.StrictFunctionName);
                }
            } else {
                if (isRestrictedWord(token.value)) {
                    firstRestricted = token;
                    message = Messages.StrictFunctionName;
                } else if (isStrictModeReservedWord(token.value)) {
                    firstRestricted = token;
                    message = Messages.StrictReservedWord;
                }
            }
        }

        tmp = parseParams(firstRestricted);
        params = tmp.params;
        stricted = tmp.stricted;
        firstRestricted = tmp.firstRestricted;
        if (tmp.message) {
            message = tmp.message;
        }

        previousStrict = strict;
        body = parseFunctionSourceElements();
        if (strict && firstRestricted) {
            throwError(firstRestricted, message);
        }
        if (strict && stricted) {
            throwErrorTolerant(stricted, message);
        }
        strict = previousStrict;

        return delegate.markEnd(delegate.createFunctionExpression(id, params, [], body));
    }

    // 14 Program

    function parseSourceElement() {
        if (lookahead.type === Token.Keyword) {
            switch (lookahead.value) {
                case 'const':
                case 'let':
                    return parseConstLetDeclaration(lookahead.value);
                case 'function':
                    return parseFunctionDeclaration();
                default:
                    return parseStatement();
            }
        }

        if (lookahead.type !== Token.EOF) {
            return parseStatement();
        }
    }

    function parseSourceElements() {
        var sourceElement, sourceElements = [], token, directive, firstRestricted;

        while (index < length) {
            token = lookahead;
            if (token.type !== Token.StringLiteral) {
                break;
            }

            sourceElement = parseSourceElement();
            sourceElements.push(sourceElement);
            if (sourceElement.expression.type !== Syntax.Literal) {
                // this is not directive
                break;
            }
            directive = source.slice(token.range[0] + 1, token.range[1] - 1);
            if (directive === 'use strict') {
                strict = true;
                if (firstRestricted) {
                    throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);
                }
            } else {
                if (!firstRestricted && token.octal) {
                    firstRestricted = token;
                }
            }
        }

        while (index < length) {
            sourceElement = parseSourceElement();
            if (typeof sourceElement === 'undefined') {
                break;
            }
            sourceElements.push(sourceElement);
        }
        return sourceElements;
    }

    function parseProgram() {
        var body;

        skipComment();
        delegate.markStart();
        strict = false;
        peek();
        body = parseSourceElements();
        return delegate.markEnd(delegate.createProgram(body));
    }

    function attachComments() {
        var i, attacher, comment, leading, trailing;

        for (i = 0; i < extra.pendingComments.length; ++i) {
            attacher = extra.pendingComments[i];
            comment = attacher.comment;
            leading = attacher.leading;
            if (leading) {
                if (typeof leading.leadingComments === 'undefined') {
                    leading.leadingComments = [];
                }
                leading.leadingComments.push(attacher.comment);
            }
            trailing = attacher.trailing;
            if (trailing) {
                if (typeof trailing.trailingComments === 'undefined') {
                    trailing.trailingComments = [];
                }
                trailing.trailingComments.push(attacher.comment);
            }
        }
        extra.pendingComments = [];
    }

    function filterTokenLocation() {
        var i, entry, token, tokens = [];

        for (i = 0; i < extra.tokens.length; ++i) {
            entry = extra.tokens[i];
            token = {
                type: entry.type,
                value: entry.value
            };
            if (extra.range) {
                token.range = entry.range;
            }
            if (extra.loc) {
                token.loc = entry.loc;
            }
            tokens.push(token);
        }

        extra.tokens = tokens;
    }

    function LocationMarker() {
        this.marker = [index, lineNumber, index - lineStart, 0, 0, 0];
    }

    LocationMarker.prototype = {
        constructor: LocationMarker,

        end: function () {
            this.marker[3] = index;
            this.marker[4] = lineNumber;
            this.marker[5] = index - lineStart;
        },

        apply: function (node) {
            if (extra.range) {
                node.range = [this.marker[0], this.marker[3]];
            }
            if (extra.loc) {
                node.loc = {
                    start: {
                        line: this.marker[1],
                        column: this.marker[2]
                    },
                    end: {
                        line: this.marker[4],
                        column: this.marker[5]
                    }
                };
                node = delegate.postProcess(node);
            }
            if (extra.attachComment) {
                delegate.processComment(node);
            }
        }
    };

    function createLocationMarker() {
        if (!extra.loc && !extra.range) {
            return null;
        }

        skipComment();

        return new LocationMarker();
    }

    function tokenize(code, options) {
        var toString,
            token,
            tokens;

        toString = String;
        if (typeof code !== 'string' && !(code instanceof String)) {
            code = toString(code);
        }

        delegate = SyntaxTreeDelegate;
        source = code;
        index = 0;
        lineNumber = (source.length > 0) ? 1 : 0;
        lineStart = 0;
        length = source.length;
        lookahead = null;
        state = {
            allowIn: true,
            labelSet: {},
            inFunctionBody: false,
            inIteration: false,
            inSwitch: false,
            lastCommentStart: -1
        };

        extra = {};

        // Options matching.
        options = options || {};

        // Of course we collect tokens here.
        options.tokens = true;
        extra.tokens = [];
        extra.tokenize = true;
        // The following two fields are necessary to compute the Regex tokens.
        extra.openParenToken = -1;
        extra.openCurlyToken = -1;

        extra.range = (typeof options.range === 'boolean') && options.range;
        extra.loc = (typeof options.loc === 'boolean') && options.loc;

        if (typeof options.comment === 'boolean' && options.comment) {
            extra.comments = [];
        }
        if (typeof options.tolerant === 'boolean' && options.tolerant) {
            extra.errors = [];
        }

        if (length > 0) {
            if (typeof source[0] === 'undefined') {
                // Try first to convert to a string. This is good as fast path
                // for old IE which understands string indexing for string
                // literals only and not for string object.
                if (code instanceof String) {
                    source = code.valueOf();
                }
            }
        }

        try {
            peek();
            if (lookahead.type === Token.EOF) {
                return extra.tokens;
            }

            token = lex();
            while (lookahead.type !== Token.EOF) {
                try {
                    token = lex();
                } catch (lexError) {
                    token = lookahead;
                    if (extra.errors) {
                        extra.errors.push(lexError);
                        // We have to break on the first error
                        // to avoid infinite loops.
                        break;
                    } else {
                        throw lexError;
                    }
                }
            }

            filterTokenLocation();
            tokens = extra.tokens;
            if (typeof extra.comments !== 'undefined') {
                tokens.comments = extra.comments;
            }
            if (typeof extra.errors !== 'undefined') {
                tokens.errors = extra.errors;
            }
        } catch (e) {
            throw e;
        } finally {
            extra = {};
        }
        return tokens;
    }

    function parse(code, options) {
        var program, toString;

        toString = String;
        if (typeof code !== 'string' && !(code instanceof String)) {
            code = toString(code);
        }

        delegate = SyntaxTreeDelegate;
        source = code;
        index = 0;
        lineNumber = (source.length > 0) ? 1 : 0;
        lineStart = 0;
        length = source.length;
        lookahead = null;
        state = {
            allowIn: true,
            labelSet: {},
            inFunctionBody: false,
            inIteration: false,
            inSwitch: false,
            lastCommentStart: -1,
            markerStack: []
        };

        extra = {};
        if (typeof options !== 'undefined') {
            extra.range = (typeof options.range === 'boolean') && options.range;
            extra.loc = (typeof options.loc === 'boolean') && options.loc;
            extra.attachComment = (typeof options.attachComment === 'boolean') && options.attachComment;

            if (extra.loc && options.source !== null && options.source !== undefined) {
                extra.source = toString(options.source);
            }

            if (typeof options.tokens === 'boolean' && options.tokens) {
                extra.tokens = [];
            }
            if (typeof options.comment === 'boolean' && options.comment) {
                extra.comments = [];
            }
            if (typeof options.tolerant === 'boolean' && options.tolerant) {
                extra.errors = [];
            }
            if (extra.attachComment) {
                extra.range = true;
                extra.pendingComments = [];
                extra.comments = [];
            }
        }

        if (length > 0) {
            if (typeof source[0] === 'undefined') {
                // Try first to convert to a string. This is good as fast path
                // for old IE which understands string indexing for string
                // literals only and not for string object.
                if (code instanceof String) {
                    source = code.valueOf();
                }
            }
        }

        try {
            program = parseProgram();
            if (typeof extra.comments !== 'undefined') {
                program.comments = extra.comments;
            }
            if (typeof extra.tokens !== 'undefined') {
                filterTokenLocation();
                program.tokens = extra.tokens;
            }
            if (typeof extra.errors !== 'undefined') {
                program.errors = extra.errors;
            }
            if (extra.attachComment) {
                attachComments();
            }
        } catch (e) {
            throw e;
        } finally {
            extra = {};
        }

        return program;
    }

    // Sync with *.json manifests.
    exports.version = '1.1.0-dev';

    exports.tokenize = tokenize;

    exports.parse = parse;

    // Deep copy.
    exports.Syntax = (function () {
        var name, types = {};

        if (typeof Object.create === 'function') {
            types = Object.create(null);
        }

        for (name in Syntax) {
            if (Syntax.hasOwnProperty(name)) {
                types[name] = Syntax[name];
            }
        }

        if (typeof Object.freeze === 'function') {
            Object.freeze(types);
        }

        return types;
    }());

}));
/* vim: set sw=4 ts=4 et tw=80 : */FBL.ns(function() { with (FBL) {
/*****************************************************/
var fcScenarioGenerator = Firecrow.ScenarioGenerator;

fcScenarioGenerator.Event = function(baseObjectDescriptor, baseObjectModel, eventType, registrationConstruct, handlerConstruct)
{
    this.thisObjectDescriptor = baseObjectDescriptor;
    this.thisObjectModel = baseObjectModel;
    this.eventType = eventType;
    this.registrationConstruct = registrationConstruct;
    this.handlerConstruct = handlerConstruct;
    this.fingerprint = this.generateFingerprint();
    this.typeHandlerFingerPrint = this.generateTypeHandlerFingerprint();
};

fcScenarioGenerator.Event.areEqual = function(eventA, eventB)
{
    if(eventA == null || eventB == null) { return false; }

    return eventA.thisObjectDescriptor == eventB.thisObjectDescriptor
        && eventA.thisObjectModel == eventB.thisObjectModel
        && eventA.eventType == eventB.eventType
        && eventA.registrationConstruct == eventB.registrationConstruct
        && eventA.handlerConstruct == eventB.handlerConstruct;
};

fcScenarioGenerator.Event.createFromEventRegistration = function(eventRegistration)
{
    var event = new fcScenarioGenerator.Event
    (
        eventRegistration.thisObjectDescriptor,
        eventRegistration.thisObjectModel,
        eventRegistration.eventType,
        eventRegistration.registrationConstruct,
        eventRegistration.handlerConstruct
    );

    event.timePeriod = eventRegistration.timePeriod;

    return event;
};

fcScenarioGenerator.Event.prototype =
{
    generateFingerprint: function()
    {
        return this.thisObjectDescriptor + this.eventType + this.handlerConstruct.nodeId;
    },

    generateTypeHandlerFingerprint: function()
    {
        return this.eventType + this.handlerConstruct.nodeId;
    },

    isTimingEvent: function()
    {
        return this.eventType == "timeout" || this.eventType == "interval"
    },

    toString: function()
    {
        var attributes = this.thisObjectModel.attributes;

        var specifier = "";

        if(attributes != null)
        {
           for(var i = 0; i < attributes.length; i++)
           {
               if(attributes[i].name.toLowerCase() == "id")
               {
                   specifier += "#" + attributes[i].value;
               }
               else if(attributes[i].name.toLowerCase() == "class")
               {
                   specifier += "." + attributes[i].value;
               }
           }
        }

        return this.eventType + " on " + this.thisObjectDescriptor + specifier;
    }
}

fcScenarioGenerator.ParametrizedEvent = function (baseEvent, parameters)
{
    this.baseEvent = baseEvent;
    this.setParameters(parameters);
    this.fingerprint = this.baseEvent.fingerprint + JSON.stringify(this.parameters);
};

fcScenarioGenerator.ParametrizedEvent.createFromEvents = function(events, inputConstraint)
{
    var resolvedResults = inputConstraint != null ? inputConstraint.resolvedResult : [];

    var parametrizedEvents = [];

    for(var i = 0; i < events.length; i++)
    {
        parametrizedEvents.push(new fcScenarioGenerator.ParametrizedEvent(events[i], resolvedResults[i]));
    }

    return parametrizedEvents;
};

fcScenarioGenerator.ParametrizedEvent.prototype =
{
    setParameters: function(parameters)
    {
        this.parameters = this.normalizeParameters(parameters);
    },

    normalizeParameters: function(parameters)
    {
        var newObject = {};
        parameters = parameters || {};

        for(var propNameWithSuffix in parameters)
        {
            var fixedSuffix = !this._isDomProperty(propNameWithSuffix) ? fcScenarioGenerator.ScenarioGenerator.removeSuffix(propNameWithSuffix)
                                                                       : propNameWithSuffix;
            newObject[fixedSuffix] = parameters[propNameWithSuffix];
        }

        return newObject;
    },

    _isDomProperty: function(name)
    {
        return name.indexOf("DOM_") == 0;
    },

    containsMousePosition: function()
    {
        for(var name in this.parameters)
        {
            if(this._isMousePositionProperty(name))
            {
                return true;
            }
        }

        return false;
    },

    _isMousePositionProperty: function(propertyName)
    {
        return this._mousePositionProperties.indexOf(propertyName) >= 0;
    },

    _mousePositionProperties: ["pageX", "pageY", "clientX", "clientY", "screenX", "screenY"]
};
/*****************************************************/
}});FBL.ns(function() { with (FBL) {
/*****************************************************/
var fcScenarioGenerator = Firecrow.ScenarioGenerator;
var fcSymbolic = fcScenarioGenerator.Symbolic;

fcScenarioGenerator.Scenario = function(events, inputConstraint, parentScenarios, creationType)
{
    this.id = fcScenarioGenerator.Scenario.LAST_ID++;

    this.events = events || [];
    this.inputConstraint = inputConstraint || new fcSymbolic.PathConstraint();
    this.parentScenarios = parentScenarios || [];
    this.executionInfo = null;
    this.parametrizedEvents = [];
    this.creationType = creationType || fcScenarioGenerator.Scenario.CREATION_TYPE.default;
    this.setCoverage(0);
    this.generateFingerprint();
};

fcScenarioGenerator.Scenario.LAST_ID = 0;

fcScenarioGenerator.Scenario.CREATION_TYPE =
{
    default: "default",
    symbolic: "symbolic",
    newEvent: "newEvent",
    existingEvent: "existingEvent",
    timingEvents: "timingEvents"
};

fcScenarioGenerator.Scenario.prototype =
{
    addEvent: function(usageScenarioEvent)
    {
        this.events.push(usageScenarioEvent);
    },

    setParametrizedEvents: function(parametrizedEvents)
    {
        this.parametrizedEvents = parametrizedEvents;
    },

    setCoverage: function(coverage)
    {
        this.coverage = coverage;
    },

    isParent: function(scenario)
    {
        if(scenario == null || this.parentScenarios.length == 0) { return false; }

        return this.parentScenarios[0] == scenario
            || this.parentScenarios[1] == scenario;
    },

    isAncestor: function(scenario)
    {
        if(scenario == null || this.parentScenarios.length == 0) { return false; }

        return   this.isParent(scenario)
             || (this.parentScenarios[0] && this.parentScenarios[0].isAncestor(scenario))
             || (this.parentScenarios[1] && this.parentScenarios[1].isAncestor(scenario));
    },

    setExecutionInfo: function(executionInfo)
    {
        this.executionInfo = executionInfo;

        this.ownerCollection.aggregateEventCoverageInfo(this, executionInfo);
    },

    getEventExecutionsInfo: function(eventObjectDescriptor, eventType)
    {
        var executionInfos = [];

        if(this.executionInfo == null) { return executionInfos; }

        for(var i = 0; i < this.executionInfo.eventExecutions.length; i++)
        {
            var eventExecution = this.executionInfo.eventExecutions[i];
            if(eventExecution.baseObjectDescriptor == eventObjectDescriptor && eventExecution.eventType == eventType)
            {
                executionInfos.push(eventExecution);
            }
        }

        return executionInfos;
    },

    addInputConstraintItem: function(pathConstraintItem)
    {
        if(pathConstraintItem == null) { return; }

        this.inputConstraint.addPathConstraintItem(pathConstraintItem);
    },

    addSolutionIfNotExistent: function(identifier, solution)
    {
        this.inputConstraint.addSolutionIfNotExistent(identifier, solution);
    },

    createCopy: function()
    {
        return new fcScenarioGenerator.Scenario(this.events.slice(), this.inputConstraint.createCopy());
    },

    generateFingerprint: function()
    {
        var inputConstraintString = this.inputConstraint != null ? this.inputConstraint.toString() : "";
        var resolvedResult = this.inputConstraint != null ? JSON.stringify(this.inputConstraint.resolvedResult) : "";

        var eventsString = "";
        for(var i = 0 ; i < this.events.length; i++) { eventsString += this.events[i].generateFingerprint(); }

        return this.fingerprint = inputConstraintString + resolvedResult + eventsString;
    },

    isSymbolicCreationType: function() { return this.creationTypwe},

    isEqualTo: function(scenario)
    {
        return scenario != null
            && this.fingerprint == scenario.fingerprint;
    },

    isEqualToByComponents: function(events, inputConstraint)
    {
        var thisInputConstraintString = this.inputConstraint != null ? this.inputConstraint.toString() : "";
        var scenarioInputConstraintString = inputConstraint != null ? inputConstraint.toString() : "";
        var thisResolvedResult = this.inputConstraint != null ? JSON.stringify(this.inputConstraint.resolvedResult) : "";
        var scenarioResolvedResult = inputConstraint != null ? JSON.stringify(inputConstraint.resolvedResult) : "";

        return (thisInputConstraintString == scenarioInputConstraintString || thisResolvedResult == scenarioResolvedResult)
            && this._haveEqualEventsByComponents(events);
    },

    _haveEqualEventsByComponents: function(events)
    {
        if(this.events.length != events.length || this.events.length == 0) { return false; }

        for(var i = 0; i < this.events.length; i++)
        {
            if(!fcScenarioGenerator.Event.areEqual(this.events[i], events[i]))
            {
                return false;
            }
        }

        return true;
    },

    filterEvents: function(eventRegistrations)
    {
        var ownEvents = [];
        var thisEventRegistrations = this.executionInfo.eventRegistrations;

        for(var i = 0; i < thisEventRegistrations.length; i++)
        {
            if(!this._containsEvent(eventRegistrations, thisEventRegistrations[i]))
            {
                ownEvents.push(thisEventRegistrations[i]);
            }
        }

        return ownEvents;
    },

    /**
     * @param scenario
     * @returns {{areEqual: boolean, isFirstSubsetOfSecond: boolean, isSecondSubsetOfFirst: boolean}}
     */
    compareEvents: function(scenario)
    {
        var matchingEventsCount = 0;

        for(var i = 0; i < this.events.length; i++)
        {
            var iThEvent = this.events[i];

            for(var j = 0; j < scenario.events.length; j++)
            {
                var jThEvent = scenario.events[j];

                if(fcScenarioGenerator.Event.areEqual(iThEvent, jThEvent))
                {
                    matchingEventsCount++;
                }
            }
        }

        return {
            areEqual: matchingEventsCount == this.events.length && matchingEventsCount == scenario.events.length,
            isFirstSubsetOfSecond: matchingEventsCount == this.events.length && this.events.length < scenario.events.length,
            isSecondSubsetOfFirst: matchingEventsCount == scenario.events.length && scenario.events.length < this.events.length
        };
    },

    _containsEvent: function(events, event)
    {
        if(event == null || events == null || events.length == 0) { return false; }

        for(var i = 0; i < events.length; i++)
        {
            if(fcScenarioGenerator.Event.areEqual(events[i], event))
            {
                return true;
            }
        }

        return false;
    },

    toString: function()
    {
        var string = "";

        this.events.forEach(function (event)
        {
            if(string != "") { string += " - "; }

            string += event.toString();
        });

        return string;
    },

    setCreationTypeSymbolic: function()
    {
        this.creationType = fcScenarioGenerator.Scenario.CREATION_TYPE.symbolic;
    },

    setCreationTypeNewEvent: function()
    {
        this.creationType = fcScenarioGenerator.Scenario.CREATION_TYPE.newEvent;
    },

    isCreatedByWithTimingEvents: function()
    {
        return this.creationType == fcScenarioGenerator.Scenario.CREATION_TYPE.timingEvents;
    },

    isCreatedBySymbolic: function()
    {
        return this.creationType == fcScenarioGenerator.Scenario.CREATION_TYPE.symbolic;
    },

    isCreatedByNewEvent: function()
    {
        return this.creationType == fcScenarioGenerator.Scenario.CREATION_TYPE.newEvent;
    }
};
/*****************************************************/
}});FBL.ns(function() { with (FBL) {
/*****************************************************/
var fcSymbolic = Firecrow.ScenarioGenerator.Symbolic;
var ValueTypeHelper = Firecrow.ValueTypeHelper;
fcSymbolic.NumberRangeChain = function(chain)
{
    this.chain = chain || [];
};
fcSymbolic.NumberRangeChain.prototype =
{
    getFromRange: function()
    {
        if(this.chain.length == 0) { return null; }

        return this.chain[0].getFromRange();
    },

    appendChain: function(rangeChain, operator)
    {
        if(rangeChain == null || rangeChain.chain == null || rangeChain.chain.length == 0) { return; }

        if(operator == "&&")
        {
            this.chain = this._getChainIntersection(this.chain, rangeChain.chain);
        }
        else
        {
            ValueTypeHelper.pushAll(this.chain, rangeChain.chain);
        }
    },

    createCopy: function()
    {
        return new fcSymbolic.NumberRangeChain(this.chain.slice());
    },

    toString: function()
    {
        var string = "";

        for(var i = 0; i < this.chain.length; i++)
        {
            if(i != 0) { string += " || "; }
            string += this.chain[i];
        }

        return string;
    },

    _getChainIntersection: function(firstChain, secondChain)
    {
        var unionChain = [];

        for(var i = 0; i < firstChain.length; i++)
        {
            var firstRange = firstChain[i];

            for(var j = 0; j < secondChain.length; j++)
            {
                var secondRange = secondChain[j];

                var union = fcSymbolic.NumberRange.makeIntersection(firstRange, secondRange);

                if(union != null)
                {
                    ValueTypeHelper.pushAll(unionChain, union.chain);
                }
            }
        }

        return unionChain;
    }
};

fcSymbolic.NumberRangeChain.createSingleItemChain = function(lowerBound, upperBound)
{
    return new fcSymbolic.NumberRangeChain([new fcSymbolic.NumberRange(lowerBound, upperBound)]);
};
fcSymbolic.NumberRangeChain.upgradeToChain = function(numberRange)
{
    return new fcSymbolic.NumberRangeChain(numberRange);
};

fcSymbolic.NumberRangeChain.createTwoItemChain = function(lowerBoundA, upperBoundA, lowerBoundB, upperBoundB)
{
    return new fcSymbolic.NumberRangeChain([new fcSymbolic.NumberRange(lowerBoundA, upperBoundA), new fcSymbolic.NumberRange(lowerBoundB, upperBoundB)]);
};

fcSymbolic.NumberRangeChain.upgradeToTwoItemChain = function(numberRangeA, numberRangeB)
{
    return new fcSymbolic.NumberRangeChain([numberRangeA, numberRangeB]);
};

fcSymbolic.NumberRangeChain.performOperation = function(chainA, chainB, operation)
{
    var a = 3;
};

fcSymbolic.NumberRangeChain._getWithLowerLowerBound = function(rangeA, rangeB)
{
    if(rangeA == null) { return rangeB; }
    if(rangeB == null) { return rangeA; }

    return rangeA.lowerBound < rangeB.lowerBound ? rangeA : rangeB;
};

fcSymbolic.NumberRangeChain._getWithHigherUpperBound = function(rangeA, rangeB)
{
    if(rangeA == null) { return rangeB; }
    if(rangeB == null) { return rangeA; }

    return rangeA.upperBound > rangeB.upperBound ? rangeA : rangeB;
};

fcSymbolic.NumberRange = function(lowerBound, upperBound)
{
    this.lowerBound = Math.min(lowerBound, upperBound);
    this.upperBound = Math.max(lowerBound, upperBound);
};
fcSymbolic.NumberRange.prototype =
{
    getFromRange: function()
    {
        if(isFinite(this.lowerBound)) { return this.lowerBound; }
        if(isFinite(this.upperBound)) { return this.upperBound; }

        return 0;
    },

    toString: function()
    {
        return "[" + this.lowerBound + ", " + this.upperBound + "]";
    }
};

fcSymbolic.NumberRange.performOperation = function(rangeA, rangeB, operation)
{
    if(operation == "&&") { return fcSymbolic.NumberRange.makeIntersection(rangeA, rangeB); }
    else if(operation == "||") { return fcSymbolic.NumberRange.makeUnion(rangeA, rangeB); }

    alert("Unknown operation in Number Range");
    return null;
};

fcSymbolic.NumberRange.makeIntersection = function(rangeA, rangeB)
{
    if(rangeA == null || rangeB == null) { return new fcSymbolic.NumberRangeChain(); }

    if(this._areDisjunct(rangeA, rangeB)) { return new fcSymbolic.NumberRangeChain(); }
    if(this._areIntersecting(rangeA, rangeB) || this._arePartiallyOverlapping(rangeA, rangeB) || this._areSharingOneBound(rangeA, rangeB)) { return fcSymbolic.NumberRangeChain.createSingleItemChain(Math.max(rangeA.lowerBound, rangeB.lowerBound), Math.min(rangeA.upperBound, rangeB.upperBound)); }
    if(this._areWhollyOverlapping(rangeA, rangeB)) { return fcSymbolic.NumberRangeChain.createSingleItemChain(rangeA.lowerBound, rangeA.upperBound); }
    if(this._isContainedWithin(rangeA, rangeB)) { return fcSymbolic.NumberRangeChain.createSingleItemChain(rangeA.lowerBound, rangeA.upperBound); }
    if(this._isContainedWithin(rangeB, rangeA)) { return fcSymbolic.NumberRangeChain.createSingleItemChain(rangeB.lowerBound, rangeB.upperBound); }
    if(this._areSharingOneBound(rangeA, rangeB)) { return fcSymbolic.NumberRangeChain.createSingleItemChain(); }

    alert("Should not be here when making intersection");

    return null;
};

fcSymbolic.NumberRange.makeUnion = function(rangeA, rangeB)
{
    if(rangeA == null && rangeB == null) { return new fcSymbolic.NumberRangeChain();}

    if(rangeA == null) { return fcSymbolic.NumberRangeChain.upgradeToChain(rangeB); }
    if(rangeB == null) { return fcSymbolic.NumberRangeChain.upgradeToChain(rangeA); }


    if(this._areDisjunct(rangeA, rangeB)) { return fcSymbolic.NumberRangeChain.upgradeToTwoItemChain(fcSymbolic.NumberRangeChain._getWithLowerLowerBound(rangeA, rangeB), fcSymbolic.NumberRangeChain._getWithHigherUpperBound(rangeA, rangeB)); }
    if(this._areIntersecting(rangeA, rangeB) || this._arePartiallyOverlapping(rangeA, rangeB) || this._areSharingOneBound(rangeA, rangeB)) { return fcSymbolic.NumberRangeChain.createSingleItemChain(Math.min(rangeA.lowerBound, rangeB.lowerBound), Math.max(rangeA.upperBound, rangeB.upperBound)); }
    if(this._areWhollyOverlapping(rangeA, rangeB)) { return fcSymbolic.NumberRangeChain.createSingleItemChain(rangeA.lowerBound, rangeA.upperBound); }
    if(this._isContainedWithin(rangeA, rangeB)) { return fcSymbolic.NumberRangeChain.createSingleItemChain(rangeB.lowerBound, rangeB.upperBound); }
    if(this._isContainedWithin(rangeB, rangeA)) { return fcSymbolic.NumberRangeChain.createSingleItemChain(rangeA.lowerBound, rangeA.upperBound); }

    alert("Should not be here when making union!");
};

fcSymbolic.NumberRange._areDisjunct = function(rangeA, rangeB)
{
    return (rangeA.lowerBound < rangeB.lowerBound && rangeA.upperBound < rangeB.upperBound && rangeA.upperBound < rangeB.lowerBound)
        || (rangeB.lowerBound < rangeA.lowerBound && rangeB.upperBound < rangeA.upperBound && rangeB.upperBound < rangeA.lowerBound);
};

fcSymbolic.NumberRange._areIntersecting = function(rangeA, rangeB)
{
    return (rangeA.lowerBound < rangeB.lowerBound && rangeA.upperBound < rangeB.upperBound && rangeA.upperBound > rangeB.lowerBound)
        || (rangeB.lowerBound < rangeA.lowerBound && rangeB.upperBound < rangeA.upperBound && rangeB.upperBound > rangeA.lowerBound);
};

fcSymbolic.NumberRange._arePartiallyOverlapping = function(rangeA, rangeB)
{
    return rangeA.lowerBound == rangeB.lowerBound
        || rangeA.upperBound == rangeB.upperBound;
};

fcSymbolic.NumberRange._areSharingOneBound = function(rangeA, rangeB)
{
    return (rangeA.upperBound == rangeB.lowerBound && rangeA.lowerBound != rangeB.upperBound)
        || (rangeB.upperBound == rangeA.lowerBound && rangeB.lowerBound != rangeA.upperBound);
};

fcSymbolic.NumberRange._areWhollyOverlapping = function(rangeA, rangeB)
{
    return rangeA.lowerBound == rangeB.lowerBound
        && rangeA.upperBound == rangeB.upperBound;
};

fcSymbolic.NumberRange._isContainedWithin = function(innerRange, outerRange)
{
    return innerRange.lowerBound > outerRange.lowerBound && innerRange.upperBound < outerRange.upperBound;
};
/*****************************************************/
}});FBL.ns(function() { with (FBL) {
/*****************************************************/
var ValueTypeHelper = Firecrow.ValueTypeHelper;
var fcSymbolic = Firecrow.ScenarioGenerator.Symbolic;

fcSymbolic.StringConstraint = function(value, operator)
{
    this.value = value;
    this.operator = operator;
};

fcSymbolic.StringConstraint.prototype.toString = function()
{
    return this.operator + " " + this.value;
};

fcSymbolic.StringConstraintChain = function(chain)
{
    this.chain = chain || [];
};

fcSymbolic.StringConstraintChain.prototype =
{
    getFromRange: function()
    {
        var equalsValues = this._filterConstraintsValues(["==", "==="]);
        var notEqualsValues = this._filterConstraintsValues(["!=", "!=="]);

        if(equalsValues.length > 1) { return null; } //Can not resolve that a variable should be equal to multiple values
        if(this._containAtLeastOneCommonValue(equalsValues, notEqualsValues)) { return null; } //Can not have the same value in equals and not equals values

        if(equalsValues.length == 1) { return equalsValues[0]; }

        return "Should generate a string based on non-equals";
    },

    appendChain: function(rangeChain)
    {
        if(rangeChain == null || rangeChain.chain == null || rangeChain.chain.length == 0) { return; }

        ValueTypeHelper.pushAll(this.chain, rangeChain.chain);
    },

    createCopy: function()
    {
        return new fcSymbolic.StringConstraintChain(this.chain.slice());
    },

    _filterConstraintsValues: function(operators)
    {
        var constraints = [];

        for(var i = 0; i < this.chain.length; i++)
        {
            var chainItem = this.chain[i];

            if(operators.indexOf(chainItem.operator) != -1)
            {
                constraints.push(chainItem);
            }
        }

        var values = [];

        for(var i = 0; i < constraints.length; i++)
        {
            if(values.indexOf(constraint.value) == -1)
            {
                values.push(constraint.value);
            }
        }

        return values;
    },

    _containAtLeastOneCommonValue: function(arrayA, arrayB)
    {
        for(var i = 0; i < arrayA.length; i++)
        {
            if(arrayB.indexOf(arrayA[i]) != -1) { return true; }
        }

        return false;
    },

    toString: function()
    {
        var string = "";

        for(var i = 0; i < this.chain.length; i++)
        {
            if(i != 0) { string += " && "; }
            string += this.chain[i];
        }

        return string;
    }
};
/*****************************************************/
}});FBL.ns(function() { with (FBL) {
/*****************************************************/
var ValueTypeHelper = Firecrow.ValueTypeHelper;
//https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API
/*
 - Expression
 - ThisExpression ?
 - Identifier
 - Literal
 - SequenceExpression
 - expressions: [Expression]
 - UnaryExpression
 - operator: UnaryOperator (- + ! ~ typeof void delete)
 - prefix: boolean
 - argument: Expression
 - BinaryExpression
 - operator: BinaryOperator (!= === !== < <= > >= << >> >>> + - * / % | ^ in instanceof ..)
 - left: Expression
 - right: Expression
 - UpdateExpression
 - operator: UpdateOperator ++ --
 - prefix: boolean
 - argument: Expression
 - LogicalExpression
 - operator (&& ||)
 - left: Expression
 - right: Expression
 - ConditionalExpression ?
 - test: Expression
 - alternate: Expression
 - consequent: Expression
 - MemberExpression ?
 - object: Expression
 - property: Identifier | Expression
 * */

var fcSymbolic = Firecrow.ScenarioGenerator.Symbolic;
var fcScenarioGenerator = Firecrow.ScenarioGenerator;
fcSymbolic.CONST =
{
    IDENTIFIER: "Identifier",
    LITERAL: "Literal",
    SEQUENCE: "Sequence",
    UNARY: "Unary",
    BINARY: "Binary",
    UPDATE: "Update",
    LOGICAL: "Logical",
    BINARY_OP:
    {
        LT: "<",
        GT: ">",
        LET: "<=",
        GET: ">=",
        EQ: "==",
        NEQ: "!=",
        TEQ: "===",
        TNEQ: "!==",
        MUL: "*",
        DIV: "/",
        ADD: "+",
        SUB: "-",

        getInverse: function(operator)
        {
            switch(operator)
            {
                case fcSymbolic.CONST.BINARY_OP.LT: return fcSymbolic.CONST.BINARY_OP.GET;
                case fcSymbolic.CONST.BINARY_OP.GT: return fcSymbolic.CONST.BINARY_OP.LET;
                case fcSymbolic.CONST.BINARY_OP.LET: return fcSymbolic.CONST.BINARY_OP.GT;
                case fcSymbolic.CONST.BINARY_OP.GET: return fcSymbolic.CONST.BINARY_OP.LT;
                case fcSymbolic.CONST.BINARY_OP.EQ: return fcSymbolic.CONST.BINARY_OP.NEQ;
                case fcSymbolic.CONST.BINARY_OP.NEQ: return fcSymbolic.CONST.BINARY_OP.EQ;
                case fcSymbolic.CONST.BINARY_OP.TEQ: return fcSymbolic.CONST.BINARY_OP.TNEQ;
                case fcSymbolic.CONST.BINARY_OP.TNEQ: return fcSymbolic.CONST.BINARY_OP.TEQ;
                case fcSymbolic.CONST.BINARY_OP.DIV: return fcSymbolic.CONST.BINARY_OP.MUL;
                case fcSymbolic.CONST.BINARY_OP.MUL: return fcSymbolic.CONST.BINARY_OP.DIV;
                case fcSymbolic.CONST.BINARY_OP.ADD: return fcSymbolic.CONST.BINARY_OP.SUB;
                case fcSymbolic.CONST.BINARY_OP.SUB: return fcSymbolic.CONST.BINARY_OP.ADD;
                default:
                    debugger; alert("Opposite Binary - should not be here: " + operator); return null;
            }
        },

        getSwapPositionOperator: function(operator)
        {
            switch(operator)
            {
                case fcSymbolic.CONST.BINARY_OP.LT: return fcSymbolic.CONST.BINARY_OP.GT;
                case fcSymbolic.CONST.BINARY_OP.GT: return fcSymbolic.CONST.BINARY_OP.LT;
                case fcSymbolic.CONST.BINARY_OP.LET: return fcSymbolic.CONST.BINARY_OP.GET;
                case fcSymbolic.CONST.BINARY_OP.GET: return fcSymbolic.CONST.BINARY_OP.LET;
                case fcSymbolic.CONST.BINARY_OP.EQ: return fcSymbolic.CONST.BINARY_OP.EQ;
                case fcSymbolic.CONST.BINARY_OP.NEQ: return fcSymbolic.CONST.BINARY_OP.NEQ;
                case fcSymbolic.CONST.BINARY_OP.TEQ: return fcSymbolic.CONST.BINARY_OP.TEQ;
                case fcSymbolic.CONST.BINARY_OP.TNEQ: return fcSymbolic.CONST.BINARY_OP.TNEQ;
                default: debugger; alert("Swap Binary - should not be here: " + operator); return null;
            }
        },

        isArithmeticOperator: function(operator)
        {
            switch(operator)
            {
                case fcSymbolic.CONST.BINARY_OP.ADD:
                case fcSymbolic.CONST.BINARY_OP.SUB:
                case fcSymbolic.CONST.BINARY_OP.MUL:
                case fcSymbolic.CONST.BINARY_OP.DIV:
                    return true;
                default:
                    return false;
            }
        },

        isEqualityOperator: function(operator)
        {
            switch(operator)
            {
                case fcSymbolic.CONST.BINARY_OP.EQ:
                case fcSymbolic.CONST.BINARY_OP.NEQ:
                case fcSymbolic.CONST.BINARY_OP.TEQ:
                case fcSymbolic.CONST.BINARY_OP.TNEQ:
                    return true;
                default:
                    return false;
            }
        }
    }
};

fcSymbolic.Expression = function(){};
fcSymbolic.Expression.LAST_ID = 0;
fcSymbolic.Expression.prototype =
{
    isIdentifier: function() { return this.type == fcSymbolic.CONST.IDENTIFIER; },
    isLiteral: function() { return this.type == fcSymbolic.CONST.LITERAL; },
    isSequence: function() { return this.type == fcSymbolic.CONST.SEQUENCE; },
    isUnary: function() { return this.type == fcSymbolic.CONST.UNARY; },
    isBinary: function() { return this.type == fcSymbolic.CONST.BINARY; },
    isBinaryStringLiteral: function() { return this.isBinary() && this.left.isIdentifier() && this.right.isLiteral() && ValueTypeHelper.isString(this.right.value); },
    isUpdate: function() { return this.type == fcSymbolic.CONST.UPDATE; },
    isLogical: function() { return this.type == fcSymbolic.CONST.LOGICAL; },
    markAsIrreversible: function() { this.isIrreversible = true; },
    setId: function()
    {
        this.id = fcSymbolic.Expression.LAST_ID;
        fcSymbolic.Expression.LAST_ID++;
    }
}

fcSymbolic.Identifier = function(name)
{
    this.setId();

    this.name = name;

    this.type = fcSymbolic.CONST.IDENTIFIER;
};
fcSymbolic.Identifier.prototype = new fcSymbolic.Expression();
fcSymbolic.Identifier.prototype.toString = function() { return this.name; }
fcSymbolic.Identifier.prototype.containsNumericExpressions = function() { return false; };
fcSymbolic.Identifier.prototype.containsStringExpressions = function() { return false; };
fcSymbolic.Identifier.prototype.getIdentifierNames = function() { return [this.name]; };
fcSymbolic.Identifier.prototype.getStringLiterals = function() { return []; };
fcSymbolic.Identifier.prototype.getHtmlElements = function() { return this.htmlElement != null ? [this.htmlElement] : []; };
fcSymbolic.Identifier.prototype.createCopyUpgradedByIndex = function(upgradeByIndex)
{
    return new fcSymbolic.Identifier(fcScenarioGenerator.ScenarioGenerator.addToPropertyName(this.name, upgradeByIndex));
};
fcSymbolic.Identifier.prototype.createCopyWithIndex = function(newIndex)
{
    return new fcSymbolic.Identifier(fcScenarioGenerator.ScenarioGenerator.updatePropertyNameWithNewIndex(this.name, newIndex));
};

fcSymbolic.Identifier.prototype.createCopyWithReplacedLiterals = function(replacement) { return new fcSymbolic.Identifier(this.name); }
fcSymbolic.Identifier.prototype.hasOnlyIdentifiers = function() { return true; }
fcSymbolic.Identifier.prototype.toJSON = function() { return { type: this.type, name: this.name, isIrreversible: this.isIrreversible }; }

fcSymbolic.Literal = function(value)
{
    this.setId();

    this.value = value;

    if(this.value === undefined || this.value === null)
    {
        this.value = 0;
    }

    this.type = fcSymbolic.CONST.LITERAL;
};
fcSymbolic.Literal.prototype = new fcSymbolic.Expression();
fcSymbolic.Literal.prototype.containsNumericExpressions = function() { return ValueTypeHelper.isNumber(this.value); };
fcSymbolic.Literal.prototype.containsStringExpressions = function() { return ValueTypeHelper.isString(this.value); };
fcSymbolic.Literal.prototype.getIdentifierNames = function() { return [];};
fcSymbolic.Literal.prototype.getStringLiterals = function() { return ValueTypeHelper.isString(this.value) ? [this.value] : []; };
fcSymbolic.Literal.prototype.createCopyWithReplacedLiterals = function(replacement)
{
    return replacement[this.value] !== null ? new fcSymbolic.Literal(replacement[this.value])
                                            : new fcSymbolic.Literal(this.value);
};
fcSymbolic.Literal.prototype.toString = function()
{
    return ValueTypeHelper.isString(this.value) ? '"' + this.value + '"'
                                                : this.value;
};
fcSymbolic.Literal.prototype.createCopyUpgradedByIndex = function(upgradeByIndex)
{
    return new fcSymbolic.Literal(this.value);
};
fcSymbolic.Literal.prototype.createCopyWithIndex = function(index)
{
    return new fcSymbolic.Literal(this.value);
};
fcSymbolic.Literal.prototype.hasOnlyIdentifiers = function() { return false; }
fcSymbolic.Literal.prototype.toJSON = function() { return { type: this.type, value: this.value, isIrreversible: this.isIrreversible }; }

fcSymbolic.Unary = function(argument, operator, prefix)
{
    this.setId();

    this.argument = argument;
    this.operator = operator;
    this.prefix = prefix;

    this.type = fcSymbolic.CONST.UNARY;
};
fcSymbolic.Unary.prototype = new fcSymbolic.Expression();
fcSymbolic.Unary.prototype.containsNumericExpressions = function() { return this.argument.containsNumericExpressions(); };
fcSymbolic.Unary.prototype.containsStringExpressions = function() { return this.argument.containsStringExpressions(); };
fcSymbolic.Unary.prototype.getIdentifierNames = function() { return this.argument.getIdentifierNames(); }
fcSymbolic.Unary.prototype.getStringLiterals = function() { return this.argument.getStringLiterals(); };
fcSymbolic.Unary.prototype.createCopyWithReplacedLiterals = function(replacement)
{
    return new fcSymbolic.Logical(this.argument.createCopyWithReplacedLiterals(replacement), this.operator, this.prefix);
};
fcSymbolic.Unary.prototype.toString = function()
{
    var string = "";

    if(this.prefix) { string += this.operator; }

    string += this.argument;

    if(!this.prefix) { string += this.operator; }

    return string;
};
fcSymbolic.Unary.prototype.createCopyUpgradedByIndex = function(upgradeByIndex)
{
    return new fcSymbolic.Unary(this.argument.createCopyUpgradedByIndex(upgradeByIndex), this.operator, this.prefix);
};

fcSymbolic.Unary.prototype.createCopyWithIndex = function(index)
{
    return new fcSymbolic.Unary(this.argument.createCopyWithIndex(index), this.operator, this.prefix);
};

fcSymbolic.Unary.prototype.hasOnlyIdentifiers = function() { return this.argument.hasOnlyIdentifiers(); }
fcSymbolic.Unary.prototype.toJSON = function() { return { type: this.type, operator: this.operator, prefix: this.prefix, argument: this.argument.toJSON(), isIrreversible: this.isIrreversible }; }

fcSymbolic.Binary = function(left, right, operator)
{
    this.setId();

    this.left = left;
    this.right = right;
    this.operator = operator;

    this.type = fcSymbolic.CONST.BINARY;
};
fcSymbolic.Binary.createIrreversibleIdentifierEqualsLiteral = function(identifierName, literalValue)
{
    var binary = new fcSymbolic.Binary(new fcSymbolic.Identifier(identifierName), new fcSymbolic.Literal(literalValue), "==");

    binary.markAsIrreversible();

    return binary;
};

fcSymbolic.Binary.createIrreversibleIdentifierGreaterEqualsThanLiteral = function(identifierName, literalValue)
{
    var binary = new fcSymbolic.Binary(new fcSymbolic.Identifier(identifierName), new fcSymbolic.Literal(literalValue), ">=");

    binary.markAsIrreversible();

    return binary;
};

fcSymbolic.Binary.prototype = new fcSymbolic.Expression();
fcSymbolic.Binary.prototype.toString = function() { return this.left + " " + this.operator + " " + this.right; };
fcSymbolic.Binary.prototype.containsNumericExpressions = function() { return this.left.containsNumericExpressions() || this.right.containsNumericExpressions(); };
fcSymbolic.Binary.prototype.containsStringExpressions = function() { return this.left.containsStringExpressions() || this.right.containsStringExpressions(); };
fcSymbolic.Binary.prototype.getStringLiterals = function() { return this.left.getStringLiterals().concat(this.right.getStringLiterals()); };
fcSymbolic.Binary.prototype.createCopyWithReplacedLiterals = function(replacement)
{
    return new fcSymbolic.Binary(this.left.createCopyWithReplacedLiterals(replacement), this.right.createCopyWithReplacedLiterals(replacement), this.operator);
};
fcSymbolic.Binary.prototype.getIdentifierNames = function()
{
    var identifierNames = [];

    ValueTypeHelper.pushAll(identifierNames, this.left.getIdentifierNames());
    ValueTypeHelper.pushAll(identifierNames, this.right.getIdentifierNames());

    return  identifierNames;
};

fcSymbolic.Binary.prototype.createCopyUpgradedByIndex = function(upgradeByIndex)
{
    return new fcSymbolic.Binary(this.left.createCopyUpgradedByIndex(upgradeByIndex), this.right.createCopyUpgradedByIndex(upgradeByIndex), this.operator);
};
fcSymbolic.Binary.prototype.createCopyWithIndex = function(index)
{
    return new fcSymbolic.Binary(this.left.createCopyWithIndex(index), this.right.createCopyWithIndex(index), this.operator);
};
fcSymbolic.Binary.prototype.hasOnlyIdentifiers = function() { return this.left.hasOnlyIdentifiers() && this.right.hasOnlyIdentifiers(); }
fcSymbolic.Binary.prototype.toJSON = function() { return { type: this.type, operator: this.operator, left: this.left.toJSON(), right: this.right.toJSON(), isIrreversible: this.isIrreversible }; }

fcSymbolic.Update = function(argument, operator, prefix)
{
    this.setId();

    this.argument = argument;
    this.operator = operator;
    this.prefix = prefix;

    this.type = fcSymbolic.CONST.UPDATE;
};
fcSymbolic.Update.prototype = new fcSymbolic.Expression();
fcSymbolic.Update.prototype.containsNumericExpressions = function() { return this.argument.containsNumericExpressions(); };
fcSymbolic.Update.prototype.containsStringExpressions = function() { return this.argument.containsStringExpressions(); };
fcSymbolic.Update.prototype.getStringLiterals = function() { return this.argument.getStringLiterals(); };
fcSymbolic.Update.prototype.toString = function()
{
    var string = "";

    if(this.prefix) { string += this.operator; }

    string += this.argument;

    if(!this.prefix) { string += this.operator; }

    return string;
};
fcSymbolic.Update.prototype.createCopyWithReplacedLiterals = function(replacement)
{
    return new fcSymbolic.Update(this.argument.createCopyWithReplacedLiterals(), this.operator, this.prefix);
};

fcSymbolic.Update.prototype.createCopyUpgradedByIndex = function(upgradeByIndex)
{
    return new fcSymbolic.Update(this.argument.createCopyUpgradedByIndex(upgradeByIndex), this.operator, this.prefix);
};

fcSymbolic.Update.prototype.createCopyWithIndex = function(index)
{
    return new fcSymbolic.Update(this.argument.createCopyWithIndex(index), this.operator, this.prefix);
};
fcSymbolic.Update.prototype.hasOnlyIdentifiers = function() { return this.argument.hasOnlyIdentifiers(); }
fcSymbolic.Update.prototype.toJSON = function() { return { type: this.type, operator: this.operator, prefix: this.prefix, argument: this.argument.toJSON(), isIrreversible: this.isIrreversible }; }

fcSymbolic.Logical = function(left, right, operator)
{
    this.setId();

    this.left = left;
    this.right = right;
    this.operator = operator;

    this.type = fcSymbolic.CONST.LOGICAL;
    this._fix();
};

fcSymbolic.Logical.createIrreversibleOr = function(left, right)
{
    var logical = new fcSymbolic.Logical(left, right, "||");

    logical.markAsIrreversible();

    return logical;
};

fcSymbolic.Logical.prototype = new fcSymbolic.Expression();
fcSymbolic.Logical.prototype.containsNumericExpressions = function() { return this.left.containsNumericExpressions() || this.right.containsNumericExpressions(); };
fcSymbolic.Logical.prototype.containsNumericExpressions = function() { return this.left.containsNumericExpressions() || this.right.containsNumericExpressions(); };
fcSymbolic.Logical.prototype.containsStringExpressions = function() { return this.left.containsStringExpressions() || this.right.containsStringExpressions(); };
fcSymbolic.Logical.prototype.getStringLiterals = function() { return this.left.getStringLiterals().concat(this.right.getStringLiterals()); };
fcSymbolic.Logical.prototype.createCopyWithReplacedLiterals = function(replacement)
{
    return new fcSymbolic.Logical(this.left.createCopyWithReplacedLiterals(replacement), this.right.createCopyWithReplacedLiterals(replacement), this.operator);
};
fcSymbolic.Logical.prototype.getIdentifierNames = function()
{
    var identifierNames = [];

    ValueTypeHelper.pushAll(identifierNames, this.left.getIdentifierNames());
    ValueTypeHelper.pushAll(identifierNames, this.right.getIdentifierNames());

    return  identifierNames;
};
fcSymbolic.Logical.prototype.toString = function() { return this.left + " " + this.operator + " " + this.right; };
fcSymbolic.Logical.prototype.createCopyUpgradedByIndex = function(upgradeByIndex)
{
    return new fcSymbolic.Logical(this.left.createCopyUpgradedByIndex(upgradeByIndex), this.right.createCopyUpgradedByIndex(upgradeByIndex), this.operator);
};
fcSymbolic.Logical.prototype.createCopyWithIndex = function(index)
{
    return new fcSymbolic.Logical(this.left.createCopyWithIndex(index), this.right.createCopyWithIndex(index), this.operator);
};
fcSymbolic.Logical.prototype._fix = function()
{
    if(this.left.type == fcSymbolic.CONST.IDENTIFIER && this.right.type == fcSymbolic.CONST.IDENTIFIER)
    {
        this.left = new fcSymbolic.Binary(this.left, new fcSymbolic.Literal(0), ">=");
        this.right = new fcSymbolic.Binary(this.right, new fcSymbolic.Literal(0), ">=");
    }
};

fcSymbolic.Logical.prototype.hasOnlyIdentifiers = function() { return this.left.hasOnlyIdentifiers() && this.right.hasOnlyIdentifiers(); }
fcSymbolic.Logical.prototype.toJSON = function() { return { type: this.type, operator: this.operator, left: this.left.toJSON(), right: this.right.toJSON(), isIrreversible: this.isIrreversible}; }
}});FBL.ns(function() { with (FBL) {
/*****************************************************/
var ASTHelper = Firecrow.ASTHelper;
var fcSymbolic = Firecrow.ScenarioGenerator.Symbolic;
var fcScenarioGenerator = Firecrow.ScenarioGenerator;
var ValueTypeHelper = Firecrow.ValueTypeHelper;

fcSymbolic.PathConstraintItem = function(codeConstruct, constraint)
{
    this.id = fcSymbolic.PathConstraintItem.LAST_ID++

    this.codeConstruct = codeConstruct;
    this.constraint = constraint;

    if(constraint == null) { debugger; }
};

fcSymbolic.PathConstraintItem.areEqual = function(pathConstraintItemA, pathConstraintItemB)
{
    if(pathConstraintItemA == null || pathConstraintItemB == null) { return false; }

    return pathConstraintItemA.codeConstruct == pathConstraintItemB.codeConstruct
        && fcScenarioGenerator.ScenarioGenerator.replaceSuffix(pathConstraintItemA.constraint.toString(), "") == fcScenarioGenerator.ScenarioGenerator.replaceSuffix(pathConstraintItemB.constraint.toString(), "");
};

fcSymbolic.PathConstraintItem.LAST_ID = 0;

fcSymbolic.PathConstraintItem.prototype =
{
    getSymbolicIdentifierNameMap: function()
    {
        if(this.constraint == null) { return {}; }

        var map = {};
        var identifierNames = this.constraint.getIdentifierNames();

        for(var i = 0; i < identifierNames.length; i++)
        {
            map[identifierNames[i]] = true;
        }

        return map;
    },

    toString: function()
    {
        try
        {
            return this.constraint.toString();
        }
        catch(e) { debugger; }
    },

    toJSON: function()
    {
        return {
            codeConstructId: this.codeConstruct != null ? this.codeConstruct.nodeId : 0,
            constraint: this.constraint
        };
    },

    createCopyUpgradedByIndex: function(upgradeByIndex)
    {
        return new fcSymbolic.PathConstraintItem(this.codeConstruct, this.constraint.createCopyUpgradedByIndex(upgradeByIndex))
    },

    createCopyWithIndex: function(index)
    {
        return new fcSymbolic.PathConstraintItem(this.codeConstruct, this.constraint.createCopyWithIndex(index));
    }
};

fcSymbolic.PathConstraint = function(pathConstraintItems, resolvedResult)
{
    this.id = fcSymbolic.PathConstraint.LAST_ID++;
    this.pathConstraintItems = pathConstraintItems || [];
    this.resolvedResult = resolvedResult || {};
};

fcSymbolic.PathConstraint.LAST_ID = 0;
fcSymbolic.PathConstraint.RESOLVED_MAPPING = { takenPaths: []};

fcSymbolic.PathConstraint.resolvePathConstraints = function(pathConstraints)
{
    var symbolicExpressionsList = [];

    for(var i = 0; i < pathConstraints.length; i++)
    {
        var pathConstraint = pathConstraints[i];

        var constrainedItems = [];

        for(var j = 0; j < pathConstraint.pathConstraintItems.length; j++)
        {
            var item = pathConstraint.pathConstraintItems[j];

            if(item.constraint != null)
            {
                constrainedItems.push(item.constraint);
            }
        }

        symbolicExpressionsList.push(constrainedItems);
    }

    var results = fcSymbolic.ConstraintResolver.resolveConstraints(symbolicExpressionsList);

    for(var i = 0; i < pathConstraints.length; i++)
    {
        var current = results[i];

        var groupedByIndex = this.groupSolutionsByIndex(current);

        if(ValueTypeHelper.isEmptyObject(groupedByIndex))
        {
            ValueTypeHelper.removeFromArrayByIndex(pathConstraints, i);
            ValueTypeHelper.removeFromArrayByIndex(results, i);
            i--;
            continue;
        }

        pathConstraints[i].resolvedResult = groupedByIndex;
    }
};

fcSymbolic.PathConstraint.groupSolutionsByIndex = function(result)
{
    var mappedObject = {};

    for(var propName in result)
    {
        var match = propName.match(/_FC_([0-9+])/);
        var index = match[1];

        if(index)
        {
            if(mappedObject[index] == null)
            {
                mappedObject[index] = {};
            }

            mappedObject[index][propName] = result[propName];
        }
    }

    return mappedObject;
};

fcSymbolic.PathConstraint.prototype =
{
    getLastPathConstraintItemCodeConstruct: function()
    {
        var lastItem = this.pathConstraintItems[this.pathConstraintItems.length - 1];

        if(lastItem == null) { return null; }

        return lastItem.codeConstruct;
    },

    addConstraint: function(codeConstruct, constraint, inverse)
    {
        this.addPathConstraintItem(this._createConstraint(codeConstruct, constraint, inverse));
    },

    addSolutionIfNotExistent: function(identifier, value)
    {
        var match = identifier.match(/_FC_([0-9+])/);

        if(match == null) { debugger; }

        var index = match[1];

        if(index)
        {
            if(this.resolvedResult[index] == null)
            {
                this.resolvedResult[index] = {};
            }

            if(this.resolvedResult[index][identifier] == null)
            {
                this.resolvedResult[index][identifier] = value;
            }

        }
    },

    addPathConstraintItem: function(pathConstraintItem)
    {
        var sameConstraint = this._getSameConstraint(pathConstraintItem);

        if(sameConstraint != null)
        {
            sameConstraint.constraint.isIrreversible = sameConstraint.constraint.isIrreversible || pathConstraintItem.constraint.isIrreversible;
        }
        else
        {
            this.pathConstraintItems.push(pathConstraintItem);
        }
    },

    addPathConstraintItemToBeginning: function(pathConstraintItem)
    {
        var sameConstraint = this._getSameConstraint(pathConstraintItem);

        if(sameConstraint != null)
        {
            sameConstraint.constraint.isIrreversible = sameConstraint.constraint.isIrreversible || pathConstraintItem.constraint.isIrreversible;
        }
        else
        {
            ValueTypeHelper.insertIntoArrayAtIndex(this.pathConstraintItems, pathConstraintItem, 0);
        }
    },

    _getSameConstraint: function(pathConstraintItem)
    {
        var pathConstraintItemString = pathConstraintItem.toString();

        for(var i = 0; i < this.pathConstraintItems.length; i++)
        {
            if(this.pathConstraintItems[i].toString() == pathConstraintItemString)
            {
                return this.pathConstraintItems[i];
            }
        }

        return null;
    },

    getImmutableConstraints: function()
    {
        var notInvertedConstraints = [];

        for(var i = 0; i < this.pathConstraintItems.length; i++)
        {
            if(this.pathConstraintItems[i].constraint.isIrreversible)
            {
                notInvertedConstraints.push(this.pathConstraintItems[i]);
            }
        }

        return notInvertedConstraints;
    },

    _createConstraint: function(codeConstruct, constraint, inverse)
    {
        if(constraint != null && constraint.isBinary() && fcSymbolic.CONST.BINARY_OP.isArithmeticOperator(constraint.operator))
        {
            constraint = fcSymbolic.SymbolicExecutor.simplifyExpression(new fcSymbolic.Binary(constraint, new fcSymbolic.Literal(0), "!="));
        }

        if(inverse)
        {
            constraint = fcSymbolic.ConstraintResolver.getInverseConstraint(constraint);
        }

        return new fcSymbolic.PathConstraintItem(codeConstruct, constraint);
    },

    getSymbolicIdentifierNameMap: function()
    {
        var identifierNamesMap = {};

        for(var i = 0; i < this.pathConstraintItems.length; i++)
        {
            ValueTypeHelper.expand(identifierNamesMap, this.pathConstraintItems[i].getSymbolicIdentifierNameMap());
        }

        return identifierNamesMap;
    },

    createCopy: function()
    {
        return this.createCopyUpgradedByIndex(0);
    },

    createSingleItemBasedOnIndex: function(pathItemIndex, newIndex)
    {
        var pathConstraintItems = [];
        var resolvedResult = null;

        var pathConstraintItem = this.pathConstraintItems[pathItemIndex];

        if(pathConstraintItem == null) { return new fcSymbolic.PathConstraint(pathConstraintItems, resolvedResult); }

        pathConstraintItems.push(pathConstraintItem.createCopyWithIndex(newIndex));

        if(this.resolvedResult[pathItemIndex] == null) { return new fcSymbolic.PathConstraint(pathConstraintItems, resolvedResult); }

        var upgradedResult = {};
        resolvedResult = {};

        for(var propName in this.resolvedResult[pathItemIndex])
        {
            upgradedResult[fcScenarioGenerator.ScenarioGenerator.updatePropertyNameWithNewIndex(propName, newIndex)] = this.resolvedResult[pathItemIndex][propName];
        }

        resolvedResult[newIndex] = upgradedResult;

        return new fcSymbolic.PathConstraint(pathConstraintItems, resolvedResult);
    },

    createCopyUpgradedByIndex: function(upgradeByIndex)
    {
        var pathConstraintItems = [];
        var resolvedResult = null;

        for(var i = 0, length = this.pathConstraintItems.length; i < length; i++)
        {
            pathConstraintItems.push(this.pathConstraintItems[i].createCopyUpgradedByIndex(upgradeByIndex));
        }

        if(!ValueTypeHelper.isEmptyObject(this.resolvedResult))
        {
            resolvedResult = {};

            for(var index in this.resolvedResult)
            {
                var result = this.resolvedResult[index];
                var upgradedResult = {};

                for(var propName in result)
                {
                    upgradedResult[fcScenarioGenerator.ScenarioGenerator.addToPropertyName(propName, upgradeByIndex)] = result[propName];
                }

                resolvedResult[parseInt(index) + upgradeByIndex] = upgradedResult;
            }
        }

        return new fcSymbolic.PathConstraint(pathConstraintItems, resolvedResult);
    },

    append: function(pathConstraint)
    {
        var itemsToAdd = pathConstraint.pathConstraintItems;

        for(var i = 0, length = itemsToAdd.length; i < length; i++)
        {
            this.pathConstraintItems.push(itemsToAdd[i]);
        }

        for(var resultIndex in pathConstraint.resolvedResult)
        {
            this.resolvedResult[resultIndex] = pathConstraint.resolvedResult[resultIndex];
        }
    },

    getAllResolvedInversions: function()
    {
        var pathConstraintItems = this.pathConstraintItems;
        var allInversions = [];

        var flipCombinations = this._generateAllFlipCombinations(pathConstraintItems);

        for(var i = pathConstraintItems.length - 1; i >= 0; i--)
        {
            var currentPathConstraintItem = pathConstraintItems[i];

            if(currentPathConstraintItem.constraint == null) { continue; }
            if(currentPathConstraintItem.constraint.isIrreversible) { continue; } //TODO NOT SURE ABOUT IT

            var modifiedConstraint = !currentPathConstraintItem.constraint.isIrreversible ? fcSymbolic.ConstraintResolver.getInverseConstraint(currentPathConstraintItem.constraint)
                                                                                          : fcSymbolic.ConstraintResolver.getStricterConstraint(currentPathConstraintItem.constraint);

            if(modifiedConstraint == null) { continue; }

            var previousItems = pathConstraintItems.slice(0, i);

            previousItems.push(new fcSymbolic.PathConstraintItem(currentPathConstraintItem.codeConstruct, modifiedConstraint));
            allInversions.push(new fcSymbolic.PathConstraint(previousItems));
        }

        fcSymbolic.PathConstraint.resolvePathConstraints(allInversions);

        return allInversions;
    },


    _generateAllFlipCombinations: function(pathConstraintItems)
    {
        var maskLength = pathConstraintItems.length;

        var mask = "";

        for(var i = 0; i < maskLength; i++) { mask += "0"; }

        var allCombinations = [];

        for(var i = maskLength - 1; i >= 0; i--)
        {
            var maskAsArray = this._convertStringToArray(mask);

            maskAsArray[i] = maskAsArray[i] == 0 ? 1 : 0;

            allCombinations.push(maskAsArray);
        }

        return allCombinations;
    },

    _convertStringToArray: function(binaryString)
    {
        var binaryArray = [];

        for(var i = 0; i < binaryString.length; i++)
        {
            binaryArray.push(parseInt(binaryString[i]));
        }

        return binaryArray;
    },

    toJSON: function()
    {
        return {
            pathConstraintItems: this.pathConstraintItems
        };
    },

    toString: function()
    {
        var string = "";

        for(var i = 0; i < this.pathConstraintItems.length; i++)
        {
            if(i != 0) { string += ", "; }

            string += this.pathConstraintItems[i].toString();
        }

        return string;
    }
};
/*****************************************************/
}});FBL.ns(function() { with (FBL) {
    /*****************************************************/
    var ValueTypeHelper = Firecrow.ValueTypeHelper;
    var fcSymbolic = Firecrow.ScenarioGenerator.Symbolic;

    fcSymbolic.SymbolicExecutor =
    {
        evalBinaryExpression: function(leftFcValue, rightFcValue, operator)
        {
            if(leftFcValue == null || rightFcValue == null) { return null;}
            if(leftFcValue.isNotSymbolic() && rightFcValue.isNotSymbolic()) { return null; }

            var leftSymbolic = leftFcValue.symbolicValue;
            var rightSymbolic = rightFcValue.symbolicValue;

            if(leftSymbolic == null && ValueTypeHelper.isPrimitive(leftFcValue.jsValue))
            {
                leftSymbolic = new fcSymbolic.Literal(leftFcValue.jsValue);
            }

            if(rightSymbolic == null && ValueTypeHelper.isPrimitive(rightFcValue.jsValue))
            {
                rightSymbolic = new fcSymbolic.Literal(rightFcValue.jsValue);
            }

            return this._simplifyExpression(new fcSymbolic.Binary(leftSymbolic, rightSymbolic, operator));
        },

        evalLogicalExpression: function(leftFcValue, rightFcValue, operator)
        {
            if((leftFcValue == null || leftFcValue.isNotSymbolic()) && (rightFcValue == null || rightFcValue.isNotSymbolic())) { return null; }

            var leftSymbolic = leftFcValue != null ? leftFcValue.symbolicValue : null;

            if(leftSymbolic == null)
            {
                if(ValueTypeHelper.isPrimitive(leftFcValue.jsValue))
                {
                    leftSymbolic = new fcSymbolic.Literal(leftFcValue.jsValue);
                }
                else
                {
                    debugger;
                    alert("The value is not literal");
                }
            }

            var rightSymbolic = rightFcValue != null ? rightFcValue.symbolicValue : null;

            if(rightFcValue == null) { return leftSymbolic; }

            if(rightSymbolic == null)
            {
                if(ValueTypeHelper.isPrimitive(rightFcValue.jsValue))
                {
                    rightSymbolic = new fcSymbolic.Literal(rightFcValue.jsValue);
                }
                else
                {
                    debugger;
                    alert("The value is not literal");
                }
            }

            return this._simplifyExpression(new fcSymbolic.Logical(leftSymbolic, rightSymbolic, operator));
        },

        evalSwitchCase: function(caseValue, switchDiscriminantValue)
        {
            if(caseValue == null || switchDiscriminantValue.symbolicValue == null) { return null; }

            var caseSymbolic = caseValue.symbolicValue;

            if(caseSymbolic == null)
            {
                if(caseValue.jsValue != null && ValueTypeHelper.isPrimitive(caseValue.jsValue))
                {
                    caseSymbolic = new fcSymbolic.Literal(caseValue.jsValue);
                }
            }

            return this._simplifyExpression(new fcSymbolic.Binary(switchDiscriminantValue.symbolicValue, caseSymbolic, "=="));
        },

        simplifyExpression: function(symbolicExpression) { return this._simplifyExpression(symbolicExpression); },

        _simplifyExpression: function(symbolicExpression)
        {
            this._simplifyOrder(symbolicExpression);

                 if (symbolicExpression.isBinary()) { return this.simplifyBinaryExpression(symbolicExpression); }
            else if (symbolicExpression.isLogical()) { return this.simplifyLogicalExpression(symbolicExpression); }

            return symbolicExpression;
        },

        simplifyBinaryExpression: function(symbolicExpression)
        {
            if(symbolicExpression.left.isBinary() && symbolicExpression.right.isLiteral())
            {
                var leftBinary = symbolicExpression.left;

                if(leftBinary.left.isIdentifier() && leftBinary.right.isLiteral())
                {
                    if(leftBinary.operator == "-" || leftBinary.operator == "+")
                    {
                        symbolicExpression.left = leftBinary.left;
                        symbolicExpression.right.value = symbolicExpression.right.value + (leftBinary.operator == "+" ? -1 * leftBinary.right.value : leftBinary.right.value);
                    }
                    else if (leftBinary.operator == "*" || leftBinary.operator == "/")
                    {
                        symbolicExpression.left = leftBinary.left;
                        symbolicExpression.right.value = leftBinary.operator == "/" ? symbolicExpression.right.value * leftBinary.right.value
                                                                                    : symbolicExpression.right.value / leftBinary.right.value;
                    }
                }
                else if(leftBinary.left.isIdentifier() && leftBinary.right.isIdentifier())
                {
                    symbolicExpression.left = leftBinary.left;
                }
            }

            return symbolicExpression;
        },

        simplifyLogicalExpression: function(symbolicExpression)
        {
            if(symbolicExpression.left.toString() == symbolicExpression.right.toString())
            {
                return symbolicExpression.left;
            }

            return symbolicExpression;
        },

        _simplifyOrder: function(symbolicExpression)
        {
            if(symbolicExpression.isBinary()) { this._simplifyOrderInBinary(symbolicExpression);}
        },

        _simplifyOrderInBinary: function(binary)
        {
            if(binary.left.isLiteral() && binary.right.isIdentifier() && binary.operator != "-" && binary.operator != "+")
            {
                var temp = binary.right;
                binary.right = binary.left;
                binary.left = temp;
                binary.operator = fcSymbolic.CONST.BINARY_OP.getSwapPositionOperator(binary.operator);
            }
        }
    };
    /*****************************************************/
}});FBL.ns(function() { with (FBL) {
/*****************************************************/
var fcSymbolic = Firecrow.ScenarioGenerator.Symbolic;
var ValueTypeHelper = Firecrow.ValueTypeHelper;
var RequestHelper = Firecrow.RequestHelper;
fcSymbolic.ConstraintResolver =
{
    _getCompoundConstraint: function(symbolicExpressions)
    {
        if(symbolicExpressions == null || symbolicExpressions.length == 0) { return null; }
        if(symbolicExpressions.length == 1) { return symbolicExpressions[0]; }

        var compoundLogicalExpression = new fcSymbolic.Logical(symbolicExpressions[0], symbolicExpressions[1], "&&");

        for(var i = 2; i < symbolicExpressions.length; i++)
        {
            compoundLogicalExpression = new fcSymbolic.Logical(compoundLogicalExpression, symbolicExpressions[i], "&&");
        }

        return compoundLogicalExpression;
    },

    resolveConstraints: function(symbolicExpressionsList)
    {
        var compoundExpressions = this._groupStringAndNumericExpressionsSeparately(symbolicExpressionsList);

        var numericExpressions = [];

        for(var i = 0; i < compoundExpressions.length; i++)
        {
            if(compoundExpressions[i].containsNumericExpressions())
            {
                numericExpressions.push(compoundExpressions[i])
            }
        }

        var stringExpressions = [];

        for(var i = 0; i < compoundExpressions.length; i++)
        {
            if(compoundExpressions[i].containsStringExpressions())
            {
                numericExpressions.push(compoundExpressions[i])
            }
        }

        var numericResults = this._resolveNumericExpressions(numericExpressions);
        var stringResults = this._resolveStringExpressions(stringExpressions);

        var results = [];

        for(var i = 0; i < compoundExpressions.length; i++)
        {
            var symbolicExpression = compoundExpressions[i];

            if(symbolicExpression.containsNumericExpressions())
            {
                results.push(numericResults[numericExpressions.indexOf(symbolicExpression)]);
            }
            else if(symbolicExpression.containsStringExpressions())
            {
                results.push(stringResults[stringExpressions.indexOf(symbolicExpression)]);
            }
            else
            {
                debugger;
                alert("Unhandled situation in ConstraintResolver");
            }
        }

        return results;
    },

    _resolveNumericExpressions: function(numericExpressions)
    {
        var numericResults = Array(numericExpressions.length);

        if(numericExpressions.length != 0)
        {
            try { var json = JSON.stringify(numericExpressions); }
            catch(e) { debugger; alert(e); }

            var numericExpressionsAjaxQuery = RequestHelper.performSynchronousPost("http://localhost/Firecrow/constraintSolver/index.php", {
                Constraint: encodeURIComponent(json)
            });

            if(numericExpressionsAjaxQuery.isSuccessful)
            {
                try
                {
                    numericResults = JSON.parse(numericExpressionsAjaxQuery.response);
                }
                catch (e)
                {
                    alert("Error when parsing constraint solver response: " + e + " -> " + numericExpressionsAjaxQuery.response);
                }
            }
            else
            {
                var expressions = "";
                numericExpressions.forEach(function(numericExpression)
                {
                    expressions += numericExpression.toString() + ";";
                });
                console.log("Expressions: " + expressions + " could not be solved");
            }
        }

        return numericResults;
    },

    _groupStringAndNumericExpressionsSeparately: function(symbolicExpressionsList)
    {
        var compoundExpressions = [];

        for(var i = 0; i < symbolicExpressionsList.length; i++)
        {
            var symbolicExpressions = symbolicExpressionsList[i];

            var numericExpressions = [], stringExpressions = [];

            for(var j = 0; j < symbolicExpressions.length; j++)
            {
                var symbolicExpression = symbolicExpressions[j];

                var containsNumericExpressions = symbolicExpression.containsNumericExpressions();
                var containsStringExpressions = symbolicExpression.containsStringExpressions();

                if(symbolicExpression.isIdentifier())
                {
                    numericExpressions.push(new fcSymbolic.Binary(symbolicExpression, new fcSymbolic.Literal(0), ">="));
                }
                else if((containsNumericExpressions && !containsStringExpressions)
                 || symbolicExpression.hasOnlyIdentifiers())
                {
                    numericExpressions.push(symbolicExpression);
                }
                else if(containsStringExpressions && !containsNumericExpressions)
                {
                    stringExpressions.push(symbolicExpression);
                }
                else if(!containsStringExpressions && !containsNumericExpressions)
                {
                    console.log("Can not resolve: " + symbolicExpression);
                }
                else
                {
                    debugger;
                    alert("Mixing String and Numeric expressions not yet handled in ConstraintResolver");
                    return;
                }
            }

            if(numericExpressions.length != 0) { compoundExpressions.push(this._getCompoundConstraint(numericExpressions)); }
            if(stringExpressions.length != 0) { compoundExpressions.push(this._getCompoundConstraint(stringExpressions)); }
        }

        return compoundExpressions;
    },

    _resolveStringExpressions: function(stringExpressions)
    {
        if(stringExpressions.length == 0) { return []; }

        var replacements = [];
        var reverseReplacements = [];
        var numberExpressions = [];

        for(var i = 0; i < stringExpressions.length; i++)
        {
            var stringExpression = stringExpressions[i];

            var stringLiterals = ValueTypeHelper.cleanDuplicatesFromArray(stringExpression.getStringLiterals());
            var replacement = {};
            var reverseReplacement = {};
            for(var j = 0; j < stringLiterals.length; j++)
            {
                replacement[stringLiterals[j]] = j;
                reverseReplacement[j] = stringLiterals[j];
            }

            replacements.push(replacement);
            reverseReplacements.push(reverseReplacement);

            numberExpressions.push(stringExpression.createCopyWithReplacedLiterals(replacement));
        }

        var results = this._resolveNumericExpressions(numberExpressions);

        for(var i = 0; i < results.length; i++)
        {
            var reverseReplacement = reverseReplacements[i];
            var result = results[i];
            for(var propName in result)
            {
                var numberResult = result[propName];
                result[propName] = reverseReplacement[numberResult];
            }
        }

        return results;
    },

    updateSelectElement: function(propName, selectElement, newValue)
    {
        var oldValue = selectElement[propName];

        selectElement[propName] = newValue;

        return {htmlElement: selectElement, oldValue: oldValue, newValue: newValue};
    },

    getHtmlElementIdFromSymbolicParameter: function(parameter)
    {
        //format: DOM_PROPERTY_NAME_FC_EVENT_INDEX_ID_XX_CLASS_ -> from HtmlElement class
        var startIdIndex = parameter.indexOf("_ID_");
        if(startIdIndex == -1) { return ""; }

        var startClassIndex = parameter.indexOf("_CLASS_");
        if(startClassIndex == -1) { startClassIndex = parameter.length; }

        return parameter.substring(startIdIndex + "_ID_".length, startClassIndex);
    },

    getHtmlElementPropertyFromSymbolicParameter: function(parameter)
    {
        var startDomIndex = parameter.indexOf("DOM_");

        var startPropertyNameIndex = 0;

        if(startDomIndex == 0)
        {
            startPropertyNameIndex = "DOM_".length;
        }

        var startFcIndex = parameter.indexOf("_FC_");
        var endPropertyIndex = parameter.length;

        if(startFcIndex != -1)
        {
            endPropertyIndex = startFcIndex;
        }

        return parameter.substring(startPropertyNameIndex, endPropertyIndex);
    },

    _getNextValue: function(item, items)
    {
        return items[items.indexOf(item) + 1];
    },

    _isStringLiteralBinaryExpression: function(symbolicExpression)
    {
        return symbolicExpression.isBinary() && symbolicExpression.left.isIdentifier() && symbolicExpression.right.isLiteral()
            && ValueTypeHelper.isString(symbolicExpression.right.value);
    },

    getInverseConstraint: function(symbolicExpression)
    {
        if(symbolicExpression == null) { return null; }

        if(symbolicExpression.isBinary()) { return this._getBinaryInverse(symbolicExpression); }
        else if(symbolicExpression.isLogical()) { return this._getLogicalInverse(symbolicExpression); }
        else if (symbolicExpression.isLiteral() || symbolicExpression.isIdentifier()) { return null; }
        else
        {
            debugger;
            alert("Unhandled constraint");
        }

        return null;
    },

    getStricterConstraint: function(symbolicExpression)
    {
        if(symbolicExpression == null) { return null; }

        if(symbolicExpression.isBinary()) { return this._getBinaryStricter(symbolicExpression); }

        return symbolicExpression;
    },

    _getBinaryStricter: function(symbolicExpression)
    {
        if(symbolicExpression.operator == ">=" || symbolicExpression.operator == "<=")
        {
            return new fcSymbolic.Binary
            (
                symbolicExpression.left,
                symbolicExpression.right,
                symbolicExpression.operator == ">=" ? ">" : "<"
            );
        }
        else if (symbolicExpression.operator == ">" && symbolicExpression.right.isLiteral())
        {
            return new fcSymbolic.Binary
            (
                symbolicExpression.left,
                new fcSymbolic.Literal(symbolicExpression.right.value + 1),
                ">="
            );
        }
        else if (symbolicExpression.operator == "<" && symbolicExpression.right.isLiteral())
        {
            return new fcSymbolic.Binary
            (
                symbolicExpression.left,
                new fcSymbolic.Literal(symbolicExpression.right.value - 1),
                "<="
            );
        }

        return symbolicExpression;
    },


    _getLogicalInverse: function(symbolicExpression)
    {
        //DEMORGAN'S LAW: !(A && B) = !A || !B; !(A || B) = !A && !B

        var leftInverse = this.getInverseConstraint(symbolicExpression.left);
        var rightInverse = this.getInverseConstraint(symbolicExpression.right);

        if(leftInverse != null && rightInverse != null) { return new fcSymbolic.Logical(leftInverse, rightInverse, symbolicExpression.operator == "&&" ? "||" : "&&"); }

        return leftInverse || rightInverse;
    },

    _getBinaryInverse: function(symbolicExpression)
    {
        return new fcSymbolic.Binary
        (
            symbolicExpression.left,
            symbolicExpression.right,
            fcSymbolic.CONST.BINARY_OP.getInverse(symbolicExpression.operator)
        );
    }
};

fcSymbolic.ConstraintResult = function(identifier, value, htmlElement)
{
    this.identifier = identifier;
    this.value = value;
    this.htmlElement = htmlElement;

    this.getValue = function() { return this.value;};
};
/*****************************************************/
}});/**
 * User: Jomaras
 * Date: 26.09.12.
 * Time: 17:24
 */
FBL.ns(function() { with (FBL) {
/*************************************************************************************/
Firecrow.DependencyGraph.DependencyHighlighter = function(htmlContainer, dependencyGraph)
{
    (function establishConnection()
    {
        var nodes = dependencyGraph.nodes;

        for(var i = 0, length = nodes.length; i < length; i++)
        {
            var node = nodes[i];

            var htmlNode = htmlContainer.querySelector("#node" + FBL.Firecrow.CodeMarkupGenerator.formatId(node.model.nodeId));

            if(htmlNode != null)
            {
                htmlNode.model = node.model;
            }
        }
    }());

    function removeClass(className)
    {
        var elements = htmlContainer.querySelectorAll("." + className);

        for(var i = 0; i < elements.length; i++)
        {
            elements[i].classList.remove(className);
        }
    }

    var codeElements = htmlContainer.querySelectorAll(".node");

    for(var i = 0, length = codeElements.length; i < length; i++)
    {
        codeElements[i].onclick = function(eventArgs)
        {
            if(this.id.indexOf("node") == 0)
            {
                eventArgs.stopPropagation();

                removeClass("selected");
                removeClass("dependent");

                this.classList.add("selected");

                var modelNode = this.model;

                if(modelNode == null) { return; }

                var dependencies = modelNode.graphNode.dataDependencies;
                for(var j = 0, jLength = dependencies.length; j < jLength; j++)
                {
                    var dependent = dependencies[j];
                    var htmlDependent = htmlContainer.querySelector("#node" + FBL.Firecrow.CodeMarkupGenerator.formatId(dependent.destinationNode.model.nodeId));
                    if(htmlDependent != null)
                    {
                        htmlDependent.classList.add("dependent");
                    }
                }
            }
        }
    }
};
}});FBL.ns(function() { with (FBL) {
/*************************************************************************************/
    var ValueTypeHelper = Firecrow.ValueTypeHelper;
    var ASTHelper = Firecrow.ASTHelper;
    var fcGraph = Firecrow.DependencyGraph;

    fcGraph.Node = function(model, type, isDynamic)
    {
        this.model = model;
        this.type = type;
        this.isDynamic = !!isDynamic;

        this.structuralDependencies = [];
        this.dataDependencies = [];
        this.reverseDependencies = [];
        this.controlDependencies = [];

        this.model.graphNode = this;
        this.idString = this.generateId();

        this.idNum = fcGraph.Node.LAST_ID++;
    };

    fcGraph.Node.notifyError = function(message) { alert("Node - " + message); }
    fcGraph.Node.LAST_ID = 0;

    fcGraph.Node.createHtmlNode = function(model, isDynamic) { return new Node(model, "html", isDynamic); };
    fcGraph.Node.createCssNode = function(model, isDynamic) { return new Node(model, "css", isDynamic); };
    fcGraph.Node.createJsNode = function(model, isDynamic) { return new Node(model, "js", isDynamic);};
    fcGraph.Node.createResourceNode = function(model, isDynamic) { return new Node(model, "resource", isDynamic);};

    fcGraph.Node.prototype =
    {
        isNodeOfType: function(type) { return this.type === type; },
        isHtmlNode: function() { return this.isNodeOfType("html"); },
        isCssNode: function() { return this.isNodeOfType("css"); },
        isJsNode: function() { return this.isNodeOfType("js"); },
        isResourceNode: function() { return this.isNodeOfType("resource"); },

        getSimplified: function()
        {
            //if(this.model.nodeId == 378) debugger;
            return {
                modelId : this.model != null ? this.model.nodeId : -1,
                type: this.type,
                isDynamic: this.isDynamic ? 1 : undefined,
                dataDependencies: this._getSimplifiedDependencies(this.dataDependencies),
                reverseDependencies: this._getSimplifiedDependencies(this.reverseDependencies)
            };
        },

        _getSimplifiedDependencies: function(dependencies, isReverseDependencies)
        {
            var simplifiedDependencies = [];
            var simplifiedDependenciesMap = {};

            for(var i = 0; i < dependencies.length; i++)
            {
                var dependency = dependencies[i];

                if(!dependency.isValueDependency) { continue; }

                var edgeSignature = dependency.getEdgeSignature();

                if(!simplifiedDependenciesMap[edgeSignature])
                {
                    simplifiedDependencies.push(dependency.getSimplified());
                    simplifiedDependenciesMap[edgeSignature] = true;
                }
            }

            return simplifiedDependencies;
        },

        addStructuralDependency: function(destinationNode, isDynamic)
        {
            var edge = new fcGraph.Edge(this, destinationNode, isDynamic);

            this.structuralDependencies.push(edge);

            return edge;
        },

        addDataDependency: function(destinationNode, isDynamic, index, dependencyCreationInfo, destinationNodeDependencyInfo, shouldNotFollowDependency)
        {
            var edge = new fcGraph.Edge(this, destinationNode, isDynamic, index, dependencyCreationInfo, destinationNodeDependencyInfo, shouldNotFollowDependency);

            this.dataDependencies.push(edge);

            if(destinationNode != null)
            {
                destinationNode.reverseDependencies.push(edge);
            }

            this.lastDependency = edge;

            return edge;
        },

        addControlDependency: function(destinationNode, isDynamic, index, dependencyCreationInfo, destinationNodeDependencyInfo, shouldNotFollowDependency, isPreviouslyExecutedBlockStatementDependency)
        {
            var edge = new Firecrow.DependencyGraph.Edge(this, destinationNode, isDynamic, index, dependencyCreationInfo, destinationNodeDependencyInfo, shouldNotFollowDependency);

            edge.isPreviouslyExecutedBlockStatementDependency = isPreviouslyExecutedBlockStatementDependency;

            this.dataDependencies.push(edge);

            if(destinationNode != null)
            {
                destinationNode.reverseDependencies.push(edge);
            }

            this.lastDependency = edge;

            return edge;
        },

        getDependencies: function(maxIndex, destinationConstraint)
        {
            var selectedDependencies = [];

            if(maxIndex == null && destinationConstraint == null) { return this.dataDependencies; }

            var dependencies = this.dataDependencies;

            for(var i = dependencies.length - 1; i >= 0; i--)
            {
                var dependency = dependencies[i];

                if((dependency.isReturnDependency  || dependency.isBreakReturnDependency) && dependency.callDependencyMaxIndex <= maxIndex)
                {
                    selectedDependencies.push(dependency);
                }

                if(dependency.shouldAlwaysBeFollowed)
                {
                    selectedDependencies.push(dependency);
                }

                if(dependency.index > maxIndex) { continue; }
                if(!this.canFollowDependency(dependency, destinationConstraint)) { continue; }

                selectedDependencies.push(dependency);

                for(var j = i + 1; j < dependencies.length; j++)
                {
                    if(!this._areDependenciesInTheSameGroupAndCanBeFollowed(dependency, dependencies[j], destinationConstraint))
                    {
                        break;
                    }

                    selectedDependencies.push(dependencies[j]);
                }

                for(var j = i - 1; j >= 0; j--)
                {
                    if(!this._areDependenciesInTheSameGroupAndCanBeFollowed(dependency, dependencies[j], destinationConstraint))
                    {
                        break;
                    }

                    selectedDependencies.push(dependencies[j]);
                }

                break;
            }

            return selectedDependencies;
        },

        getUntraversedValueDependenciesFromContext:function(executionContextId)
        {
            var dependencies = this.dataDependencies;
            var selectedDependencies = [];

            for(var i = 0; i < dependencies.length; i++)
            {
                var dependency = dependencies[i];
                if(dependency.isValueDependency && !dependency.hasBeenTraversed && dependency.executionContextId == executionContextId)
                {
                    selectedDependencies.push(dependency);
                }
            }

            return selectedDependencies;
        },

        _areDependenciesInTheSameGroupAndCanBeFollowed: function(dependency1, dependency2, destinationConstraint)
        {
            return (dependency1.dependencyCreationInfo.groupId.indexOf(dependency2.dependencyCreationInfo.groupId) == 0
                 || dependency2.dependencyCreationInfo.groupId.indexOf(dependency1.dependencyCreationInfo.groupId) == 0)
                && this.canFollowDependency(dependency2, destinationConstraint);
        },

        canFollowDependency: function(dependency, destinationConstraint)
        {
            if(destinationConstraint == null) { return true; }

            return dependency.dependencyCreationInfo.currentCommandId <= destinationConstraint.currentCommandId;
        },

        generateId: function()
        {
            if(this.isHtmlNode()) { return this._generateIdForHtmlNode(); }
            else if (this.isCssNode()) { return this._generateIdForCssNode(); }
            else if (this.isJsNode()) { return this._generateIdForJsNode(); }
            else { debugger; alert("Node.generateId - unknown node type!"); return ""; }
        },

        _generateIdForHtmlNode: function()
        {
            if(!this.isHtmlNode()) { return this.generateId(); }

            return this.idNum + ":" +  this.model.type;
        },

        _generateIdForCssNode: function()
        {
                if(!this.isCssNode()) { return this.generateId(); }

                return this.idNum + ":" + this.model.selector;
        },

        _generateIdForJsNode: function()
        {
            if(!this.isJsNode()) { return this.generateId(); }

            var additionalData = "";

            if(this.model.type == "Identifier") { additionalData = "->" + this.model.name; }
            else if (this.model.type == "Literal") { additionalData = "->" + this.model.value;}

            return this.idNum + ":@" + (this.model.loc != null ? this.model.loc.start.line : '?' )+  "-" + this.model.type + additionalData;
        }
    };
}});FBL.ns(function() { with (FBL) {
/*************************************************************************************/

var ValueTypeHelper = Firecrow.ValueTypeHelper;

Firecrow.DependencyGraph.Edge = function(sourceNode, destinationNode, isDynamic, index, dependencyCreationInfo, destinationNodeDependencyConstraints, shouldNotFollowDependency)
{
    if(!ValueTypeHelper.isOfType(sourceNode, Firecrow.DependencyGraph.Node)
    || !ValueTypeHelper.isOfType(destinationNode, Firecrow.DependencyGraph.Node))
    {
        debugger;
        Firecrow.DependencyGraph.Edge.notifyError("DependencyGraph.Edge: Source or destination node are not of type node!");
        return;
    }

    this.sourceNode = sourceNode;
    this.destinationNode = destinationNode;
    this.isDynamic = !!isDynamic;
    this.index = index; //if(index == 14)debugger;

    this.dependencyCreationInfo = dependencyCreationInfo;
    this.destinationNodeDependencyConstraints = destinationNodeDependencyConstraints || dependencyCreationInfo;
    this.shouldNotFollowDependency = shouldNotFollowDependency;

    if(dependencyCreationInfo == null) { return; }

    this.isReturnDependency = dependencyCreationInfo.isReturnDependency;
    this.isBreakReturnDependency = dependencyCreationInfo.isBreakReturnDependency;
    this.shouldAlwaysBeFollowed = dependencyCreationInfo.shouldAlwaysBeFollowed;

    if(this.isReturnDependency)
    {
        this.callDependencyMaxIndex = dependencyCreationInfo.callDependencyMaxIndex || index;
    }

/*    if(sourceNode.model.nodeId == 14)
    {
        console.log(sourceNode.model.nodeId + " index: " + this.index +  "; depCreationInfoId: " + dependencyCreationInfo.groupId + "; depCommand: " + dependencyCreationInfo.currentCommandId
                 +  " destinationGroupId: " + this.destinationNodeDependencyConstraints.groupId + "; destDepCommand: " + this.destinationNodeDependencyConstraints.currentCommandId
                 + " " + Firecrow.CodeTextGenerator.generateJsCode(this.destinationNode.model));
    }*/

     /*var sourceStartLine = sourceNode.model.loc != null ? sourceNode.model.loc.start.line : sourceNode.model.parent.loc.start.line;
     var sourceCode = Firecrow.CodeTextGenerator.generateJsCode(sourceNode.model);

     var destinationStartLine = destinationNode.model.loc != null ? destinationNode.model.loc.start.line : destinationNode.model.parent.loc.start.line;
     var destinationCode = Firecrow.CodeTextGenerator.generateJsCode(destinationNode.model);

     var location = sourceStartLine + "[" + sourceNode.model.nodeId + "]" + ":" + sourceCode + "=>" + destinationStartLine + "[" + destinationNode.model.nodeId + "]" + ":" + destinationCode

     var dependencyInfo = dependencyCreationInfo.groupId + "->" + dependencyCreationInfo.currentCommandId;
     var additionalInfo = destinationNodeDependencyConstraints == null ? "N" : destinationNodeDependencyConstraints.groupId + "->" + destinationNodeDependencyConstraints.currentCommandId;
     console.log(location.replace(/\n/," ") + "; index:" + index + "; " + "; info: " + dependencyInfo + "; aInfo: " + additionalInfo);*/
};

Firecrow.DependencyGraph.Edge.prototype.getEdgeSignature = function()
{
    var sourceSignature = this.sourceNode.model != null ? this.sourceNode.model.nodeId : -1;
    var destinationSignature = this.destinationNode.model != null ? this.destinationNode.model.nodeId : -1;

    return sourceSignature + "-" + destinationSignature;
};

Firecrow.DependencyGraph.Edge.prototype.getSimplified = function()
{
    return {
        sourceNodeId: this.sourceNode.model != null ? this.sourceNode.model.nodeId : -1,
        destinationNodeId: this.destinationNode.model != null ? this.destinationNode.model.nodeId : -1
    };
};

Firecrow.DependencyGraph.Edge.notifyError = function(message) { alert("Edge - " + message); }
/*************************************************************************************/
}});FBL.ns(function() { with (FBL) {
    /*************************************************************************************/
    var ValueTypeHelper = Firecrow.ValueTypeHelper;
    var ASTHelper = Firecrow.ASTHelper;
    var Node = Firecrow.DependencyGraph.Node;

    var fcGraph = Firecrow.DependencyGraph;

    fcGraph.DependencyGraph = function()
    {
        this.nodes = [];

        this.htmlNodes = [];
        this.cssNodes = [];
        this.jsNodes = [];
        this.dynamicNodes = [];

        this.controlFlow = [];
        this.importantConstructDependencyIndexMapping = [];
        this.controlDependencies = [];
        this.breakContinueReturnEventsMapping = [];

        this.dependencyEdgesCounter = 0;
        this.inclusionFinder = new Firecrow.DependencyGraph.InclusionFinder();

        this.dependencyCallExpressionMapping = {};

        this.currentCallExpressions = [];
        this.currentCallExpressionsHardCopy = [];

        this.executionContextIndexMap = {};
        this.executionContextIdStack = [];
        this.pushExecutionContextId("root");
        this.traversedEdgesMap = {};
        this.expressionTrace = [];
    };

    var DependencyGraph = Firecrow.DependencyGraph.DependencyGraph;
    var dummy;

    DependencyGraph.notifyError = function(message) { alert("DependencyGraph - " + message); };
    DependencyGraph.log = [];
    DependencyGraph.shouldLog = false;
    DependencyGraph.sliceUnions = true;
    DependencyGraph.noOfSlicingCriteria = 0;
    DependencyGraph.sliceUnionProblematicExpressions = [];

    DependencyGraph.prototype = dummy =
    {
        getSimplified: function()
        {
            var simplifiedDependencyGraph = { htmlNodes:[], cssNodes:[], jsNodes:[] };

            for(var i = 0; i < this.htmlNodes.length; i++)
            {
                simplifiedDependencyGraph.htmlNodes.push(this.htmlNodes[i].getSimplified());
            }

            for(var i = 0; i < this.cssNodes.length; i++)
            {
                simplifiedDependencyGraph.cssNodes.push(this.cssNodes[i].getSimplified());
            }

            for(var i = 0; i < this.jsNodes.length; i++)
            {
                simplifiedDependencyGraph.jsNodes.push(this.jsNodes[i].getSimplified());
            }

            return simplifiedDependencyGraph;
        },

        addNode: function(node)
        {
            if(!ValueTypeHelper.isOfType(node, Node)) { this.notifyError("Node is not of type DependencyGraph.Node!"); return; }

            this.nodes.push(node);

                 if (node.type == "html") { this.htmlNodes.push(node); }
            else if (node.type == "css") { this.cssNodes.push(node); }
            else if (node.type == "js") { this.jsNodes.push(node); }
        },

        pushExecutionContextId: function(executionContextId)
        {
            this.executionContextId = executionContextId;
            this.executionContextIdStack.push(executionContextId);

            if(this.executionContextIndexMap[this.executionContextId] == null) { this.executionContextIndexMap[this.executionContextId] = []; }
        },

        popExecutionContextId: function()
        {
            this.executionContextIdStack.pop();
            this.executionContextId = this.executionContextIdStack[this.executionContextIdStack.length-1];
        },

        handleExpressionEvaluated: function(codeConstruct)
        {
            this.expressionTrace.push
            ({
                codeConstruct: codeConstruct,
                dependencyIndex: codeConstruct.maxCreatedDependencyIndex,
                executionContextId: this.executionContextId
            });
        },

        handleNodeCreated: function(nodeModelObject, type, isDynamic)
        {
            this.addNode(new Node(nodeModelObject, type, isDynamic));
        },

        handleNodeInserted: function(nodeModelObject, parentNodeModelObject, isDynamic)
        {
            if(nodeModelObject == null) { this.notifyError("nodeModelObject must not be null!"); return; }

            if(parentNodeModelObject != null)
            {
                nodeModelObject.graphNode.addStructuralDependency(parentNodeModelObject.graphNode, isDynamic);
            }
        },

        handleDataDependencyEstablished: function(sourceNodeModelObject, targetNodeModelObject, dependencyCreationInfo, destinationNodeDependencyInfo, shouldNotFollowDependency, isValueDependency)
        {
            if(sourceNodeModelObject == null || targetNodeModelObject == null) { return; }

            if(ValueTypeHelper.isArray(targetNodeModelObject))
            {
                for(var i = 0; i < targetNodeModelObject.length; i++)
                {
                    var edge = sourceNodeModelObject.graphNode.addDataDependency(targetNodeModelObject[i].graphNode, true, this.dependencyEdgesCounter++, dependencyCreationInfo, destinationNodeDependencyInfo, shouldNotFollowDependency);
                    edge.isValueDependency = isValueDependency;
                    sourceNodeModelObject.maxCreatedDependencyIndex = edge.index;

                    if(DependencyGraph.sliceUnions) {  this._registerDependencyCallExpressionRelationship(edge); }

                    this.executionContextIndexMap[this.executionContextId].push(edge.index);
                    edge.executionContextId = this.executionContextId;
                }
            }
            else
            {
                var edge = sourceNodeModelObject.graphNode.addDataDependency(targetNodeModelObject.graphNode, true, this.dependencyEdgesCounter++, dependencyCreationInfo, destinationNodeDependencyInfo, shouldNotFollowDependency);
                edge.isValueDependency = isValueDependency;
                sourceNodeModelObject.maxCreatedDependencyIndex = edge.index;

                if(DependencyGraph.sliceUnions) {  this._registerDependencyCallExpressionRelationship(edge); }

                this.executionContextIndexMap[this.executionContextId].push(edge.index);
                edge.executionContextId = this.executionContextId;
            }
        },

        handleControlDependencyEstablished: function(sourceNodeModelObject, targetNodeModelObject, dependencyCreationInfo, destinationNodeDependencyInfo, isPreviouslyExecutedBlockStatementDependency)
        {
            if(sourceNodeModelObject == null || targetNodeModelObject == null) { return; }

            if(dependencyCreationInfo != null && dependencyCreationInfo.isReturnDependency)
            {
                var enterFunctionPoints = sourceNodeModelObject.graphNode.enterFunctionPoints;
                if(enterFunctionPoints != null)
                {
                    dependencyCreationInfo.callDependencyMaxIndex = enterFunctionPoints[enterFunctionPoints.length - 1].lastDependencyIndex;
                }
            }

            var edge = sourceNodeModelObject.graphNode.addControlDependency
            (
                targetNodeModelObject.graphNode,
                true,
                this.dependencyEdgesCounter++,
                dependencyCreationInfo,
                destinationNodeDependencyInfo,
                false,
                isPreviouslyExecutedBlockStatementDependency
            );
            sourceNodeModelObject.maxCreatedDependencyIndex = edge.index;

            this._registerDependencyCallExpressionRelationship(edge);

            this.executionContextIndexMap[this.executionContextId].push(edge.index);
            edge.executionContextId = this.executionContextId;
        },

        _registerDependencyCallExpressionRelationship: function(edge)
        {
            this.dependencyCallExpressionMapping[edge.index] = this.currentCallExpressionsHardCopy;
        },

        handleCallbackCalled: function(callbackConstruct, callCallbackConstruct, evaluationPosition)
        {
            if(this.callbackExecutionMap[callbackConstruct.nodeId] == null)
            {
                this.callbackExecutionMap[callbackConstruct.nodeId] =
                {
                    callbackConstruct: callbackConstruct,
                    callCallbackMap: {}
                }
            }

            if(this.callbackExecutionMap[callbackConstruct.nodeId].callCallbackMap[callCallbackConstruct.nodeId] == null)
            {
                this.callbackExecutionMap[callbackConstruct.nodeId].callCallbackMap[callCallbackConstruct.nodeId] =
                {
                    callCallbackConstruct: callCallbackConstruct,
                    evaluationPositions: []
                };
            }

            this.callbackExecutionMap[callbackConstruct.nodeId].callCallbackMap[callCallbackConstruct.nodeId].evaluationPositions.push(evaluationPosition);
        },

        callbackExecutionMap: {},

        handleControlFlowConnection: function(sourceNode)
        {
            //sourceNode.hasBeenExecuted = true;
        },

        handleImportantConstructReached: function(sourceNode)
        {
            var dataDependencies = sourceNode.graphNode.dataDependencies;
            this.importantConstructDependencyIndexMapping.push
            ({
                codeConstruct: sourceNode,
                dependencyIndex: dataDependencies.length > 0 ? dataDependencies[dataDependencies.length - 1].index : -1
            });
        },

        handleBreakContinueReturnEventReached: function(sourceNode,  evaluationPosition, isCallbackReturn)
        {
            var dataDependencies = sourceNode.graphNode.dataDependencies;
            this.breakContinueReturnEventsMapping.push
            ({
                codeConstruct: sourceNode,
                dependencyIndex: dataDependencies.length > 0 ? dataDependencies[dataDependencies.length - 1].index : -1,
                executionContextId: this.executionContextId,
                isCallbackReturn: isCallbackReturn
            });
        },

        //This is so that i know which callback executions are related
        //in the map i will keep track of all execution context id's
        //for the executed callback functions
        _callbackStartStopTrackingMap: {},
        _currentCallbackStartStopExecutionIdStack: [],

        handleCallbackStartedExecuting: function(functionConstruct)
        {
            /*if(functionConstruct == null) { return; }

             if(this._callbackStartStopTrackingMap[functionConstruct.nodeId] == null) { this._callbackStartStopTrackingMap[functionConstruct.nodeId] = []; }

             this._currentCallbackStartStopExecutionIdStack.push([]);*/
        },

        handleCallbackStoppedExecuting: function(functionConstruct)
        {
            //debugger;
        },

        handleEnterFunction: function(callExpression, functionConstruct, executionContextId)
        {
            if(callExpression == null) return;

            this.currentCallExpressions.push(callExpression);
            this.currentCallExpressionsHardCopy = this.currentCallExpressions.slice();

            this.pushExecutionContextId(executionContextId);
        },

        handleExitFunction: function()
        {
            this.currentCallExpressions.pop();
            this.currentCallExpressionsHardCopy = this.currentCallExpressions.slice();
            this.popExecutionContextId();
        },

        markGraph: function(model)
        {
            try
            {
                this.previouslyExecutedBlockDependencies = [];
                this.traversedEdgesMap = {};

                this._traverseImportantDependencies(this.importantConstructDependencyIndexMapping);
                this._traverseHtmlNodeDependencies(this.htmlNodes);

                var addedDependencies = this._traverseIndirectDependencies();

                while(addedDependencies != 0)
                {
                    addedDependencies = this._traverseIndirectDependencies();
                }

                Firecrow.DependencyGraph.DependencyPostprocessor.processHtmlElement(model);
            }
            catch(e)
            {
                debugger;
                this.notifyError("Error when marking graph: " + e);
            }
        },

        _traverseIndirectDependencies: function()
        {
            var addedDependencies = 0;

            addedDependencies += this._traverseExecutedBlockDependencies();
            addedDependencies += this._traverseBreakContinueReturnEventsDependencies();

            if(fcGraph.DependencyGraph.sliceUnions)
            {
                addedDependencies += this._traverseSliceUnionPossibleProblems(this.expressionTrace);
            }

            return addedDependencies
        },

        _traverseImportantDependencies: function(executionTrace)
        {
            for(var i = 0, length = executionTrace.length; i < length; i++)
            {
                var mapping = executionTrace[i];

                DependencyGraph.noOfSlicingCriteria++;
                this._mainTraverseAndMark(mapping.codeConstruct, mapping.dependencyIndex, null, null);
            }
        },

        _traverseHtmlNodeDependencies: function(htmlNodes)
        {
            for(var i = 0, length = htmlNodes.length; i < length; i++)
            {
                var htmlModelNode = htmlNodes[i].model;

                if(!htmlModelNode.shouldBeIncluded) { continue; }

                DependencyGraph.noOfSlicingCriteria++;
                this._mainTraverseAndMark(htmlModelNode);
                this._markParentCssDependencies(htmlModelNode.domElement);
            }
        },

        _markParentCssDependencies: function(htmlDomNode)
        {
            if(htmlDomNode == null || htmlDomNode.parentNode == null
                || htmlDomNode.parentNode.modelElement == null || htmlDomNode.parentNode.modelElement.graphNode == null) { return; }

            var parentModelElement = htmlDomNode.parentNode.modelElement;
            var dependencies = parentModelElement.graphNode.dataDependencies;

            for(var i = 0; i < dependencies.length; i++)
            {
                var dependency = dependencies[i];

                if(dependency.destinationNode.type == "css")
                {
                    Firecrow.includeNode(dependency.destinationNode.model);
                }
            }

            this._markParentCssDependencies(parentModelElement.domElement);
        },

        _traverseExecutedBlockDependencies: function()
        {
            var addedDependencies = 0;

            for(var i = 0, length = this.previouslyExecutedBlockDependencies.length; i < length; i++)
            {
                var blockDependency = this.previouslyExecutedBlockDependencies[i];
                //Because the dependency is added to the condition, and here, we want to traverse it
                //only if some of at least one sub-expression is already included in the previous phases
                if(this.inclusionFinder.isIncludedElement(blockDependency.codeConstruct.parent))
                {
                    addedDependencies += this._mainTraverseAndMark(blockDependency.codeConstruct, blockDependency.maxDependencyIndex, blockDependency.dependencyConstraint, blockDependency.includedByNode);
                }
            }

            return addedDependencies;
        },

        _traverseBreakContinueReturnEventsDependencies: function()
        {
            var addedDependencies = 0;

            for(var i = 0; i < this.breakContinueReturnEventsMapping.length; i++)
            {
                var mapping = this.breakContinueReturnEventsMapping[i];
                var codeConstruct = mapping.codeConstruct;

                if(codeConstruct.shouldBeIncluded) { continue; }

                var parent = ASTHelper.getBreakContinueReturnImportantAncestor(codeConstruct);

                if(!this.inclusionFinder.isIncludedElement(parent)) { continue; }

                if(this._areAllIncluded(this.dependencyCallExpressionMapping[mapping.dependencyIndex]) || this._contextHasIncludedDependencies(mapping.executionContextId))
                {
                    addedDependencies += this._mainTraverseAndMark(codeConstruct, mapping.dependencyIndex, null);
                    ValueTypeHelper.removeFromArrayByIndex(this.breakContinueReturnEventsMapping, i--);
                }
            }

            return addedDependencies;
        },

        _traverseSliceUnionPossibleProblems: function(trace)
        {
            var addedDependencies = 0;

            if(trace == null) { return addedDependencies; }

            for(var i = 0; i < trace.length; i++)
            {
                var traceItem = trace[i];

                if(traceItem == null) { continue; }

                var codeConstruct = traceItem.codeConstruct;
                //if(codeConstruct.nodeId == 99164) debugger;
                //if(codeConstruct.loc != null && codeConstruct.loc.start.line == 4791) debugger;
                if(!codeConstruct.shouldBeIncluded || !this._contextHasIncludedDependencies(traceItem.executionContextId)) { continue; }
                var dependencies = codeConstruct.graphNode.getUntraversedValueDependenciesFromContext(traceItem.executionContextId);

                addedDependencies += dependencies.length;
                if(dependencies.length != 0) { DependencyGraph.sliceUnionProblematicExpressions.push({traceItem: traceItem, dependencies: dependencies});}
                for(var j = 0; j < dependencies.length; j++)
                {
                    var dependency = dependencies[j];

                    dependency.hasBeenTraversed = true;

                    this._traverseAndMark(dependency.destinationNode.model, dependency.index);
                }

                trace[i] = null;//not important anymore, but slice is too slow to remove it
            }

            return addedDependencies;
        },

        _contextIncludedDependencyCache: {},

        _contextHasIncludedDependencies: function(referentExecutionContextId)
        {
            if(this._contextIncludedDependencyCache[referentExecutionContextId]) { return true; }

            var hasIncludedDependencies = this._isAtLeastOneDependencyTraversed(this.executionContextIndexMap[referentExecutionContextId]);

            if(hasIncludedDependencies)
            {
                this._contextIncludedDependencyCache[referentExecutionContextId] = true;
            }

            return hasIncludedDependencies;
        },

        _isAtLeastOneDependencyTraversed: function(dependencyIndexes)
        {
            for(var i = 0; i < dependencyIndexes.length; i++)
            {
                if(this.traversedEdgesMap[dependencyIndexes[i]]) { return true; }
            }

            return false;
        },

        _areAllIncluded: function(callExpressions)
        {
            if(callExpressions == null || callExpressions.length == 0) { return false; }
            if(callExpressions.areAllIncluded) { return true; }

            for(var i = 0; i < callExpressions.length; i++)
            {
                if(!callExpressions[i].shouldBeIncluded) { return false; }
            }

            callExpressions.areAllIncluded = true;

            return true;
        },

        _includedMemberCallExpressionMap: {},

        _mainTraverseAndMark: function(codeConstruct, maxDependencyIndex, dependencyConstraint)
        {
            return this._traverseAndMark(codeConstruct, maxDependencyIndex, dependencyConstraint, 0);
        },

        _traverseAndMark: function(codeConstruct, maxDependencyIndex, dependencyConstraint, addedDependencies)
        {
            Firecrow.includeNode(codeConstruct, false, maxDependencyIndex, dependencyConstraint);

            if((ASTHelper.isMemberExpression(codeConstruct) || ASTHelper.isMemberExpression(codeConstruct.parent)
             || ASTHelper.isCallExpression(codeConstruct) || ASTHelper.isCallExpressionCallee(codeConstruct)))
            {
                this._includedMemberCallExpressionMap[codeConstruct.nodeId] = codeConstruct;
            }

            var potentialDependencyEdges = codeConstruct.graphNode.getDependencies(maxDependencyIndex, dependencyConstraint);

            for(var i = potentialDependencyEdges.length - 1; i >= 0; i--)
            {
                var dependencyEdge = potentialDependencyEdges[i];
                if(dependencyEdge.hasBeenTraversed) { continue; }

                //if(dependencyEdge.index >= 85346 && dependencyEdge.index <= 85396) debugger;

                dependencyEdge.hasBeenTraversed = true;
                this.traversedEdgesMap[dependencyEdge.index] = true;
                addedDependencies++;
                var dependencyConstraintToFollow = dependencyConstraint;

                if(dependencyConstraintToFollow == null){ dependencyConstraintToFollow = dependencyEdge.destinationNodeDependencyConstraints; }
                else if(dependencyEdge.destinationNodeDependencyConstraints.currentCommandId < dependencyConstraint.currentCommandId)
                {
                    dependencyConstraintToFollow = dependencyEdge.destinationNodeDependencyConstraints;
                }
                else if (dependencyEdge.isReturnDependency || dependencyEdge.shouldAlwaysBeFollowed)
                {
                    dependencyConstraintToFollow = dependencyEdge.destinationNodeDependencyConstraints;
                }

                if(dependencyEdge.shouldNotFollowDependency)
                {
                    Firecrow.includeNode(dependencyEdge.destinationNode.model);
                    continue;
                }

                if(dependencyEdge.isPreviouslyExecutedBlockStatementDependency)
                {
                    this.previouslyExecutedBlockDependencies.push
                    ({
                        codeConstruct:dependencyEdge.destinationNode.model,
                        maxDependencyIndex: dependencyEdge.index,
                        dependencyConstraint: dependencyConstraintToFollow,
                        includedByNode:  dependencyEdge.sourceNode.model,
                        executionContextId: dependencyEdge.executionContextId
                    });

                    continue;
                }
                //if(dependencyEdge.index >= 49955 && dependencyEdge.index < 253284) debugger;3
                this._traverseAndMark(dependencyEdge.destinationNode.model, dependencyEdge.index, dependencyConstraintToFollow, dependencyEdge.sourceNode.model, addedDependencies);
            }

            return addedDependencies;
        },

        notifyError: function(message)
        {
            debugger;
            Firecrow.DependencyGraph.DependencyGraph.notifyError(message);
        }
    };
}});/**
 * User: Jomaras
 * Date: 15.06.12.
 * Time: 13:01
 */
FBL.ns(function() { with (FBL) {
/*************************************************************************************/
Firecrow.DependencyGraph.SlicingCriterion = function(type)
{
    this.type = type;
};

Firecrow.DependencyGraph.SlicingCriterion.TYPES =
{
    READ_IDENTIFIER: "READ_IDENTIFIER",
    DOM_MODIFICATION: "DOM_MODIFICATION",
    LINE_EXECUTED: "LINE_EXECUTED"
};

Firecrow.DependencyGraph.SlicingCriterion.createReadIdentifierCriterion = function(fileName, lineNumber, identifierName)
{
    var criterion = new Firecrow.DependencyGraph.SlicingCriterion(Firecrow.DependencyGraph.SlicingCriterion.TYPES.READ_IDENTIFIER);

    criterion.fileName = fileName;
    criterion.lineNumber = lineNumber;
    criterion.identifierName = identifierName;

    return criterion;
};

Firecrow.DependencyGraph.SlicingCriterion.createModifyDomCriterion = function(cssSelector)
{
    var criterion = new Firecrow.DependencyGraph.SlicingCriterion(Firecrow.DependencyGraph.SlicingCriterion.TYPES.DOM_MODIFICATION);

    criterion.cssSelector = cssSelector;

    return criterion;
};

Firecrow.DependencyGraph.SlicingCriterion.createLineExecutedCriterion = function(fileName, lineNumber)
{
    var criterion = new Firecrow.DependencyGraph.SlicingCriterion(Firecrow.DependencyGraph.SlicingCriterion.TYPES.LINE_EXECUTED);

    criterion.fileName = fileName;
    criterion.lineNumber = lineNumber;
};
/*************************************************************************************/
}});FBL.ns(function() { with (FBL) {
/*************************************************************************************/
var ASTHelper = Firecrow.ASTHelper;
var ValueTypeHelper = Firecrow.ValueTypeHelper;
Firecrow.DependencyGraph.InclusionFinder = function(){};

Firecrow.DependencyGraph.InclusionFinder.notifyError = function(message) { alert("InclusionFinder - " + message);}

Firecrow.DependencyGraph.InclusionFinder.prototype =
{
    isIncludedHtmlElement: function(htmlElement)
    {
        try
        {
            if(htmlElement == null) debugger;
            if(htmlElement.shouldBeIncluded) { return true; }

            if(htmlElement.type == "script")
            {
                return this.isIncludedElement(htmlElement.pathAndModel.model);
            }
            else if(htmlElement.type == "style" || htmlElement.type == "link")
            {
                if(htmlElement.cssRules == null) { return false; }

                var rules = htmlElement.cssRules;

                for(var i = 0, length = rules.length; i < length; i++)
                {
                    if(rules[i].shouldBeIncluded) { return true; }
                }
            }
            else if (htmlElement.type == "textNode")
            {
                return htmlElement.shouldBeIncluded || (htmlElement.parent != null && htmlElement.parent.shouldBeIncluded);
            }
            else
            {
                var childNodes = htmlElement.childNodes;
                if(childNodes != null)
                {
                    for(var i = 0, length = childNodes.length; i < length; i++)
                    {
                        if(this.isIncludedHtmlElement(childNodes[i]))
                        {
                            return true;
                        }
                    }
                }
            }

            return false;
        }
        catch(e)
        {
            debugger;
            this.notifyError("Error when finding inclusions in htmlElement: " + e);
        }
    },

    isIncludedElement: function(element)
    {
        if(element == null) { return false;}

             if (ASTHelper.isProgram(element)) { return this.isIncludedProgram(element); }
        else if (ASTHelper.isStatement(element)) { return this.isIncludedStatement(element); }
        else if (ASTHelper.isFunction(element)) { return this.isIncludedFunction(element); }
        else if (ASTHelper.isExpression(element)) { return this.isIncludedExpression(element); }
        else if (ASTHelper.isSwitchCase(element)) { return this.isIncludedSwitchCase(element); }
        else if (ASTHelper.isCatchClause(element)) { return this.isIncludedCatchClause(element); }
        else if (ASTHelper.isVariableDeclaration(element)) { return this.isIncludedVariableDeclaration(element); }
        else if (ASTHelper.isVariableDeclarator(element)) { return this.isIncludedVariableDeclarator(element); }
        else if (ASTHelper.isLiteral(element)) { return this.isIncludedLiteral(element); }
        else if (ASTHelper.isIdentifier(element)) { return this.isIncludedIdentifier(element); }
        else { this.notifyError("Error while finding inclusions unidentified ast element"); }
    },

    isIncludedProgram: function(programElement)
    {
        if(programElement.body != null)
        {
            var body = programElement.body;

            for(var i = 0, length = body.length; i < length; i++)
            {
                if(this.isIncludedElement(body[i])) { return true; }
            }
        }

        return false;
    },

    isIncludedStatement: function(statement)
    {
             if (ASTHelper.isEmptyStatement(statement))  { return this.isIncludedEmptyStatement(statement); }
        else if (ASTHelper.isBlockStatement(statement)) { return this.isIncludedBlockStatement(statement); }
        else if (ASTHelper.isExpressionStatement(statement)) { return this.isIncludedExpressionStatement(statement); }
        else if (ASTHelper.isIfStatement(statement)) { return this.isIncludedIfStatement(statement); }
        else if (ASTHelper.isWhileStatement(statement)) { return this.isIncludedWhileStatement(statement); }
        else if (ASTHelper.isDoWhileStatement(statement)) { return this.isIncludedDoWhileStatement(statement); }
        else if (ASTHelper.isForStatement(statement)) { return this.isIncludedForStatement(statement); }
        else if (ASTHelper.isForInStatement(statement)) { return this.isIncludedForInStatement(statement); }
        else if (ASTHelper.isLabeledStatement(statement)) { return this.isIncludedLabeledStatement(statement); }
        else if (ASTHelper.isBreakStatement(statement)) { return this.isIncludedBreakStatement(statement); }
        else if (ASTHelper.isContinueStatement(statement)) { return this.isIncludedContinueStatement(statement); }
        else if (ASTHelper.isReturnStatement(statement)) { return this.isIncludedReturnStatement(statement); }
        else if (ASTHelper.isWithStatement(statement)) { return this.isIncludedWithStatement(statement); }
        else if (ASTHelper.isTryStatement(statement)) { return this.isIncludedTryStatement(statement); }
        else if (ASTHelper.isThrowStatement(statement)) { return this.isIncludedThrowStatement(statement); }
        else if (ASTHelper.isSwitchStatement(statement)) { return this.isIncludedSwitchStatement(statement); }
        else { this.notifyError("Error: AST Statement element not defined: " + statement.type);}
    },

    isIncludedExpression: function(expression)
    {
             if (ASTHelper.isAssignmentExpression(expression)) { return this.isIncludedAssignmentExpression(expression); }
        else if (ASTHelper.isUnaryExpression(expression)) { return this.isIncludedUnaryExpression(expression); }
        else if (ASTHelper.isBinaryExpression(expression)) { return this.isIncludedBinaryExpression(expression); }
        else if (ASTHelper.isLogicalExpression(expression)) { return this.isIncludedLogicalExpression(expression); }
        else if (ASTHelper.isLiteral(expression)) { return this.isIncludedLiteral(expression); }
        else if (ASTHelper.isIdentifier(expression)) { return this.isIncludedIdentifier(expression); }
        else if (ASTHelper.isUpdateExpression(expression)) { return this.isIncludedUpdateExpression(expression); }
        else if (ASTHelper.isNewExpression(expression)) { return this.isIncludedNewExpression(expression); }
        else if (ASTHelper.isConditionalExpression(expression)) { return this.isIncludedConditionalExpression(expression); }
        else if (ASTHelper.isThisExpression(expression)) { return this.isIncludedThisExpression(expression); }
        else if (ASTHelper.isCallExpression(expression)) { return this.isIncludedCallExpression(expression); }
        else if (ASTHelper.isMemberExpression(expression)) { return this.isIncludedMemberExpression(expression); }
        else if (ASTHelper.isSequenceExpression(expression)) { return this.isIncludedSequenceExpression(expression); }
        else if (ASTHelper.isArrayExpression(expression)) { return this.isIncludedArrayExpression(expression); }
        else if (ASTHelper.isObjectExpression(expression)) { return this.isIncludedObjectExpression(expression); }
        else if (ASTHelper.isFunctionExpression(expression)) { return this.isIncludedFunction(expression); }
        else { this.notifyError("Error: AST Expression element not defined: " + expression.type);  return false;}
    },

    isIncludedFunction: function(functionDecExp)
    {
        return functionDecExp.shouldBeIncluded
            || this.isIncludedFunctionParameters(functionDecExp)
            || this.isIncludedFunctionBody(functionDecExp);
    },

    isIncludedFunctionParameters: function(functionDecExp)
    {
        var params = functionDecExp.params;

        for(var i = 0, length = params.length; i < length; i++)
        {
            if(params[i].shouldBeIncluded) { return true; }
        }

        return false;
    },

    isIncludedFunctionBody: function(functionDeclExp)
    {
        this.isIncludedElement(functionDeclExp.body);
    },

    isIncludedBlockStatement: function(blockStatement)
    {
        var body = blockStatement.body;

        for(var i = 0, length = body.length; i < length; i++)
        {
            if(this.isIncludedElement(body[i])) { return true; };
        }

        return false;
    },

    isIncludedEmptyStatement: function(emptyStatement)
    {
        return emptyStatement.shouldBeIncluded;
    },

    isIncludedExpressionStatement: function(expressionStatement)
    {
        return this.isIncludedElement(expressionStatement.expression);
    },

    isIncludedAssignmentExpression: function(assignmentExpression)
    {
        return assignmentExpression.shouldBeIncluded
            || this.isIncludedElement(assignmentExpression.left)
            || this.isIncludedElement(assignmentExpression.right)
    },

    isIncludedUnaryExpression: function(unaryExpression)
    {
        return unaryExpression.shouldBeIncluded
            || this.isIncludedExpression(unaryExpression.argument);
    },

    isIncludedBinaryExpression: function(binaryExpression)
    {
        return binaryExpression.shouldBeIncluded
            || this.isIncludedElement(binaryExpression.left)
            || this.isIncludedElement(binaryExpression.right);
    },

    isIncludedLogicalExpression: function(logicalExpression)
    {
        return logicalExpression.shouldBeIncluded
            || this.isIncludedElement(logicalExpression.left)
            || this.isIncludedElement(logicalExpression.right);
    },

    isIncludedUpdateExpression: function(updateExpression)
    {
        return updateExpression.shouldBeIncluded
            || this.isIncludedExpression(updateExpression.argument);
    },

    isIncludedNewExpression: function(newExpression)
    {
        return newExpression.shouldBeIncluded
            || this.isIncludedElement(newExpression.callee)
            || this.isSequenceIncluded(newExpression.arguments);
    },

    isIncludedConditionalExpression: function(conditionalExpression)
    {
        return conditionalExpression.shouldBeIncluded
            || this.isIncludedElement(conditionalExpression.test)
            || this.isIncludedElement(conditionalExpression.consequent)
            || this.isIncludedElement(conditionalExpression.alternate);
    },

    isIncludedThisExpression: function(thisExpression)
    {
        return thisExpression.shouldBeIncluded;
    },

    isIncludedCallExpression: function(callExpression)
    {
        return callExpression.shouldBeIncluded
            || this.isIncludedElement(callExpression.callee)
            || this.isSequenceIncluded(callExpression.arguments);
    },

    isIncludedMemberExpression: function(memberExpression)
    {
        return memberExpression.shouldBeIncluded
            || this.isIncludedElement(memberExpression.object)
            || this.isIncludedElement(memberExpression.property);
    },

    isIncludedSequenceExpression: function(sequenceExpression)
    {
        var isIncluded = this.isSequenceIncluded(sequenceExpression.expressions);

        if(isIncluded)
        {
            Firecrow.includeNode(sequenceExpression);
        }

        return isIncluded;
    },

    isIncludedArrayExpression: function(arrayExpression)
    {
        return arrayExpression.shouldBeIncluded
            || this.isSequenceIncluded(arrayExpression.elements);
    },

    isIncludedObjectExpression: function(objectExpression)
    {
        var properties = objectExpression.properties;

        if(objectExpression.shouldBeIncluded) { return true; }

        for (var i = 0, length = properties.length; i < length; i++)
        {
            if(this.isIncludedObjectExpressionProperty(properties[i])) { return true;}
        }

        return false;
    },

    isIncludedObjectExpressionProperty: function(objectExpressionProperty)
    {
        if(objectExpressionProperty.shouldBeIncluded || objectExpressionProperty.key.shouldBeIncluded) { return true;}

        return objectExpressionProperty.value != null
             ? this.isIncludedElement(objectExpressionProperty.value)
             : false;
    },

    isIncludedIfStatement: function(ifStatement)
    {
        return ifStatement.shouldBeIncluded
            || this.isIncludedElement(ifStatement.test)
            || this.isIncludedElement(ifStatement.consequent)
            || (ifStatement.alternate != null ? this.isIncludedElement(ifStatement.alternate) : false);
    },

    isIncludedWhileStatement: function(whileStatement)
    {
        return whileStatement.shouldBeIncluded
            || this.isIncludedElement(whileStatement.test)
            || this.isIncludedElement(whileStatement.body);
    },

    isIncludedDoWhileStatement: function(doWhileStatement)
    {
        return doWhileStatement.shouldBeIncluded
            || this.isIncludedElement(doWhileStatement.test)
            || this.isIncludedElement(doWhileStatement.body);
    },

    isIncludedForStatement: function(forStatement)
    {                                    arguments
        var testIncluded = (forStatement.test != null ? this.isIncludedElement(forStatement.test) : false);
        var updateIncluded = (forStatement.update != null ? this.isIncludedElement(forStatement.update) : false);

        //TODO: HACK!
        if(testIncluded && !updateIncluded)
        {
            if(forStatement.update != null)
            {
                updateIncluded = true;
                Firecrow.includeNode(forStatement.update);
                if(forStatement.update.children != null)
                {
                    forStatement.update.children.forEach(function(child)
                    {
                        Firecrow.includeNode(child);
                    });
                }
            }
        }
        //END HACK!

        return  forStatement.shouldBeIncluded
            || (forStatement.init != null ? this.isIncludedElement(forStatement.init) : false)
            || testIncluded
            || updateIncluded
            || this.isIncludedElement(forStatement.body);
    },

    isIncludedForInStatement: function(forInStatement)
    {
        return forInStatement.shouldBeIncluded
            || this.isIncludedElement(forInStatement.left)
            || this.isIncludedElement(forInStatement.right)
            || this.isIncludedElement(forInStatement.body);
    },

    isIncludedBreakStatement: function(breakStatement)
    {
        return breakStatement.shouldBeIncluded;
    },

    isIncludedContinueStatement: function(continueStatement)
    {
        return continueStatement.shouldBeIncluded;
    },

    isIncludedReturnStatement: function(returnStatement)
    {
        return returnStatement.shouldBeIncluded
            || (returnStatement.argument != null ? this.isIncludedExpression(returnStatement.argument) : false);
    },

    isIncludedWithStatement: function(withStatement)
    {
        return withStatement.shouldBeIncluded
            || this.isIncludedExpression(withStatement.object)
            || this.isIncludedStatement(withStatement.body);
    },

    isIncludedThrowStatement: function(throwStatement)
    {
        return throwStatement.shouldBeIncluded
            || this.isIncludedExpression(throwStatement.argument);
    },

    isIncludedSwitchStatement: function(switchStatement)
    {
        if(switchStatement.shouldBeIncluded || this.isIncludedExpression(switchStatement.discriminant)) { return true; }

        for(var i = 0; i < switchStatement.cases.length; i++)
        {
            if(this.isIncludedSwitchCase(switchStatement.cases[i])) { return true; }
        }

        return false;
    },

    isIncludedSwitchCase: function(switchCase)
    {
        if(switchCase.shouldBeIncluded) { return true; }

        if(switchCase.test != null) { if(this.isIncludedExpression(switchCase.test)) { return true;}; }

        for(var i = 0; i < switchCase.consequent.length; i++)
        {
            if(this.isIncludedElement(switchCase.consequent[i])) { return true; }
        }

        return false;
    },

    isIncludedTryStatement: function(tryStatement)
    {
        if(tryStatement.shouldBeIncluded) { return true;}
        if(this.isIncludedElement(tryStatement.block)) { return true; }

        var handlers = tryStatement.handlers ||
           (ValueTypeHelper.isArray(tryStatement.handler) ? tryStatement.handler :
                                                            [tryStatement.handler]);

        for(var i = 0; i < handlers.length; i++)
        {
            if(this.isIncludedCatchClause(handlers[i])) { return true};
        }

        if(tryStatement.finalizer != null)
        {
            if(this.isIncludedElement(tryStatement.finalizer)) { return true;}
        }

        return false;
    },

    isIncludedLabeledStatement: function(labeledStatement)
    {
        return labeledStatement.shouldBeIncluded
            || this.isIncludedIdentifier(labeledStatement.label)
            || this.isIncludedElement(labeledStatement.body);
    },

    isIncludedVariableDeclaration: function(variableDeclaration)
    {
        if(variableDeclaration.shouldBeIncluded) { return true; }

        var declarators = variableDeclaration.declarations;
        for (var i = 0, length = declarators.length; i < length; i++)
        {
            var declarator = declarators[i];

            if(this.isIncludedVariableDeclarator(declarator)) { return true; }
        }

        return false;
    },

    isIncludedVariableDeclarator: function(variableDeclarator)
    {
        return variableDeclarator.shouldBeIncluded
            || this.isIncludedPattern(variableDeclarator.id)
            || (variableDeclarator.init != null ? this.isIncludedElement(variableDeclarator.init) : false);
    },

    isIncludedPattern: function(pattern)
    {
        if(ASTHelper.isIdentifier(pattern)) { return this.isIncludedIdentifier(pattern);}

        return false;
    },

    isIncludedCatchClause: function(catchClause)
    {
        if(catchClause == null) return false;

        return catchClause.shouldBeIncluded
            || this.isIncludedStatement(catchClause.body)
            || this.isIncludedElement(catchClause.param);
    },

    isIncludedIdentifier: function(identifier)
    {
        return identifier.shouldBeIncluded;
    },

    isIncludedLiteral: function(literal)
    {
        return literal.shouldBeIncluded;
    },

    isSequenceIncluded: function(sequence)
    {
        for(var i = 0, length = sequence.length; i < length; i++)
        {
            var item = sequence[i];

            if(item.shouldBeIncluded || this.isIncludedElement(item)) { return true; }
        }

        return false;
    },

    notifyError:function(message) { Firecrow.DependencyGraph.InclusionFinder.notifyError(message); }
}
/*************************************************************************************/
}});FBL.ns(function() { with (FBL) {
/*************************************************************************************/
var ASTHelper = Firecrow.ASTHelper;
var ValueTypeHelper = Firecrow.ValueTypeHelper;
var InclusionFinder = Firecrow.DependencyGraph.InclusionFinder;

Firecrow.DependencyGraph.DependencyPostprocessor = function()
{
    this.inclusionFinder = new InclusionFinder();
};

Firecrow.DependencyGraph.DependencyPostprocessor.notifyError = function(message) { debugger; alert("DependencyPostprocessor - " + message); }
Firecrow.DependencyGraph.DependencyPostprocessor.processHtmlElement = function(model)
{
    try { (new Firecrow.DependencyGraph.DependencyPostprocessor()).processHtmlElement(model); }
    catch(e) {  Firecrow.DependencyGraph.DependencyPostprocessor.notifyError("Error when processing HTML element " + e); }
};

Firecrow.DependencyGraph.DependencyPostprocessor.prototype =
{
    processHtmlElement: function(htmlElement)
    {
        if(!this.inclusionFinder.isIncludedHtmlElement(htmlElement)) { return; }

        var previousValue = htmlElement.shouldBeIncluded;

        Firecrow.includeNode(htmlElement, true);

        if(htmlElement.type == "script")
        {
            this.processElement(htmlElement.pathAndModel.model);
        }
        else if(htmlElement.type == "style" || htmlElement.type == "textNode") {}
        else
        {
            var childNodes = htmlElement.childNodes;

            if(childNodes != null)
            {
                for(var i = 0, length = childNodes.length; i < length; i++)
                {
                    this.processHtmlElement(childNodes[i]);
                }
            }
        }
    },

    processElement: function(element)
    {
             if (ASTHelper.isProgram(element)) { this.processProgram(element); }
        else if (ASTHelper.isStatement(element)) { this.processStatement(element); }
        else if (ASTHelper.isFunction(element)) { this.processFunction(element); }
        else if (ASTHelper.isExpression(element)) { this.processExpression(element); }
        else if (ASTHelper.isSwitchCase(element)) { this.processSwitchCase(element); }
        else if (ASTHelper.isCatchClause(element)) { this.processCatchClause(element); }
        else if (ASTHelper.isVariableDeclaration(element)) { this.processVariableDeclaration(element); }
        else if (ASTHelper.isVariableDeclarator(element)) { this.processVariableDeclarator(element); }
        else if (ASTHelper.isLiteral(element)) { this.processLiteral(element); }
        else if (ASTHelper.isIdentifier(element)) { this.processIdentifier(element); }
        else { this.notifyError("Error while processing code unidentified ast element"); }
    },

    processProgram: function(programElement)
    {
        if(!this.inclusionFinder.isIncludedProgram(programElement)) { return; }

        Firecrow.includeNode(programElement, true);

        if(programElement.body != null)
        {
            var body = programElement.body;

            for(var i = 0, length = body.length; i < length; i++)
            {
                this.processElement(body[i]);
            }
        }
    },

    processStatement: function(statement)
    {
             if (ASTHelper.isEmptyStatement(statement))  { this.processEmptyStatement(statement); }
        else if (ASTHelper.isBlockStatement(statement)) { this.processBlockStatement(statement); }
        else if (ASTHelper.isExpressionStatement(statement)) { this.processExpressionStatement(statement); }
        else if (ASTHelper.isIfStatement(statement)) { this.processIfStatement(statement); }
        else if (ASTHelper.isWhileStatement(statement)) { this.processWhileStatement(statement); }
        else if (ASTHelper.isDoWhileStatement(statement)) { this.processDoWhileStatement(statement); }
        else if (ASTHelper.isForStatement(statement)) { this.processForStatement(statement); }
        else if (ASTHelper.isForInStatement(statement)) { this.processForInStatement(statement); }
        else if (ASTHelper.isLabeledStatement(statement)) { this.processLabeledStatement(statement); }
        else if (ASTHelper.isBreakStatement(statement)) { this.processBreakStatement(statement); }
        else if (ASTHelper.isContinueStatement(statement)) { this.processContinueStatement(statement); }
        else if (ASTHelper.isReturnStatement(statement)) { this.processReturnStatement(statement); }
        else if (ASTHelper.isWithStatement(statement)) { this.processWithStatement(statement); }
        else if (ASTHelper.isTryStatement(statement)) { this.processTryStatement(statement); }
        else if (ASTHelper.isThrowStatement(statement)) { this.processThrowStatement(statement); }
        else if (ASTHelper.isSwitchStatement(statement)) { this.processSwitchStatement(statement); }
        else if (ASTHelper.isVariableDeclaration(statement)) { this.processVariableDeclaration(statement);}
        else { this.notifyError("Error: AST Statement element not defined: " + statement.type); }
    },

    processExpression: function(expression)
    {
             if (ASTHelper.isAssignmentExpression(expression)) { this.processAssignmentExpression(expression); }
        else if (ASTHelper.isUnaryExpression(expression)) { this.processUnaryExpression(expression); }
        else if (ASTHelper.isBinaryExpression(expression)) { this.processBinaryExpression(expression); }
        else if (ASTHelper.isLogicalExpression(expression)) { this.processLogicalExpression(expression); }
        else if (ASTHelper.isLiteral(expression)) { this.processLiteral(expression); }
        else if (ASTHelper.isIdentifier(expression)) { this.processIdentifier(expression); }
        else if (ASTHelper.isUpdateExpression(expression)) { this.processUpdateExpression(expression); }
        else if (ASTHelper.isNewExpression(expression)) { this.processNewExpression(expression); }
        else if (ASTHelper.isConditionalExpression(expression)) { this.processConditionalExpression(expression); }
        else if (ASTHelper.isThisExpression(expression)) { this.processThisExpression(expression); }
        else if (ASTHelper.isCallExpression(expression)) { this.processCallExpression(expression); }
        else if (ASTHelper.isMemberExpression(expression)) { this.processMemberExpression(expression); }
        else if (ASTHelper.isSequenceExpression(expression)) { this.processSequenceExpression(expression); }
        else if (ASTHelper.isArrayExpression(expression)) { this.processArrayExpression(expression); }
        else if (ASTHelper.isObjectExpression(expression)) { this.processObjectExpression(expression); }
        else if (ASTHelper.isFunctionExpression(expression)) { this.processFunction(expression); }
        else { this.notifyError("Error: AST Expression element not defined: " + expression.type);  "";}
    },

    processFunction: function(functionDecExp)
    {
        if(!this.inclusionFinder.isIncludedFunction(functionDecExp)) { return; }

        Firecrow.includeNode(functionDecExp, true);
        Firecrow.includeNode(functionDecExp.body, true);

        if(functionDecExp.id != null) { Firecrow.includeNode(functionDecExp.id);}

        var params = functionDecExp.params;

        if(params != null)
        {
            for(var i = 0, length = params.length; i < length; i++)
            {
                Firecrow.includeNode(params[i], true);
            }
        }


        this.processFunctionBody(functionDecExp);
    },

    processFunctionBody: function(functionDeclExp)
    {
        this.processElement(functionDeclExp.body);
    },

    processBlockStatement: function(blockStatement)
    {
        if(!this.inclusionFinder.isIncludedBlockStatement(blockStatement)) { return; }

        Firecrow.includeNode(blockStatement, true);

        var body = blockStatement.body;

        for(var i = 0, length = body.length; i < length; i++)
        {
            this.processElement(body[i]);
        }
    },

    processEmptyStatement: function(emptyStatement)
    {
    },

    processExpressionStatement: function(expressionStatement)
    {
        if(!this.inclusionFinder.isIncludedExpressionStatement(expressionStatement)) { return; }

        Firecrow.includeNode(expressionStatement, true);

        this.processElement(expressionStatement.expression);
    },

    processAssignmentExpression: function(assignmentExpression)
    {
        if(!this.inclusionFinder.isIncludedAssignmentExpression(assignmentExpression)) { return; }

        if(assignmentExpression.shouldBeIncluded)
        {
            Firecrow.includeNode(assignmentExpression.left, true);
        }

        Firecrow.includeNode(assignmentExpression, true);

        this.processElement(assignmentExpression.left);
        this.processElement(assignmentExpression.right);
    },

    processUnaryExpression: function(unaryExpression)
    {
        if(!this.inclusionFinder.isIncludedUnaryExpression(unaryExpression)) { return; }

        Firecrow.includeNode(unaryExpression, true);

        this.processExpression(unaryExpression.argument);
    },

    processBinaryExpression: function(binaryExpression)
    {
        if(!this.inclusionFinder.isIncludedBinaryExpression(binaryExpression)) { return; }

        Firecrow.includeNode(binaryExpression, true);

        this.processElement(binaryExpression.left);
        this.processElement(binaryExpression.right);
    },

    processLogicalExpression: function(logicalExpression)
    {
        if(!this.inclusionFinder.isIncludedLogicalExpression(logicalExpression)) { return; }

        Firecrow.includeNode(logicalExpression, true);

        this.processElement(logicalExpression.left);
        this.processElement(logicalExpression.right);
    },

    processUpdateExpression: function(updateExpression)
    {
        if(!this.inclusionFinder.isIncludedUpdateExpression(updateExpression)) { return; }

        Firecrow.includeNode(updateExpression, true);

        this.processElement(updateExpression.argument);
    },

    processNewExpression: function(newExpression)
    {
        if(!this.inclusionFinder.isIncludedNewExpression(newExpression)) { return; }

        Firecrow.includeNode(newExpression, true);
        Firecrow.includeNode(newExpression.callee, true);

        this.processElement(newExpression.callee);
        this.processSequence(newExpression.arguments);
    },

    processConditionalExpression: function(conditionalExpression)
    {
        if(!this.inclusionFinder.isIncludedConditionalExpression(conditionalExpression)) { return; }

        Firecrow.includeNode(conditionalExpression, true);

        this.processElement(conditionalExpression.test);
        this.processElement(conditionalExpression.consequent);
        this.processElement(conditionalExpression.alternate);
    },

    processThisExpression: function(thisExpression) { },

    processCallExpression: function(callExpression)
    {
        if(!this.inclusionFinder.isIncludedCallExpression(callExpression)) { return; }

        Firecrow.includeNode(callExpression, true);

        /*if(ASTHelper.isMemberExpression(callExpression.callee))
        {
            if(ASTHelper.isIdentifier(callExpression.callee.property))
            {
                Firecrow.includeNode(callExpression.callee.property);
            }

            if(ASTHelper.isIdentifier(callExpression.callee.object))
            {
                Firecrow.includeNode(callExpression.callee.object);
            }
        }*/

        this.processElement(callExpression.callee);
        this.processSequence(callExpression.arguments);
    },

    processMemberExpression: function(memberExpression)
    {
        if(!this.inclusionFinder.isIncludedMemberExpression(memberExpression)) { return; }

        var isObjectIncluded = this.inclusionFinder.isIncludedElement(memberExpression.object);
        var isPropertyIncluded = this.inclusionFinder.isIncludedElement(memberExpression.property);

        var areChildrenIncluded = isObjectIncluded || isPropertyIncluded;

        if(areChildrenIncluded)
        {
            Firecrow.includeNode(memberExpression, true);
        }

        if(!ASTHelper.isMemberExpression(memberExpression.parent)
        && !ASTHelper.isCallExpression(memberExpression.parent)
        && !ASTHelper.isCallExpression(memberExpression.object))
        {
            Firecrow.includeNode(memberExpression.object, true);
            Firecrow.includeNode(memberExpression.property, true);
        }
        /*else
        {
            if(ASTHelper.isIdentifier(memberExpression.property)
            && !ASTHelper.isCallExpression(memberExpression.parent)
            && areChildrenIncluded)
            {
                Firecrow.includeNode(memberExpression.object);
                Firecrow.includeNode(memberExpression.property);
            }
        } */

        this.processElement(memberExpression.object);
        this.processElement(memberExpression.property);
    },

    processSequenceExpression: function(sequenceExpression)
    {
        if(!this.inclusionFinder.isIncludedSequenceExpression(sequenceExpression)) { return; }

        Firecrow.includeNode(sequenceExpression, true);

        this.processSequence(sequenceExpression.expressions);
    },

    processArrayExpression: function(arrayExpression)
    {
        if(!this.inclusionFinder.isIncludedArrayExpression(arrayExpression)) { return; }

        Firecrow.includeNode(arrayExpression, true);

        this.processSequence(arrayExpression.elements);
    },

    processObjectExpression: function(objectExpression)
    {
        if(!this.inclusionFinder.isIncludedObjectExpression(objectExpression)) { return; }

        Firecrow.includeNode(objectExpression, true);

        var properties = objectExpression.properties;

        for (var i = 0, length = properties.length; i < length; i++)
        {
            this.processObjectExpressionProperty(properties[i]);
        }
    },

    processObjectExpressionProperty: function(objectExpressionProperty)
    {
        if(!this.inclusionFinder.isIncludedObjectExpressionProperty(objectExpressionProperty)) { return; }

        Firecrow.includeNode(objectExpressionProperty, true);
        Firecrow.includeNode(objectExpressionProperty.key, true);

        this.processElement(objectExpressionProperty.value);
    },

    processIfStatement: function(ifStatement)
    {
        if(!this.inclusionFinder.isIncludedIfStatement(ifStatement)) { return; }

        Firecrow.includeNode(ifStatement, true);

        this.processElement(ifStatement.test);

        //TODO - not sure about this: the problem is the if statement gets included, but it does not include the
        //return statement in it's body - and i'm not sure whether it even should
        if(ifStatement.test.shouldBeIncluded)
        {
            var returnStatement = ASTHelper.getDirectlyContainedReturnStatement(ifStatement.consequent);

            if(returnStatement != null && returnStatement.hasBeenExecuted)
            {
                Firecrow.includeNode(returnStatement, true);
            }
        }

        this.processElement(ifStatement.consequent);

        if(ifStatement.alternate != null)
        {
            this.processElement(ifStatement.alternate);
        }
    },

    processWhileStatement: function(whileStatement)
    {
        if(!this.inclusionFinder.isIncludedWhileStatement(whileStatement)) { return; }

        Firecrow.includeNode(whileStatement, true);

        this.processElement(whileStatement.test);
        this.processElement(whileStatement.body);
    },

    processDoWhileStatement: function(doWhileStatement)
    {
        if(!this.inclusionFinder.isIncludedDoWhileStatement(doWhileStatement)) { return; }

        Firecrow.includeNode(doWhileStatement, true);

        this.processElement(doWhileStatement.test);
        this.processElement(doWhileStatement.body);
    },

    processForStatement: function(forStatement)
    {
        if(!this.inclusionFinder.isIncludedForStatement(forStatement)) { return; }

        Firecrow.includeNode(forStatement, true);

        if(forStatement.init != null) { this.processElement(forStatement.init); }
        if(forStatement.test != null) { this.processElement(forStatement.test); }
        if(forStatement.update != null) {this.processElement(forStatement.update)}

        this.processElement(forStatement.body);
    },

    processForInStatement: function(forInStatement)
    {
        if(!this.inclusionFinder.isIncludedForInStatement(forInStatement)) { return; }

        Firecrow.includeNode(forInStatement, true);

        this.processElement(forInStatement.left);
        this.processElement(forInStatement.right);
        this.processElement(forInStatement.body);

        if(forInStatement.right.shouldBeIncluded) { forInStatement.left.shouldBeIncluded; }
    },

    processBreakStatement: function(breakStatement)
    {
        if(!this.inclusionFinder.isIncludedBreakStatement(breakStatement)) { return; }

        Firecrow.includeNode(breakStatement, true);
    },

    processContinueStatement: function(continueStatement)
    {
        if(!this.inclusionFinder.isIncludedContinueStatement(continueStatement)) { return; }

        Firecrow.includeNode(continueStatement, true);
    },

    processReturnStatement: function(returnStatement)
    {
        if(!this.inclusionFinder.isIncludedReturnStatement(returnStatement)) { return; }

        Firecrow.includeNode(returnStatement, true);

        if(returnStatement.argument != null) { this.processExpression(returnStatement.argument); }
    },

    processWithStatement: function(withStatement)
    {
        if(!this.inclusionFinder.isIncludedWithStatement(withStatement)) { return; }

        Firecrow.includeNode(withStatement, true);

        this.processExpression(withStatement.object);
        this.processStatement(withStatement.body);
    },

    processThrowStatement: function(throwStatement)
    {
        if(!this.inclusionFinder.isIncludedThrowStatement(throwStatement)) { return; }

        Firecrow.includeNode(throwStatement, true);

        this.processExpression(throwStatement.argument);
    },

    processSwitchStatement: function(switchStatement)
    {
        if(!this.inclusionFinder.isIncludedSwitchStatement(switchStatement)) { return; }

        Firecrow.includeNode(switchStatement, true);

        this.processExpression(switchStatement.discriminant);

        for(var i = 0; i < switchStatement.cases.length; i++)
        {
            this.processSwitchCase(switchStatement.cases[i]);
        }
    },

    processSwitchCase: function(switchCase)
    {
        if(!this.inclusionFinder.isIncludedSwitchCase(switchCase)) { return; }

        Firecrow.includeNode(switchCase, true);

        if(switchCase.test != null)
        {
            Firecrow.includeNode(switchCase.test, true);
        }


        for(var i = 0; i < switchCase.consequent.length; i++)
        {
            this.processStatement(switchCase.consequent[i]);
        }
    },

    processTryStatement: function(tryStatement)
    {
        if(!this.inclusionFinder.isIncludedTryStatement(tryStatement)) { return; }

        Firecrow.includeNode(tryStatement, true);

        this.processElement(tryStatement.block);

        var handlers = tryStatement.handlers || (ValueTypeHelper.isArray(tryStatement.handler) ? tryStatement.handler : [tryStatement.handler]);

        for(var i = 0; i < handlers.length; i++)
        {
            Firecrow.includeNode(handlers[i], true);
            this.processCatchClause(handlers[i]);
        }

        if(tryStatement.finalizer != null)
        {
            this.processElement(tryStatement.finalizer);
        }
    },

    processLabeledStatement: function(labeledStatement)
    {
        if(!this.inclusionFinder.isIncludedStatement(labeledStatement)) { return; }

        Firecrow.includeNode(labeledStatement, true);

        this.processElement(labeledStatement.body);
    },

    processVariableDeclaration: function(variableDeclaration)
    {
        if(!this.inclusionFinder.isIncludedVariableDeclaration(variableDeclaration)) { return; }

        Firecrow.includeNode(variableDeclaration, true);

        var declarators = variableDeclaration.declarations;

        for (var i = 0, length = declarators.length; i < length; i++)
        {
            this.processVariableDeclarator(declarators[i]);
        }
    },

    processVariableDeclarator: function(variableDeclarator)
    {
        if(!this.inclusionFinder.isIncludedVariableDeclarator(variableDeclarator)) { return; }

        Firecrow.includeNode(variableDeclarator, true);
        Firecrow.includeNode(variableDeclarator.id, true);

        if(variableDeclarator.init != null)
        {
            this.processElement(variableDeclarator.init);
        }
    },

    processPattern: function(pattern)
    {
        if(ASTHelper.isIdentifier(pattern)) { this.processIdentifier(pattern);}
    },

    processCatchClause: function(catchClause)
    {
        if(!this.inclusionFinder.isIncludedCatchClause(catchClause)) { return;}

        Firecrow.includeNode(catchClause, true);

        this.processElement(catchClause.param);
        this.processStatement(catchClause.body);
    },

    processIdentifier: function(identifier) { },

    processLiteral: function(literal)
    {
        if(literal.shouldBeIncluded == true && Firecrow.ValueTypeHelper.isObject(literal.value))
        {
            Firecrow.includeNode(literal.value, true);
        }
    },

    processSequence: function(sequence)
    {
        var code = "";

        for(var i = 0, length = sequence.length; i < length; i++)
        {
            this.processElement(sequence[i])
        }
    },

    notifyError:function(message) {  Firecrow.DependencyGraph.DependencyPostprocessor.notifyError(message); }
}
/*************************************************************************************/
}});var usesModule = typeof module !== 'undefined' && module.exports;
if(usesModule)
{
    FBL =  { Firecrow: {}, ns:  function(namespaceFunction){ namespaceFunction(); }};

    var path = require('path');
    var CodeTextGenerator = require(path.resolve(__dirname, "codeTextGenerator.js")).CodeTextGenerator;
    atob = require('atob');
}

var CodeMarkupGenerator;
FBL.ns(function () { with (FBL) {
    /*******/
    var ASTHelper = Firecrow.ASTHelper;
    var ValueTypeHelper = Firecrow.ValueTypeHelper;

    if(ValueTypeHelper == null && usesModule)
    {
        ValueTypeHelper = require(path.resolve(__dirname, "../helpers/valueTypeHelper.js")).ValueTypeHelper;
    }

    if(ASTHelper == null && usesModule)
    {
        ASTHelper = require(path.resolve(__dirname, "../helpers/ASTHelper.js")).ASTHelper;
    }

    Firecrow.CodeMarkupGenerator = CodeMarkupGenerator =
    {
        generateHtmlRepresentation: function(root)
        {
            try
            {
                return "<div class='htmlRepresentation'>" //generate the main container
                        + this.generateHtmlDocumentTypeTags(root.docType) // generate the HTML Document Type Definition
                        + this.generateHtmlElement(root.htmlElement)
                     + '</div>';
            }
            catch(e)
            {
                console.log("Error while creating a HTML representation of the site: " + e);
            }
        },

        generateHtmlDocumentTypeTags: function(documentType)
        {
            var docTypeHtml = '<div class="node documentType">';

            if (documentType == "") { docTypeHtml += '&#60;&#33;DOCTYPE html&#62;'; }
            else if (documentType === "http://www.w3.org/TR/html4/strict.dtd") { docTypeHtml += '&#60;&#33;DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"&#62;';}
            else if (documentType === "http://www.w3.org/TR/html4/loose.dtd") { docTypeHtml += '&#60;&#33;DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&#62;'; }
            else if (documentType === "http://www.w3.org/TR/html4/frameset.dtd") { docTypeHtml += '&#60;&#33;DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Frameset//EN" "http://www.w3.org/TR/html4/frameset.dtd"&#62;'; }
            else if (documentType === "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd") { docTypeHtml += '&#60;&#33;DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"&#62;'; }
            else if (documentType === "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd") { docTypeHtml += '&#60;&#33;DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&#62;'; }
            else if (documentType === "http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd") { docTypeHtml += '&#60;&#33;DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Frameset//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd"&#62;'; }
            else if (documentType === "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd") { docTypeHtml += '&#60;&#33;DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"&#62;'; }
            else { return "";}

            docTypeHtml += '</div>';

            return docTypeHtml;
        },

        generateOpeningTags: function (elementType, elementAttributes)
        {
            if(elementType === 'textNode' || elementAttributes == null) { return ''};

            var html = '';

            // generate <elementType attribute[0].name="attribute[0].value" ... attribute[N].name="attribute[N].value">
            // <elementType
            html += '&#60;<span class="node htmlTag">' + elementType + '</span>';

            for (var i = 0; i < elementAttributes.length; i++)
            {
                html += '<span class="node htmlAttributeName"> ' + elementAttributes[i].name + '</span>=';
                html += '<span class="node htmlAttributeValue">"' + elementAttributes[i].value + '"</span>';
            }
            // generate >
            html += '&#62;';

            return html;
        },

        generateClosingTags: function (elementType)
        {
            if(elementType === "textNode") { return "" };

            return '&#60;&#47;<span class="node htmlTag">' + elementType + "</span>&#62;";
        },

        generateHtmlElement: function(element)
        {
            try
            {
                if(element.type == "textNode") { return element.textContent.trim() != "" ? "<span class='label'>" + element.textContent + "</span>" : ""; }

                var html = '<div class="node ' + element.type + (element.type != "html" ? " indented" : "") + '" id="node' + this.formatId(element.nodeId) + '">'
                          + this.generateOpeningTags(element.type, element.attributes);

                if (element.type === "script")
                {
                    html += this.generateHtml(element.pathAndModel.model);
                }
                else if (element.type === "link")
                {
                    // Check if the link is a stylesheet
                    var isLinkStyleSheet = false;

                    for (var i = 0; i < element.attributes.length; i++)
                    {
                        var attribute = element.attributes[i];
                        if (attribute != undefined)
                        {
                            if (attribute.name === "rel" && attribute.value.toLowerCase() == "stylesheet"
                            ||  attribute.name === "type" && attribute.value.toLowerCase() === "text/css")
                            {
                                html += this.generateCSSRepresentation(element.pathAndModel.model);
                            }
                        }
                    }
                }
                else if (element.type === "style")
                {
                    html += this.generateCSSRepresentation(element.pathAndModel.model);
                }
                else
                {
                    if(element.textContent != undefined) { html += element.textContent; }

                    if(element.childNodes != null)
                    {
                        for(var i=0; i < element.childNodes.length; i++)
                        {
                            html += this.generateHtmlElement(element.childNodes[i]);
                        }
                    }
                }

                if(this.doesElementHaveClosingTags(element.type))
                {
                    html += this.generateClosingTags(element.type);
                }


                html += '</div>';

                return html;
            }
            catch(e)
            {
                debugger;
                alert("Error while generating a html element: " + e);
            }
        },

        generateCSSRepresentation: function(cssModel)
        {
            try
            {
                var html = "<div class=\"cssContainer\">";
                var cssRules = "";
                var rulesArray = [];
                for(var i = 0; i < cssModel.rules.length; i++)
                {
                    // if rule is @charset
                    if (cssModel.rules[i].cssText[0] == "@")
                    {
                        html += '<div class="node cssCharset" id="node' + cssModel.rules[i].nodeId + '">' + cssModel.rules[i].cssText + '</div>';
                    }
                    else
                    {
                        cssRules = cssModel.rules[i].cssText.replace(cssModel.rules[i].selector, "");

                        cssRules = cssRules.replace("{", "");
                        cssRules = cssRules.replace("}", "");
                        while(cssRules[0] === " ")
                            cssRules = cssRules.replace(" ", "");

                        html += '<div class="node cssRule" id="node' + FBL.Firecrow.CodeMarkupGenerator.formatId(cssModel.rules[i].nodeId) +'">';
                        //html += '<span class="node cssSelector">' + cssModel.rules[i].selector + "</span><br>";
                        html += '<span class="node cssSelector">' + cssModel.rules[i].selector + '</span><br>';
                        html += "{ <br>";

                        rulesArray = cssRules.split("; ");

                        for(var j = 0; j < rulesArray.length; j++)
                        {
                            if(rulesArray[j] != "")
                                html += "<span class=\"cssRule\">" + rulesArray[j] + ";</span><br>";
                        }
                        html += '} </div>';
                    }
                }

                html += "</div>";
                return html;
            }
            catch(e)
            {
                alert("Error while generating HTML representation of CSS: " + e);
            }
        },

        doesElementHaveClosingTags: function(elementType)
        {
            return !(elementType === "area"
                || elementType === "base"
                || elementType === "br"
                || elementType === "basefont"
                || elementType === "col"
                || elementType === "frame"
                || elementType ===  "hr"
                || elementType === "img"
                || elementType === "input"
                || elementType === "meta"
                || elementType === "param");
        },

        generateHtml: function(element)
        {
            try
            {
                if(element == null) { return ""; }

                     if (ASTHelper.isProgram(element)) { return this.generateProgram(element); }
                else if (ASTHelper.isStatement(element)) { return this.generateStatement(element); }
                else if (ASTHelper.isExpression(element)) { return this.generateExpression(element); }
                else if (ASTHelper.isSwitchCase(element)) { return this.generateFromSwitchCase(element); }
                else if (ASTHelper.isCatchClause(element)) { return this.generateFromCatchClause(element); }
                else if (ASTHelper.isFunction(element)) { return this.generateFromFunction(element); }
                else if (ASTHelper.isVariableDeclaration(element)) { return this.generateFromVariableDeclaration(element); }
                else if (ASTHelper.isVariableDeclarator(element)) { return this.generateFromVariableDeclarator(element); }
                else if (ASTHelper.isLiteral(element)) { return this.generateFromLiteral(element); }
                else if (ASTHelper.isIdentifier(element)) { return this.generateFromIdentifier(element); }
                else
                {
                    alert("Error while generating HTML in codeMarkupGenerator: unidentified ast element.");
                    return "";
                }
            }
            catch(e)
            {
                debugger;
                alert("Error while generating HTML in codeMarkupGenerator: " + e);
            }
        },

        generateProgram: function(program)
        {
            try
            {
                var html = "<div class=\"jsContainer\">";
                var body = program.body;

                for(var i = 0; i < body.length; i++)
                {
                    html += this.generateHtml(body[i]);
                }

                return html + "</div>";
            }
            catch(e)
            {
                alert("Error when generating program HTML");
            }
        },

        generateStatement: function(statement)
        {
            try
            {
                     if (ASTHelper.isEmptyStatement(statement))  { return this.generateFromEmptyStatement(statement); }
                else if (ASTHelper.isBlockStatement(statement)) { return this.generateFromBlockStatement(statement); }
                else if (ASTHelper.isExpressionStatement(statement)) { return this.generateFromExpressionStatement(statement); }
                else if (ASTHelper.isIfStatement(statement)) { return this.generateFromIfStatement(statement); }
                else if (ASTHelper.isWhileStatement(statement)) { return this.generateFromWhileStatement(statement); }
                else if (ASTHelper.isDoWhileStatement(statement)) { return this.generateFromDoWhileStatement(statement); }
                else if (ASTHelper.isForStatement(statement)) { return this.generateFromForStatement(statement); }
                else if (ASTHelper.isForInStatement(statement)) { return this.generateFromForInStatement(statement); }
                else if (ASTHelper.isLabeledStatement(statement)) { return this.generateFromLabeledStatement(statement); }
                else if (ASTHelper.isBreakStatement(statement)) { return this.generateFromBreakStatement(statement); }
                else if (ASTHelper.isContinueStatement(statement)) { return this.generateFromContinueStatement(statement); }
                else if (ASTHelper.isReturnStatement(statement)) { return this.generateFromReturnStatement(statement); }
                else if (ASTHelper.isWithStatement(statement)) { return this.generateFromWithStatement(statement); }
                else if (ASTHelper.isTryStatement(statement)) { return this.generateFromTryStatement(statement); }
                else if (ASTHelper.isThrowStatement(statement)) { return this.generateFromThrowStatement(statement); }
                else if (ASTHelper.isSwitchStatement(statement)) { return this.generateFromSwitchStatement(statement); }
                else
                {
                    alert("Error: AST Statement element not defined: " + statement.type);
                    return "";
                }
            }
            catch(e)
            {
                debugger;
                alert("Error when generating HTML from a statement: " + e);
            }
        },

        generateExpression: function(expression)
        {
            try
            {
                if (ASTHelper.isAssignmentExpression(expression)) { return this.generateFromAssignmentExpression(expression); }
                else if (ASTHelper.isUnaryExpression(expression)) { return this.generateFromUnaryExpression(expression); }
                else if (ASTHelper.isBinaryExpression(expression)) { return this.generateFromBinaryExpression(expression); }
                else if (ASTHelper.isLogicalExpression(expression)) { return this.generateFromLogicalExpression(expression); }
                else if (ASTHelper.isLiteral(expression)) { return this.generateFromLiteral(expression); }
                else if (ASTHelper.isIdentifier(expression)) { return this.generateFromIdentifier(expression); }
                else if (ASTHelper.isUpdateExpression(expression)) { return this.generateFromUpdateExpression(expression); }
                else if (ASTHelper.isNewExpression(expression)) { return this.generateFromNewExpression(expression); }
                else if (ASTHelper.isConditionalExpression(expression)) { return this.generateFromConditionalExpression(expression); }
                else if (ASTHelper.isThisExpression(expression)) { return this.generateFromThisExpression(expression); }
                else if (ASTHelper.isCallExpression(expression)) { return this.generateFromCallExpression(expression); }
                else if (ASTHelper.isMemberExpression(expression)) { return this.generateFromMemberExpression(expression); }
                else if (ASTHelper.isSequenceExpression(expression)) { return this.generateFromSequenceExpression(expression); }
                else if (ASTHelper.isArrayExpression(expression)) { return this.generateFromArrayExpression(expression); }
                else if (ASTHelper.isObjectExpression(expression)) { return this.generateFromObjectExpression(expression); }
                else if (ASTHelper.isFunctionExpression(expression)) { return this.generateFromFunction(expression, true); }
                else
                {
                    alert("Error: AST Expression element not defined: " + expression.type);  return "";
                }
            }
            catch(e)
            {
                alert("Error when generating HTML from an expression:" + e);
            }
        },

        generateFromFunction: function(functionDecExp)
        {
            try
            {
                var _class = functionDecExp.type + " node" + this._generateHasBeenExecutedClass(functionDecExp);
                var _id = "node" + this.formatId(functionDecExp.nodeId);
                var _style = this.getStyle(functionDecExp);

                var nodeType = ASTHelper.isFunctionExpression(functionDecExp) ? "span" : "div";

                var shouldBeInParentheses = ASTHelper.isFunctionExpression(functionDecExp)
                                         && ASTHelper.isCallExpressionCallee(functionDecExp);

                return this.getStartElementHtml(nodeType, { class: _class, id : _id, style: _style })
                     + (shouldBeInParentheses ? this._LEFT_PARENTHESIS : "")
                     + this.getElementHtml("span", {class: "keyword"}, this._FUNCTION_KEYWORD) + " " + (functionDecExp.id != null ? this.generateFromIdentifier(functionDecExp.id) + " " : "")
                     + this.generateFunctionParametersHtml(functionDecExp)
                     + this.generateFromFunctionBody(functionDecExp)
                     + (shouldBeInParentheses ? this._RIGHT_PARENTHESIS : "")
                     + this.getEndElementHtml(nodeType);
            }
            catch(e)
            {
                alert("Error when generating HTML from a function:" + e);
            }
        },

        generateFunctionParametersHtml: function(functionDecExp)
        {
            var html = this._LEFT_PARENTHESIS;

            for(var i = 0; i < functionDecExp.params.length; i++)
            {
                if(i != 0) { html += ", "; }

                html += this.generateFromPattern(functionDecExp.params[i]);
            }

            return html + this._RIGHT_PARENTHESIS;
        },

        generateFromFunctionBody: function(functionDeclExp)
        {
            return this.generateHtml(functionDeclExp.body);
        },

        generateFromBlockStatement: function(blockStatement)
        {
            var html = this.getStartElementHtml( "div",
                       {
                           class: ASTHelper.CONST.STATEMENT.BlockStatement + " node",
                           id: "node" + this.formatId(blockStatement.nodeId)
                       })
                     + this.getElementHtml("div", {class: "Bracket"}, "{");


            var body = blockStatement.body;
            for(var i = 0, length = body.length; i < length; i++)
            {
                html += this.generateHtml(body[i]);
            }

            return html + this.getElementHtml("div", {class: "Bracket"}, "}")
                        + this.getEndElementHtml("div");
        },

        generateFromEmptyStatement: function(emptyStatement)
        {
            return this.getElementHtml("div",
            {
                class: ASTHelper.CONST.STATEMENT.EmptyStatement + " node",
                id: "node" + this.formatId(emptyStatement.nodeId),
                style: this.getStyle(emptyStatement)
            }, ";");
        },

        generateFromExpressionStatement: function(expressionStatement)
        {
            return this.getStartElementHtml("div",
                    {
                        class: ASTHelper.CONST.STATEMENT.ExpressionStatement + " node" + this._generateHasBeenExecutedClass(expressionStatement),
                        id: "node" + this.formatId(expressionStatement.nodeId),
                        style: this.getStyle(expressionStatement)
                    })
                   + this.generateHtml(expressionStatement.expression)
                   + this.getEndElementHtml("div");
        },

        generateFromAssignmentExpression: function(assignmentExpression)
        {
            var shouldBeSurrounded = ASTHelper.isBinaryExpression(assignmentExpression.parent)
                                  || ASTHelper.isLogicalExpression(assignmentExpression.parent);

            return (shouldBeSurrounded ? this._LEFT_PARENTHESIS : "")
                  + this.getStartElementHtml("span",
                   {
                       class: ASTHelper.CONST.EXPRESSION.AssignmentExpression + " node",
                       id: "node" + this.formatId(assignmentExpression.nodeId)
                   })
                + this.generateHtml(assignmentExpression.left)
                + " " + assignmentExpression.operator + " "
                + this.generateHtml(assignmentExpression.right)
                + this.getEndElementHtml("span")
                + (shouldBeSurrounded ? this._RIGHT_PARENTHESIS : "");
        },

        generateFromUnaryExpression: function(unaryExpression)
        {
            var html = this.getStartElementHtml("span",
            {
                class: ASTHelper.CONST.EXPRESSION.UnaryExpression + " node",
                id: "node" + this.formatId(unaryExpression.nodeId)
            });

            if(unaryExpression.prefix) { html += unaryExpression.operator; }

            if(unaryExpression.operator == "typeof"
            || unaryExpression.operator == "void"
            || unaryExpression.operator == "delete")
            {
                html += " ";
            }

            var isComplexArgument = !(ASTHelper.isLiteral(unaryExpression.argument) || ASTHelper.isIdentifier(unaryExpression.argument));

            html += (isComplexArgument ? this._LEFT_PARENTHESIS : "")
                        + this.generateExpression(unaryExpression.argument)
                   + (isComplexArgument ? this._RIGHT_PARENTHESIS : "");

            if(!unaryExpression.prefix) { html += unaryExpression.operator; }

            html += this.getEndElementHtml("span");

            return html;
        },

        generateFromBinaryExpression: function(binaryExpression)
        {
            return this.getStartElementHtml("span",
                   {
                       class: ASTHelper.CONST.EXPRESSION.BinaryExpression + " node",
                       id: "node" + this.formatId(binaryExpression.nodeId)
                   })
                   + this.generateHtml(binaryExpression.left)
                   + " " + binaryExpression.operator + " "
                   + this.generateHtml(binaryExpression.right)
                   + this.getEndElementHtml("span");
        },

        generateFromLogicalExpression: function(logicalExpression)
        {
            var _class = ASTHelper.CONST.EXPRESSION.LogicalExpression + " node";
            var _id = "node" + this.formatId(logicalExpression.nodeId);

            var shouldBeSurrounded = ASTHelper.isBinaryExpression(logicalExpression.parent)
                                 || (ASTHelper.isLogicalExpression(logicalExpression.parent) && logicalExpression.parent.operator != logicalExpression.operator)
                                 || (ASTHelper.isCallExpression(logicalExpression.parent) && logicalExpression.parent.callee == logicalExpression);

            return (shouldBeSurrounded ? this._LEFT_PARENTHESIS : "")
                  + this.getStartElementHtml("span",
                   {
                       class: _class,
                       id: _id
                   })
                 + this.generateHtml(logicalExpression.left)
                 + " " + logicalExpression.operator + " "
                 + this.generateHtml(logicalExpression.right)
                 + this.getEndElementHtml("span")
                 + (shouldBeSurrounded ? this._RIGHT_PARENTHESIS : "")
        },

        generateFromUpdateExpression: function(updateExpression)
        {
            var html = this.getStartElementHtml("span",
            {
                class: ASTHelper.CONST.EXPRESSION.UpdateExpression + " node",
                id: "node" + this.formatId(updateExpression.nodeId)
            });

            // if prefixed e.g.: ++i
            if(updateExpression.prefix) html += updateExpression.operator;

            html += this.generateHtml(updateExpression.argument);

            // if postfixed e.g.: i++
            if(!updateExpression.prefix) html += updateExpression.operator;

            return html + this.getEndElementHtml("span");
        },

        generateFromNewExpression: function(newExpression)
        {
            return this.getStartElementHtml("span",
                       {
                           class: ASTHelper.CONST.EXPRESSION.NewExpression + " node",
                           id: "node" + this.formatId(newExpression.nodeId)
                       })
                     + this.getElementHtml("span", {class: "keyword"}, "new ")
                     + this.generateHtml(newExpression.callee)
                     + this._LEFT_PARENTHESIS
                        + this.getSequenceHtml(newExpression.arguments)
                     + this._RIGHT_PARENTHESIS
                     + this.getEndElementHtml("span");
        },

        generateFromConditionalExpression: function(conditionalExpression)
        {
            var shouldBeSurrounded = ASTHelper.isBinaryExpression(conditionalExpression.parent)
                                  || ASTHelper.isLogicalExpression(conditionalExpression.parent)
                                  || ASTHelper.isCallExpressionCallee(conditionalExpression);

            return (shouldBeSurrounded ? this._LEFT_PARENTHESIS : "")
                   + this.getStartElementHtml("span",
                     {
                         class: ASTHelper.CONST.EXPRESSION.ConditionalExpression + " node",
                         id: "node" + this.formatId(conditionalExpression.nodeId)
                     })
                   + this.generateHtml(conditionalExpression.test)
                   + " ? " + this.generateHtml(conditionalExpression.consequent)
                   + " : " + this.generateHtml(conditionalExpression.alternate)
                   + this.getEndElementHtml("span")
                   + (shouldBeSurrounded ? this._RIGHT_PARENTHESIS : "");
        },

        generateFromThisExpression: function(thisExpression)
        {
            return this.getElementHtml("span",
            {
                class: "keyword node",
                id: "node" + this.formatId(thisExpression.nodeId)
            }, "this");
        },

        generateFromCallExpression: function(callExpression)
        {
            return this.getStartElementHtml("span",
                   {
                       class: ASTHelper.CONST.EXPRESSION.CallExpression + " node",
                       id: "node" + this.formatId(callExpression.nodeId)
                   })
                 + this.generateHtml(callExpression.callee) + this._LEFT_PARENTHESIS
                 + this.getSequenceHtml(callExpression.arguments)
                 + this._RIGHT_PARENTHESIS + this.getEndElementHtml("span");
        },

        generateFromMemberExpression: function(memberExpression)
        {
            var isNotSimpleMemberExpression = !ASTHelper.isIdentifier(memberExpression.object)
                                            &&!ASTHelper.isCallExpression(memberExpression.object)
                                            &&!ASTHelper.isThisExpression(memberExpression.object)
                                            &&!ASTHelper.isMemberExpression(memberExpression.object);

            var html = this.getStartElementHtml("span",
                       {
                          class: ASTHelper.CONST.EXPRESSION.MemberExpression + " node",
                          id: "node" + this.formatId(memberExpression.nodeId)
                       })
                     + this.generateHtml(memberExpression.object);

            var isPropertyStringLiteral = ASTHelper.isStringLiteral(memberExpression.property);

            if(memberExpression.computed || isPropertyStringLiteral)
            {
                html += this._LEFT_BRACKET
                        + (isPropertyStringLiteral ? "'" : "")
                        +  this.generateHtml(memberExpression.property)
                        + (isPropertyStringLiteral ? "'" : "")
                      + this._RIGHT_BRACKET;
            }
            else
            {
                html += "." + this.generateHtml(memberExpression.property);
            }

            return (isNotSimpleMemberExpression ? this._LEFT_PARENTHESIS : "")
                   + html + this.getEndElementHtml("span")
                   + (isNotSimpleMemberExpression ? this._RIGHT_PARENTHESIS : "")
        },

        generateFromSequenceExpression: function(sequenceExpression)
        {
            return this.getStartElementHtml("span",
                   {
                       class: ASTHelper.CONST.EXPRESSION.SequenceExpression + " node",
                       id: "node" + this.formatId(sequenceExpression.nodeId)
                   })
                   + this.getSequenceHtml(sequenceExpression.expressions)
                   + this.getEndElementHtml("span");
        },

        generateFromArrayExpression: function(arrayExpression)
        {
            return this.getStartElementHtml("span",
                   {
                       class: ASTHelper.CONST.EXPRESSION.ArrayExpression + " node",
                       id: "node" + this.formatId(arrayExpression.nodeId)
                   })
                   + this._LEFT_BRACKET
                        + this.getSequenceHtml(arrayExpression.elements)
                   + this._RIGHT_BRACKET
                   + this.getEndElementHtml("span");
        },

        generateFromObjectExpression: function(objectExpression)
        {
            var _style = this.getStyle(objectExpression);
            var _id = "node" + this.formatId(objectExpression.nodeId);
            var _class = ASTHelper.CONST.EXPRESSION.ObjectExpression + " node";

            var _containerStyle = "display: block";
            var _propertyContainerStyle = "";

            var _isEmptyObject = objectExpression.properties.length == 0;

            var _hasGettersOrSetters = false;
            var _hasMoreThanTwoProperties = objectExpression.properties.length > 2;
            var _hasFunctionExpressions = false;

            var properties = objectExpression.properties;

            for(var i = 0; i < properties.length; i++)
            {
                var property = properties[i];

                if (property.kind == "get" || property.kind == "set")
                {
                    _hasGettersOrSetters = true;
                }

                if (ASTHelper.isFunctionExpression(property.value))
                {
                    _hasFunctionExpressions = true;
                }
            }


            if (_isEmptyObject == true || (_hasMoreThanTwoProperties == false && _hasFunctionExpressions == false && _hasGettersOrSetters == false))
            {
                _containerStyle = "display: inline;";
                _propertyContainerStyle = "display: inline;";
            }
            else
            {
                _containerStyle = "display: block;";
                _propertyContainerStyle = "display: block; padding-left: 20px;";
            }

            var html = this.getStartElementHtml("div", { class: _class, style: _containerStyle, id: _id });

            if (_isEmptyObject) { html += "{}"; }
            else
            {
                html += '{';

                for (var i = 0; i < properties.length; i++)
                {
                    var property = properties[i];

                    html += '<div class="objectProperty" id="node' + this.formatId(property.nodeId) +  '" style ="' + _propertyContainerStyle + '">';

                    if (property.kind == "init")
                    {
                        html += this.generateHtml(property.key) + ': '
                              + this.generateHtml(property.value);
                    }
                    else
                    {
                        html += this.getElementHtml("span", {class: "keyword"}, property.kind) + " " + this.generateHtml(property.key)
                              + this.generateExpression(property.value);
                    }


                    if(i != properties.length - 1) { html += ", "; }

                    html += '</div>';
                }

                html += '}'
            }

            return html + this.getEndElementHtml("div");
        },

        generateFromIfStatement: function(ifStatement)
        {
            var _class = ASTHelper.CONST.STATEMENT.IfStatement + " node" + this._generateHasBeenExecutedClass(ifStatement);
            var _id = "node" + this.formatId(ifStatement.nodeId);
            var _style = "display: inline";

            var html = this.getStartElementHtml("div", {class: _class, style: _style, id: _id})
                + this.getElementHtml("span", {class:"keyword"}, "if")
                + " (" + this.generateHtml(ifStatement.test) + ") ";

            if(!ASTHelper.isBlockStatement(ifStatement.consequent))
                html += "<br>";

            html += this.generateHtml(ifStatement.consequent);

            if(ifStatement.alternate != null)
            {
                html += this.getElementHtml("span", {class:"keyword", style:"margin-left:20px"}, "else ")
                    + this.generateHtml(ifStatement.alternate);
            }

            html += this.getEndElementHtml("div");

            return html;
        },

        generateFromWhileStatement: function(whileStatement)
        {
            var _class = ASTHelper.CONST.STATEMENT.WhileStatement + " node" + this._generateHasBeenExecutedClass(whileStatement);
            var _id = "node" + this.formatId(whileStatement.nodeId);

            var html = this.getStartElementHtml("div", {class: _class, id: _id})
                + this.getElementHtml("span", {class:"keyword"}, "while")
                + "(" + this.generateHtml(whileStatement.test) + ")  ";

            html += this.generateHtml(whileStatement.body)
                + this.getEndElementHtml("div");

            return html;
        },

        generateFromDoWhileStatement: function(doWhileStatement)
        {
            var _class = ASTHelper.CONST.STATEMENT.DoWhileStatement + " node" + this._generateHasBeenExecutedClass(doWhileStatement);
            var _id = "node" + this.formatId(doWhileStatement.nodeId);

            var html = this.getStartElementHtml("div", {class: _class, id: _id})
                + this.getElementHtml("span", {class:"keyword"}, "do");

            if(!ASTHelper.isBlockStatement(doWhileStatement.body))
                html += "<br>";

            html += this.generateHtml(doWhileStatement.body);

            html += this.getElementHtml("span", {class:"keyword"}, "while")
                + " (" + this.generateHtml(doWhileStatement.test) + ")"
                + this.getEndElementHtml("div");

            return html;
        },

        generateFromForStatement: function(forStatement)
        {
            var _class = ASTHelper.CONST.STATEMENT.ForStatement + " node" + this._generateHasBeenExecutedClass(forStatement);
            var _id = "node" + this.formatId(forStatement.nodeId);

            var html = this.getStartElementHtml("div", {class: _class, id: _id});

            html += this.getElementHtml("span", {class:"keyword"}, "for") + " "
                + "(" + this.generateHtml(forStatement.init) + "; "
                + this.generateHtml(forStatement.test) + "; "
                + this.generateHtml(forStatement.update) + ") "
                + this.generateHtml(forStatement.body);

            html += this.getEndElementHtml("div");

            return html;
        },

        generateFromForInStatement: function(forInStatement)
        {
            if(!ASTHelper.isForInStatement(forInStatement))
            {
                alert("Invalid element when generating for...in statement html code!");
                return "";
            }

            var _class = ASTHelper.CONST.STATEMENT.ForInStatement + " node" + this._generateHasBeenExecutedClass(forInStatement);
            var _id = "node" + this.formatId(forInStatement.nodeId);

            var html = this.getStartElementHtml("div", {class: _class, id: _id});

            html += this.getElementHtml("span", {class:"keyword"}, "for") + " ";

            if(forInStatement.each === true) html += this.getElementHtml("span", {class:"keyword"}, "each") + " ";

            html += "(" + this.generateHtml(forInStatement.left)
                + " in " + this.generateExpression(forInStatement.right) + ")";

            if(!ASTHelper.isBlockStatement(forInStatement.body))
                html += "<br>";

            html += this.generateStatement(forInStatement.body);

            html += this.getEndElementHtml("div");

            return html;
        },

        generateFromBreakStatement: function(breakStatement)
        {
            if(!ASTHelper.isBreakStatement(breakStatement))
            {
                alert("Invalid element when generating break statement html code!");
                return "";
            }

            var _class = ASTHelper.CONST.STATEMENT.BreakStatement + " node" + this._generateHasBeenExecutedClass(breakStatement);
            var _id = "node" + this.formatId(breakStatement.nodeId);
            var _style = this.getStyle(breakStatement);

            var html = this.getStartElementHtml("div", {class: _class, id: _id, style: _style})
                + this.getElementHtml("span", {class:"keyword"}, "break");

            if(breakStatement.label != null) html += " " + this.generateFromIdentifier(breakStatement.label);

            html += ";" + this.getEndElementHtml("div");

            return html;
        },

        generateFromContinueStatement: function(continueStatement)
        {
            var _class =  ASTHelper.CONST.STATEMENT.ContinueStatement + " node";
            var _id = "node" + this.formatId(continueStatement.nodeId);
            var _style = this.getStyle(continueStatement);

            var html = this.getStartElementHtml("div", {class: _class, id: _id, style: _style})
                + this.getElementHtml("span", {class:"keyword"}, "continue");

            if(continueStatement.label != null) html += " " + this.generateFromIdentifier(continueStatement.label);

            html += ";" + this.getEndElementHtml("div");

            return html;
        },

        generateFromReturnStatement: function(returnStatement)
        {
            var _class = ASTHelper.CONST.STATEMENT.ReturnStatement + " node" + this._generateHasBeenExecutedClass(returnStatement);
            var _id = "node" + this.formatId(returnStatement.nodeId);
            var _style = this.getStyle(returnStatement);

            var html = this.getStartElementHtml("div", {class: _class, id: _id, style: _style})
                + this.getElementHtml("span", {class:"keyword"}, "return");

            if(returnStatement.argument != null) html += " " + this.generateExpression(returnStatement.argument);

            html += ";" + this.getEndElementHtml("div");

            return html;
        },

        generateFromWithStatement: function(withStatement)
        {
            var _class = ASTHelper.CONST.STATEMENT.WithStatement + " node" + this._generateHasBeenExecutedClass(withStatement);
            var _id = "node" + this.formatId(withStatement.nodeId);

            return this.getStartElementHtml("div", {class: _class, id: _id})
                + this.getElementHtml("span", {class:"keyword"}, "with") + " ("
                + this.generateExpression(withStatement.object) + ")"
                + this.generateStatement(withStatement.body)
                + this.getEndElementHtml("div");
        },

        generateFromThrowStatement: function(throwStatement)
        {
            var _class = ASTHelper.CONST.STATEMENT.ThrowStatement + " node";
            var _id =  "node" + this.formatId(throwStatement.nodeId);

            var html = this.getStartElementHtml("div", {class: _class, id: _id})
                + this.getElementHtml("span", {class: "keyword"}, "throw")
                + " " + this.generateExpression(throwStatement.argument)
                + ";" + this.getEndElementHtml("div");

            return html;
        },

        generateFromSwitchStatement: function(switchStatement)
        {
            var _class = ASTHelper.CONST.STATEMENT.SwitchStatement + " node" + this._generateHasBeenExecutedClass(switchStatement);
            var _id = "node" + this.formatId(switchStatement.nodeId);

            var html = this.getStartElementHtml("div", {class: _class, id: _id})
                + this.getElementHtml("span", {class: "keyword"}, "switch")
                + " (" + this.generateExpression(switchStatement.discriminant) + ")"
                + "<br>";

            html += this.getElementHtml("div", {class: "Bracket"}, "{");

            for(var i = 0; i < switchStatement.cases.length; i++)
            {
                html += this.generateFromSwitchCase(switchStatement.cases[i]);
            }

            html += this.getElementHtml("div", {class: "Bracket"}, "}");

            html += this.getEndElementHtml("div");

            return html;
        },

        generateFromSwitchCase: function(switchCase)
        {
            var _class = ASTHelper.CONST.SwitchCase + " node" + this._generateHasBeenExecutedClass(switchCase);
            var _id = "node" + this.formatId(switchCase.nodeId);
            var _style =  "padding-left: 20px;";

            var html = this.getStartElementHtml("div", {class: _class, style: _style,id: _id})
                + " ";

            if(switchCase.test === null) html += "default:<br>";
            else html += "case " + this.generateExpression(switchCase.test) + ":<br>";

            for(var i = 0; i < switchCase.consequent.length; i++)
            {
                html += this.generateHtml(switchCase.consequent[i]);
            }

            html += this.getEndElementHtml("div");

            return html;
        },

        generateFromTryStatement: function(tryStatement)
        {
            var _class = ASTHelper.CONST.STATEMENT.TryStatement  + " node" + this._generateHasBeenExecutedClass(tryStatement);
            var _id = "node" + this.formatId(tryStatement.nodeId);

            var html = this.getStartElementHtml("div", {class: _class, id: _id})
                + this.getElementHtml("span", {class:"keyword"}, "try")
                + this.generateHtml(tryStatement.block);

            var handlers = tryStatement.handlers || (ValueTypeHelper.isArray(tryStatement.handler) ? tryStatement.handler : [tryStatement.handler]);
            // catch clauses
            for(var i = 0; i < handlers.length; i++)
            {
                html += this.generateFromCatchClause(handlers[i]);
            }

            if(tryStatement.finalizer != null)
            {
                html += this.getElementHtml("span", {class:"keyword"}, "finally")
                    + this.generateHtml(tryStatement.finalizer);
            }

            return html + this.getEndElementHtml("div");
        },

        generateFromLabeledStatement: function(labeledStatement)
        {
            var _class = ASTHelper.CONST.STATEMENT.LabeledStatement + " node" + this._generateHasBeenExecutedClass(labeledStatement);
            var _id = "node" + this.formatId(labeledStatement.nodeId);

            var html = this.getStartElementHtml("div", {class: _class, id: _id})
                + this.generateFromIdentifier(labeledStatement.label) + ": "
                + this.generateHtml(labeledStatement.body)
                + this.getEndElementHtml("div");

            return html;
        },

        generateFromVariableDeclaration: function(variableDeclaration)
        {
            var html = "";

            var _class = ASTHelper.CONST.VariableDeclaration + " node" + this._generateHasBeenExecutedClass(variableDeclaration);
            var _id = "node" + this.formatId(variableDeclaration.nodeId);

            html += this.getStartElementHtml("span", {class: _class, id: _id});
            html += this.getElementHtml("span", {class:"keyword"}, variableDeclaration.kind);
            html += " ";

            for (var i = 0; i < variableDeclaration.declarations.length; i++)
            {
                var previousDeclarator = i == 0 ? variableDeclaration : variableDeclaration.declarations[i - 1];
                var currentDeclarator = variableDeclaration.declarations[i];

                if (previousDeclarator != variableDeclaration)
                {
                    html += ", ";
                }

                html += this.generateFromVariableDeclarator(currentDeclarator);
            }

            if (ASTHelper.isForStatement(variableDeclaration.parent) || ASTHelper.isForInStatement(variableDeclaration.parent))
            {
                html += this.getEndElementHtml("span");
            }
            else
            {
                html += ";" + this.getEndElementHtml("span") + "<br>";
            }

            return html;
        },

        generateFromVariableDeclarator: function(variableDeclarator)
        {
            var html = this.getStartElementHtml
            (
                "span",
                {
                    class: ASTHelper.CONST.VariableDeclarator,
                    id: "node" + this.formatId(variableDeclarator.nodeId)
                }
            );

            html += this.generateFromPattern(variableDeclarator.id);

            if(variableDeclarator.init != null)
            {
                html += " = ";
                html += this.generateHtml(variableDeclarator.init);
            }

            return html + this.getEndElementHtml("span");
        },

        generateFromPattern: function(pattern)
        {
            if(ASTHelper.isIdentifier(pattern)) { return this.generateFromIdentifier(pattern);}
        },

        generateFromCatchClause: function(catchClause)
        {
            var _class = ASTHelper.CONST.CatchClause + " node" + this._generateHasBeenExecutedClass(catchClause);
            var _id = "node" + this.formatId(catchClause.nodeId);

            var html = this.getStartElementHtml("div", {class: _class, id: _id})
                + this.getElementHtml("span", {class: "keyword"}, "catch");

            html += " (" + this.generateHtml(catchClause.param);

            if(catchClause.guard != null) html += " if " + this.generateExpression(catchClause.guard);

            html += ")";
            html += this.generateStatement(catchClause.body);

            html += this.getEndElementHtml("div");

            return html;
        },

        generateFromIdentifier: function(identifier)
        {
            var _class = ASTHelper.CONST.Identifier + " node";
            var _id = "node" + this.formatId(identifier.nodeId);
            //var _padding = this.getStyle(identifier);

            //, style: _padding
            return this.getElementHtml("span", {class: _class, id: _id}, identifier.name);
        },

        generateFromLiteral: function(literal)
        {
            if (ValueTypeHelper.isString(literal.value))
            {
                return this.getElementHtml("span", {class: "String", id: "node" + this.formatId(literal.nodeId)}, "\"" + this.escapeHtml(literal.value) + "\"");
            }
            else if (ValueTypeHelper.isBoolean(literal.value) || ValueTypeHelper.isNull(literal.value))
            {
                return this.getElementHtml("span", {class: "Keyword", id: "node" + this.formatId(literal.nodeId)}, literal.value);
            }
            else if(ValueTypeHelper.isInteger(literal.value))
            {
                return this.getElementHtml("span", {class: "Number", id: "node" + this.formatId(literal.nodeId)}, literal.value);
            }
            else if(ValueTypeHelper.isObject(literal.value))
            {
                var regExString = "";

                if(literal.value.constructor != null && literal.value.constructor.name === "RegExp")
                {
                    regExString = literal.value.toString();
                }
                else //over JSON conversion
                {
                    regExString = atob(literal.value.RegExpBase64);
                }

                regExString = ValueTypeHelper.adjustForRegExBug(literal.value, regExString);

                return this.getElementHtml("span", {class: "RegExp", id: "node" + this.formatId(literal.nodeId)}, regExString );
            }
            else
            {
                return this.getElementHtml("span", {class: ASTHelper.CONST.Literal, id: "node" + this.formatId(literal.nodeId)}, literal.value);
            }
        },

        getSequenceHtml: function(sequence)
        {
            var html = "";

            for(var i = 0; i < sequence.length; i++)
            {
                if(i != 0) { html += ", "; }
                html += this.generateHtml(sequence[i]);
            }

            return html;
        },

        getElementHtml: function(elementType, attributes, content)
        {
            return this.getStartElementHtml(elementType, attributes) + content + this.getEndElementHtml(elementType);
        },

        getStartElementHtml: function(elementType, attributes)
        {
            var html = "<" + elementType + " ";

            for(var propertyName in attributes)
            {
                html += propertyName + " = '" + attributes[propertyName] + "' ";
            }

            html += ">";

            return html;
        },

        getEndElementHtml: function(elementType)
        {
            return "</" + elementType  + ">";
        },

        getStyle: function(currentElement)
        {
            if( ASTHelper.isLoopStatement(currentElement.parent)
             || ASTHelper.isIfStatement(currentElement.parent)
             || ASTHelper.isSwitchCase(currentElement.parent))
            {
                return "padding-left: 20px";
            }

            if (currentElement.type == "ObjectExpression")
            {

            }

            return "";
        },

        _generateHasBeenExecutedClass: function(expression)
        {
            if(expression == null) { return ""; }

            return (expression.hasBeenExecuted ? " hasBeenExecuted "
                                              : " hasNotBeenExecuted ")
                 + (expression.differsInExecution ? " differs " : "")
                 + (expression.shouldBeIncluded ? " hasBeenIncluded" : "hasNotBeenIncluded");
        },

        formatId: function(currentId)
        {
            if(currentId < 0)
            {
                alert("Invalid Node Identification: ID cannot be negative.)");
            }
            if(currentId > 999999)
            {
                alert("Invalid Node Identification: ID exceeds, but is limited to,  6 characters");
            }
            return ("00000" + currentId).slice(-6);
        },

        escapeHtml: function(string)
        {
            return string.replace(/&/g, "&amp;").replace(/>/g, "&gt;").replace(/</g, "&lt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;").replace(/\//, "&#47;");
        },

        _LEFT_GULL_WING:  "{",
        _RIGHT_GULL_WING: "}",
        _LEFT_PARENTHESIS: "(",
        _RIGHT_PARENTHESIS: ")",
        _LEFT_BRACKET : "[",
        _RIGHT_BRACKET: "]",
        _SEMI_COLON: ";",
        _QUESTION_MARK: "?",
        _COLON: ":",
        _DOT: ".",
        _COMMA: ",",
        _IF_KEYWORD: "if",
        _ELSE_KEYWORD: "else",
        _FOR_KEYWORD: "for",
        _WHILE_KEYWORD: "while",
        _DO_KEYWORD: "do",
        _WITH_KEYWORD: "with",
        _IN_KEYWORD: "in",
        _FUNCTION_KEYWORD: "function",
        _BREAK_KEYWORD: "break",
        _CONTINUE_KEYWORD: "continue",
        _TRY_KEYWORD: "try",
        _CATCH_KEYWORD: "catch",
        _FINALLY_KEYWORD: "finally",
        _THROW_KEYWORD: "throw",
        _RETURN_KEYWORD: "return",
        _VAR_KEYWORD: "var",
        _SWITCH_KEYWORD: "switch",
        _CASE_KEYWORD: "case",
        _DEFAULT_KEYWORD: "default"
    }
}});

if(usesModule)
{
    exports.CodeMarkupGenerator = CodeMarkupGenerator;
}var usesModule = typeof module !== 'undefined' && module.exports;
if(usesModule)
{
    FBL =  { Firecrow: { includeNode: function(node) { if(node) { node.shouldBeIncluded = true; } }}, ns:  function(namespaceFunction){ namespaceFunction(); }};
    atob = require("atob");
}
var CodeTextGenerator;
FBL.ns(function () { with (FBL) {
/*******/
var ASTHelper = Firecrow.ASTHelper;
var ValueTypeHelper = Firecrow.ValueTypeHelper;

if(ValueTypeHelper == null && usesModule)
{
    var path = require('path');
    ValueTypeHelper = require(path.resolve(__dirname, "../helpers/valueTypeHelper.js")).ValueTypeHelper;
}

if(ASTHelper == null && usesModule)
{
    ASTHelper = require(path.resolve(__dirname, "../helpers/ASTHelper.js")).ASTHelper;
}

Firecrow.CodeTextGenerator = CodeTextGenerator = function(isSlicing)
{
    this.isSlicing = !!isSlicing;
};

Firecrow.CodeTextGenerator.generateSlicedCode = function(model)
{
    var codeGenerator = new Firecrow.CodeTextGenerator(true);

    return codeGenerator.generateCode(model);
}

Firecrow.CodeTextGenerator.generateProfiledCode = function(model)
{
    ASTHelper.traverseAst(model.htmlElement, function(element)
    {
        if(element.hasBeenExecuted)
        {
            if(ASTHelper.isFunctionParameter(element))
            {
                if(element.parent.shouldBeIncluded || element.parent.hasBeenExecuted)
                {
                    Firecrow.includeNode(element);
                }
            }

            if(ASTHelper.isForInStatement(element.parent))
            {
                Firecrow.includeNode(element.parent);
                Firecrow.includeNode(element.parent.right);
            }

            if(element.hasBeenExecuted)
            {
                Firecrow.includeNode(element);
            }
        }
    });

    var postProcessor = new Firecrow.DependencyGraph.DependencyPostprocessor();
    postProcessor.processHtmlElement(model.htmlElement);

    var codeGenerator = new Firecrow.CodeTextGenerator(true);

    return codeGenerator.generateCode(model);
};

Firecrow.CodeTextGenerator.generateStandAloneCode = function(model)
{
    var codeGenerator = new Firecrow.CodeTextGenerator();

    return codeGenerator.generateStandAloneCode(model);
};

Firecrow.CodeTextGenerator.generateCode = function(model)
{
    var codeGenerator = new Firecrow.CodeTextGenerator();

    return codeGenerator.generateCode(model);
};

Firecrow.CodeTextGenerator.generateJsCode = function(model)
{
    var codeGenerator = new Firecrow.CodeTextGenerator();

    return codeGenerator.generateJsCode(model);
};

Firecrow.gen = Firecrow.CodeTextGenerator.generateJsCode;

Firecrow.CodeTextGenerator.notifyError = function(message)
{
    console.warn("CodeTextGenerator - " + message);
};

Firecrow.CodeTextGenerator.prototype =
{
    generateCode: function(model)
    {
        try
        {
            return this.generateDocumentType(model.docType) + this.newLine
                 + this.generateCodeFromHtmlElement(model.htmlElement, "root");
        }
        catch(e)
        {
            this.notifyError("Error when generating code: " + e);
        }
    },

    generateDocumentType: function(documentType)
    {
        var docTypeHtml = "<!DOCTYPE html";

             if (documentType === "http://www.w3.org/TR/html4/strict.dtd") { docTypeHtml += ' PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"';}
        else if (documentType === "http://www.w3.org/TR/html4/loose.dtd") { docTypeHtml += ' PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"'; }
        else if (documentType === "http://www.w3.org/TR/html4/frameset.dtd") { docTypeHtml += ' PUBLIC "-//W3C//DTD HTML 4.01 Frameset//EN" "http://www.w3.org/TR/html4/frameset.dtd"'; }
        else if (documentType === "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd") { docTypeHtml += ' PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"'; }
        else if (documentType === "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd") { docTypeHtml += ' PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"'; }
        else if (documentType === "http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd") { docTypeHtml += ' PUBLIC "-//W3C//DTD XHTML 1.0 Frameset//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd"'; }
        else if (documentType === "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd") { docTypeHtml += ' PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"'; }

        return docTypeHtml + ">";
    },

    emptyElementTypes: ["img", "br", "input", "meta", "link"],

    isEmptyElementType: function(type)
    {
       if(type == null) { return false; }

        return this.emptyElementTypes.indexOf(type) != -1;
    },

    generateCodeFromHtmlElement: function(htmlElement, origin)
    {
        try
        {
            var htmlElementContent = "";

            if(this.isSlicing && !htmlElement.shouldBeIncluded && htmlElement.type != "textNode"){ return htmlElementContent; }

            var htmlElementType = htmlElement.type != "link" ? htmlElement.type : "style";

            var code = this.generateStartHtmlTagString(htmlElementType)
                     + this.generateHtmlElementAttributes(htmlElement)
                     + (this.isEmptyElementType(htmlElementType) ? "/>" : ">");

            if(htmlElement.type == "html")
            {
                code += this.newLine;
            }

            if(htmlElement.type == "script")
            {
                this.indent();
                htmlElementContent = this.generateCodeFromScriptElement(htmlElement);
                this.deIndent();
            }
            else if(htmlElement.type == "style" || htmlElement.type == "link")
            {
                this.indent();
                htmlElementContent = this.generateCodeFromStyleElement(htmlElement);
                this.deIndent();
            }
            else if (htmlElement.type == "textNode")
            {
                return htmlElement.textContent;
            }
            else
            {
                var children = htmlElement.childNodes;

                if(children != null)
                {
                    for(var i = 0, length = children.length; i < length; i++)
                    {
                        htmlElementContent += this.generateCodeFromHtmlElement(children[i], "parent");
                    }
                }
            }

            if(htmlElement.type == "h3")
            {

            }

            return code + htmlElementContent + (htmlElementType == "html" ? this.newLine : "") + this.generateEndHtmlTagString(htmlElementType);
        }
        catch(e)
        {
            console.log("HTMLElement", htmlElement, "origin", origin, "Stack", e.stack);
            this.notifyError("Error when generating htmlElement: " + e);
        }
    },

    generateCodeFromScriptElement: function(scriptElement)
    {
        try
        {
            if(scriptElement != null && scriptElement.pathAndModel != null && scriptElement.pathAndModel.model != null)
            {
                return this.newLine + this.generateJsCode(scriptElement.pathAndModel.model);
            }

            if(scriptElement.sourceCode != null)
            {
                return this.newLine + scriptElement.sourceCode;
            }

            return "";
        }
        catch(e) { this.notifyError("Error when generating code from script element: " + e); }
    },

    generateStandAloneCode: function(element)
    {
        if (ASTHelper.isProgram(element)) { return this.generateProgram(element); }
        else if (ASTHelper.isStatement(element))
        {
            var isElseIfStatement = ASTHelper.isElseIfStatement(element);

            var statementCode = this.generateStatement(element);
            if(statementCode === "") { return ""; }

            return (!isElseIfStatement ? this.whitespace : "")
                + statementCode
                + (ASTHelper.isFunctionExpression(element.parent) ? "": this.newLine);
        }
        else if (ASTHelper.isFunction(element))
        {
            return (ASTHelper.isFunctionDeclaration(element) ? this.whitespace : "")
                + this.generateFromFunction(element);
        }
        else if (ASTHelper.isExpression(element)) { return this.generateExpression(element); }
        else if (ASTHelper.isSwitchCase(element)) { return this.generateFromSwitchCase(element); }
        else if (ASTHelper.isCatchClause(element)) { return this.generateFromCatchClause(element); }
        else if (ASTHelper.isVariableDeclaration(element))
        {
            var isForStatementInit = ASTHelper.isForStatementInit(element);

            var variableDeclarationCode = this.generateFromVariableDeclaration(element);

            if(isForStatementInit) { return variableDeclarationCode; }

            if(variableDeclarationCode == "") { return ""; }

            return this.whitespace + variableDeclarationCode + this._SEMI_COLON + this.newLine;
        }
        else if (ASTHelper.isVariableDeclarator(element)) { return this.generateFromVariableDeclarator(element); }
        else if (ASTHelper.isLiteral(element)) { return this.generateFromLiteral(element); }
        else if (ASTHelper.isIdentifier(element)) { return this.generateFromIdentifier(element); }
        else if (ASTHelper.isObjectExpressionPropertyValue(element)) { return this.generateFromObjectExpressionProperty(element); }
        else if (element != null) { return this.generateCodeFromHtmlElement(element, "standalone"); }

        return "";
    },

    generateJsCode: function(element)
    {
        try
        {
            if(element == null || (this.isSlicing && !element.shouldBeIncluded)) { return "";}

                 if (ASTHelper.isProgram(element)) { return this.generateProgram(element); }
            else if (ASTHelper.isStatement(element))
            {
                var isElseIfStatement = ASTHelper.isElseIfStatement(element);

                var statementCode = this.generateStandAloneCode(element);

                if(element.comments != null)
                {
                    var commentText = "/*";
                    element.comments.forEach(function(comment)
                    {
                        if(commentText.indexOf(comment) == -1)
                        {
                            commentText += comment + "; ";
                        }
                    }, this);
                    commentText += "*/"

                    if(ASTHelper.isLoopStatement(element) || ASTHelper.isIfStatement(element))
                    {
                        statementCode = commentText + this.newLine + this.whitespace + statementCode;
                    }
                    else
                    {
                        statementCode += commentText;
                    }
                }

                return statementCode;
            }
            else if (ASTHelper.isFunction(element))
            {
                return (ASTHelper.isFunctionDeclaration(element) ? this.whitespace : "")
                     + this.generateFromFunction(element);
            }
            else if (ASTHelper.isExpression(element)) { return this.generateExpression(element); }
            else if (ASTHelper.isSwitchCase(element)) { return this.generateFromSwitchCase(element); }
            else if (ASTHelper.isCatchClause(element)) { return this.generateFromCatchClause(element); }
            else if (ASTHelper.isVariableDeclaration(element))
            {
                var isForStatementInit = ASTHelper.isForStatementInit(element);

                var variableDeclarationCode = this.generateFromVariableDeclaration(element);

                if(element.comments != null)
                {
                    variableDeclarationCode += "/*";
                    element.comments.forEach(function(comment)
                    {
                        variableDeclarationCode += comment + "; ";
                    }, this);
                    variableDeclarationCode += "*/"
                }

                if(isForStatementInit) { return variableDeclarationCode; }
                if(variableDeclarationCode == "") { return ""; }

                return this.whitespace + variableDeclarationCode + this._SEMI_COLON + this.newLine;
            }
            else if (ASTHelper.isVariableDeclarator(element)) { return this.generateFromVariableDeclarator(element); }
            else if (ASTHelper.isLiteral(element)) { return this.generateFromLiteral(element); }
            else if (ASTHelper.isIdentifier(element)) { return this.generateFromIdentifier(element); }
            else if (ASTHelper.isObjectExpressionPropertyValue(element)) { return this.generateFromObjectExpressionProperty(element); }
            else
            {
                this.notifyError("Error while generating code unidentified ast element: "); return "";
            }
        }
        catch(e)
        {
            this.notifyError("Error while generating code: " + e + e.stack);
        }
    },

    generateProgram: function(programElement)
    {
        try
        {
            var code = "";

            if(programElement.body != null)
            {
                var body = programElement.body;

                for(var i = 0, length = body.length; i < length; i++)
                {
                    code += this.generateJsCode(body[i]);
                }
            }

            return code;
        }
        catch(e) { this.notifyError("Error when generating program: " + e); }
    },

    generateStatement: function(statement)
    {
        try
        {
            if(statement == null || (this.isSlicing && !statement.shouldBeIncluded)) { return "";}

                 if (ASTHelper.isEmptyStatement(statement))  { return this.generateFromEmptyStatement(statement); }
            else if (ASTHelper.isBlockStatement(statement)) { return this.generateFromBlockStatement(statement); }
            else if (ASTHelper.isExpressionStatement(statement))
            {
                var expressionStatementCode = this.generateFromExpressionStatement(statement);

                return expressionStatementCode != "" ? expressionStatementCode + this._SEMI_COLON
                                                     : "";
            }
            else if (ASTHelper.isIfStatement(statement)) { return this.generateFromIfStatement(statement); }
            else if (ASTHelper.isWhileStatement(statement)) { return this.generateFromWhileStatement(statement); }
            else if (ASTHelper.isDoWhileStatement(statement)) { return this.generateFromDoWhileStatement(statement); }
            else if (ASTHelper.isForStatement(statement)) { return this.generateFromForStatement(statement); }
            else if (ASTHelper.isForInStatement(statement)) { return this.generateFromForInStatement(statement); }
            else if (ASTHelper.isLabeledStatement(statement)) { return this.generateFromLabeledStatement(statement); }
            else if (ASTHelper.isBreakStatement(statement)) { return this.generateFromBreakStatement(statement) + this._SEMI_COLON ; }
            else if (ASTHelper.isContinueStatement(statement)) { return this.generateFromContinueStatement(statement) + this._SEMI_COLON ; }
            else if (ASTHelper.isReturnStatement(statement)) { return this.generateFromReturnStatement(statement)  + this._SEMI_COLON ; }
            else if (ASTHelper.isWithStatement(statement)) { return this.generateFromWithStatement(statement); }
            else if (ASTHelper.isTryStatement(statement)) { return this.generateFromTryStatement(statement); }
            else if (ASTHelper.isThrowStatement(statement)) { return this.generateFromThrowStatement(statement); }
            else if (ASTHelper.isSwitchStatement(statement)) { return this.generateFromSwitchStatement(statement); }
            else if (ASTHelper.isVariableDeclaration(statement)) { return this.generateFromVariableDeclaration(statement); }
            else { this.notifyError("Error: AST Statement element not defined: " + statement.type);  return "";}
        }
        catch(e)
        {
            this.notifyError("Error when generating code from a statement: " + e);
        }
    },

    generateExpression: function(expression)
    {
        try
        {
            if(expression == null || (this.isSlicing && !expression.shouldBeIncluded)) { return "";}

                 if (ASTHelper.isAssignmentExpression(expression)) { return this.generateFromAssignmentExpression(expression); }
            else if (ASTHelper.isUnaryExpression(expression)) { return this.generateFromUnaryExpression(expression); }
            else if (ASTHelper.isBinaryExpression(expression)) { return this.generateFromBinaryExpression(expression); }
            else if (ASTHelper.isLogicalExpression(expression)) { return this.generateFromLogicalExpression(expression); }
            else if (ASTHelper.isLiteral(expression)) { return this.generateFromLiteral(expression); }
            else if (ASTHelper.isIdentifier(expression)) { return this.generateFromIdentifier(expression); }
            else if (ASTHelper.isUpdateExpression(expression)) { return this.generateFromUpdateExpression(expression); }
            else if (ASTHelper.isNewExpression(expression)) { return this.generateFromNewExpression(expression); }
            else if (ASTHelper.isConditionalExpression(expression)) { return this.generateFromConditionalExpression(expression); }
            else if (ASTHelper.isThisExpression(expression)) { return this.generateFromThisExpression(expression); }
            else if (ASTHelper.isCallExpression(expression)) { return this.generateFromCallExpression(expression); }
            else if (ASTHelper.isMemberExpression(expression)) { return this.generateFromMemberExpression(expression); }
            else if (ASTHelper.isSequenceExpression(expression)) { return this.generateFromSequenceExpression(expression); }
            else if (ASTHelper.isArrayExpression(expression)) { return this.generateFromArrayExpression(expression); }
            else if (ASTHelper.isObjectExpression(expression)) { return this.generateFromObjectExpression(expression); }
            else if (ASTHelper.isFunctionExpression(expression)) { return this.generateFromFunction(expression, true); }
            else { this.notifyError("Error: AST Expression element not defined: " + expression.type);  return "";}
        }
        catch(e) { this.notifyError("Error when generating code from an expression:" + e); }
    },

    generateFromFunction: function(functionDecExp)
    {
        if(functionDecExp == null || (this.isSlicing && !functionDecExp.shouldBeIncluded)) { return "";}

        var functionBodyCode = this.generateFromFunctionBody(functionDecExp);
        if(functionBodyCode.trim() == "") { return ""; }
        var isFunctionBodyNotEmpty = functionBodyCode.trim() != "{}";


        var shouldBeInParentheses = ASTHelper.isFunctionExpression(functionDecExp)
                                 && ASTHelper.isCallExpressionCallee(functionDecExp);

        return (shouldBeInParentheses ? this._LEFT_PARENTHESIS : "")
             +  this._FUNCTION_KEYWORD + (functionDecExp.id != null ? " " + this.generateFromIdentifier(functionDecExp.id) : "")
             +  this.generateFunctionParameters(functionDecExp)
             +  (isFunctionBodyNotEmpty ? this.newLine + functionBodyCode : functionBodyCode.trim())
             +  (shouldBeInParentheses ? this._RIGHT_PARENTHESIS : "");
    },

    generateFunctionParameters: function(functionDecExp)
    {
        var code = this._LEFT_PARENTHESIS;

        var params = functionDecExp.params;

        if(params != null)
        {
            for(var i = 0, length = params.length; i < length; i++)
            {
                var param = params[i];

                if(i != 0) { code += ", "; }

                code += this.generateFromPattern(param);
            }
        }

        return code + this._RIGHT_PARENTHESIS;
    },

    generateFromFunctionBody: function(functionDeclExp)
    {
        return this.generateJsCode(functionDeclExp.body);
    },

    generateFromBlockStatement: function(blockStatement)
    {
        var code = "";

        this.indent();
        var body = blockStatement.body;

        if(body != null)
        {
            for(var i = 0, length = body.length; i < length; i++)
            {
                code += this.generateJsCode(body[i]);
            }
        }

        this.deIndent();

        if(code === "") { return this._LEFT_GULL_WING + this._RIGHT_GULL_WING; }

        code = code.replace(/((\r)?\n)+$/g, this.newLine);

        return this._LEFT_GULL_WING + this.newLine + code + this.whitespace + this._RIGHT_GULL_WING;
    },

    generateFromEmptyStatement: function(emptyStatement)
    {
        return this._SEMI_COLON;
    },

    generateFromExpressionStatement: function(expressionStatement)
    {
        return this.generateJsCode(expressionStatement.expression);
    },

    generateFromAssignmentExpression: function(assignmentExpression)
    {
        var leftSide = this.generateJsCode(assignmentExpression.left);
        var rightSide = this.generateJsCode(assignmentExpression.right);

        if(leftSide.length == 0) { return rightSide;}
        if(rightSide.length == 0) { return leftSide; }

        var shouldBeSurrounded = ASTHelper.isBinaryExpression(assignmentExpression.parent)
                              || ASTHelper.isLogicalExpression(assignmentExpression.parent);

        return (shouldBeSurrounded ? this._LEFT_PARENTHESIS : "") + leftSide + " " + assignmentExpression.operator + " " + rightSide + (shouldBeSurrounded ? this._RIGHT_PARENTHESIS : "");
    },

    generateFromUnaryExpression: function(unaryExpression)
    {
        var code = "";

        var expressionCode = this.generateExpression(unaryExpression.argument);

        if(unaryExpression.prefix) { code += unaryExpression.operator;}

        if(unaryExpression.operator == "typeof"
            || unaryExpression.operator == "void"
            || unaryExpression.operator == "delete") { code += " "; }

        var isComplexArgument = !(ASTHelper.isLiteral(unaryExpression.argument) || ASTHelper.isIdentifier(unaryExpression.argument));

        code += (isComplexArgument ? this._LEFT_PARENTHESIS : "")
                    + expressionCode
              + (isComplexArgument ? this._RIGHT_PARENTHESIS : "");

        if(!unaryExpression.prefix) { code += unaryExpression.operator; }

        return code;
    },

    generateFromBinaryExpression: function(binaryExpression)
    {
        var leftCode = this.generateJsCode(binaryExpression.left);
        var rightCode = this.generateJsCode(binaryExpression.right);

        var shouldBeSurrounded = ASTHelper.isBinaryExpression(binaryExpression.parent);

        if(leftCode.length != 0 && rightCode.length != 0)
        {
            return (shouldBeSurrounded ? this._LEFT_PARENTHESIS : "") + leftCode + " " + binaryExpression.operator + " " + rightCode + (shouldBeSurrounded ? this._RIGHT_PARENTHESIS : "");
        }

        if(leftCode.length != 0) { return leftCode; }
        if(rightCode.length != 0) { return rightCode; }

        return "";
    },

    generateFromLogicalExpression: function(logicalExpression)
    {
        var leftCode = this.generateJsCode(logicalExpression.left);
        var rightCode = this.generateJsCode(logicalExpression.right);

        var shouldBeSurrounded = ASTHelper.isBinaryExpression(logicalExpression.parent)
                              || (ASTHelper.isLogicalExpression(logicalExpression.parent) && logicalExpression.parent.operator != logicalExpression.operator)
                              || (ASTHelper.isCallExpression(logicalExpression.parent) && logicalExpression.parent.callee == logicalExpression);

        if(leftCode.length != 0 && rightCode.length != 0)
        {
            return (shouldBeSurrounded ? this._LEFT_PARENTHESIS : "") + leftCode + " " + logicalExpression.operator + " " + rightCode + (shouldBeSurrounded ? this._RIGHT_PARENTHESIS : "");
        }

        if(leftCode.length != 0) { return leftCode; }
        if(rightCode.length != 0) { return rightCode; }

        return "";
    },

    generateFromUpdateExpression: function(updateExpression)
    {
        var code = this.generateJsCode(updateExpression.argument);
        if(code.trim && code.trim() == "") { return ""; }

        if(updateExpression.prefix) { return updateExpression.operator + code;}
        else                        { return code + updateExpression.operator;}
    },

    generateFromNewExpression: function(newExpression)
    {
        return "new " + this.generateJsCode(newExpression.callee) + this._LEFT_PARENTHESIS
            + this.getSequenceCode(newExpression.arguments)
            + this._RIGHT_PARENTHESIS;
    },

    generateFromConditionalExpression: function(conditionalExpression)
    {
        var testCode = this.generateJsCode(conditionalExpression.test);
        var consequentCode = this.generateJsCode(conditionalExpression.consequent);
        var alternateCode = this.generateJsCode(conditionalExpression.alternate);

        if(testCode === "" && consequentCode === "" && alternateCode === "") { return ""; }

        if(testCode === "" && consequentCode !== "" && alternateCode === "") { testCode = "true"; alternateCode = "0";}
        if(testCode === "" && consequentCode === "" && alternateCode !== "") { testCode = "false"; consequentCode = "0"; }

        if(consequentCode === "") { consequentCode = "0"; }
        if(alternateCode === "") { alternateCode = "0";}

        var shouldBeSurroundedWithParenthesis = ASTHelper.isBinaryExpression(conditionalExpression.parent)
                                             || ASTHelper.isLogicalExpression(conditionalExpression.parent)
                                             || ASTHelper.isCallExpressionCallee(conditionalExpression);

        var code =  testCode + " " + this._QUESTION_MARK + " " + consequentCode
                             + " " + this._COLON + " " + alternateCode;

        return shouldBeSurroundedWithParenthesis ? (this._LEFT_PARENTHESIS + code + this._RIGHT_PARENTHESIS) : code;
    },

    generateFromThisExpression: function(thisExpression)
    {
        return "this";
    },

    generateFromCallExpression: function(callExpression)
    {
        var calleeCode = this.generateJsCode(callExpression.callee);
        var argumentsCode = this.getSequenceCode(callExpression.arguments);
        //TODO HACKY WAY
        if(calleeCode[calleeCode.length-1] == ".") { return calleeCode.substring(0, calleeCode.length-1); }
        if((ASTHelper.isMemberExpression(callExpression.callee) || ASTHelper.isCallExpression(callExpression.callee))
         && calleeCode[calleeCode.length-1] == ")" && this._areArgumentsNotIncluded(callExpression.arguments) && callExpression.isIncludedByPostprocessor)
        {
            return calleeCode;
        }
        //END HACKY
        return calleeCode
            +  this._LEFT_PARENTHESIS
                +  argumentsCode
            +  this._RIGHT_PARENTHESIS;
    },

    //Do NOT USE ELSEWHERE; except for a hack in generateFromCallExpression!
    _areArgumentsNotIncluded: function(arguments)
    {
        if(arguments == null || arguments.length == 0) { return true; }

        for(var i = 0; i < arguments.length; i++)
        {
            if(arguments[i].shouldBeIncluded) { return false; }
        }

        return true;
    },

    generateFromMemberExpression: function(memberExpression)
    {
        var isNotSimpleMemberExpression = !ASTHelper.isIdentifier(memberExpression.object)
                                        &&!ASTHelper.isCallExpression(memberExpression.object)
                                        &&!ASTHelper.isThisExpression(memberExpression.object)
                                        &&!ASTHelper.isMemberExpression(memberExpression.object);

        var propertyCode = this.generateJsCode(memberExpression.property);

        var isInBrackets = memberExpression.computed;

        if(!isInBrackets)
        {
            if(propertyCode.indexOf(' ') != -1 || propertyCode.indexOf("-") != -1
            || propertyCode.indexOf("*") != -1 || propertyCode.indexOf(":") != -1)
            {
                propertyCode = "'" + propertyCode + "'";
                isInBrackets = true;
            }
        }

        var objectCode = this.generateJsCode(memberExpression.object);

        if(objectCode === "") { return propertyCode;}
        if(propertyCode === "") { return objectCode; }

        return (isNotSimpleMemberExpression ? this._LEFT_PARENTHESIS : "") + objectCode + (isNotSimpleMemberExpression ? this._RIGHT_PARENTHESIS : "")
            + (isInBrackets ? ( propertyCode !== "" ? (this._LEFT_BRACKET + propertyCode + this._RIGHT_BRACKET) : "") : (this._DOT + propertyCode));
    },

    generateFromSequenceExpression: function(sequenceExpression)
    {
        var sequenceCode = this.getSequenceCode(sequenceExpression.expressions);

        if(!ASTHelper.isLoopStatement(sequenceExpression.parent))
        {
            sequenceCode = this._LEFT_PARENTHESIS + sequenceCode + this._RIGHT_PARENTHESIS;
        }

        return sequenceCode;
    },

    generateFromArrayExpression: function(arrayExpression)
    {
        return this._LEFT_BRACKET
                + this.getSequenceCode(arrayExpression.elements)
               + this._RIGHT_BRACKET;
    },

    generateFromObjectExpression: function(objectExpression)
    {
        if (objectExpression.properties == null || objectExpression.properties.length == 0) { return this._LEFT_GULL_WING + this._RIGHT_GULL_WING; }

        var code = this._LEFT_GULL_WING;
        var containsOnlySimpleProperties = this._objectExpressionContainsOnlySimpleProperties(objectExpression);

        if(!containsOnlySimpleProperties)
        {
            this.indent();
            code += this.newLine + this.whitespace;
        }

        var properties = objectExpression.properties;
        var generatedProperties = 0;
        for (var i = 0, length = properties.length; i < length; i++)
        {
            var property = properties[i];

            if(this.isSlicing && !property.shouldBeIncluded) { continue; }

            if(generatedProperties != 0)
            {
                code += ", " + (containsOnlySimpleProperties ? "" : this.newLine + this.whitespace);
            }

            code += this.generateFromObjectExpressionProperty(property);

            var lastGeneratedProperty = property;
            generatedProperties++;
        }

        if(lastGeneratedProperty != null && !containsOnlySimpleProperties) //&& ASTHelper.isFunctionExpression(lastGeneratedProperty.value))
        {
            code += this.newLine;
        }

        if(!containsOnlySimpleProperties)
        {
            this.deIndent();
            code += this.whitespace;
        }

        code += this._RIGHT_GULL_WING;

        return code;
    },

    generateFromObjectExpressionProperty: function(property)
    {
        try
        {
            if(this.isSlicing && !property.shouldBeIncluded) { return ""; }

            var code = "";

            if (property.kind == "init")
            {
                code += this.generateJsCode(property.key);
                var valueCode = this.generateJsCode(property.value);

                if(valueCode === "") { valueCode = "null"; }
                if(this.isSlicing && !property.shouldBeIncluded) {}
                else
                {
                    code += this._COLON + " " + valueCode;
                }
            }
            else
            {
                code += this.generateJsCode(property.key);

                if (ASTHelper.isFunctionExpression(property.value))
                    code += this.generateFromFunction(property.value);
                else
                    code += this.generateExpression(property.value);
            }

            return code;
        }
        catch(e) { this.notifyError("Error when generating from object expression property:" + e); }
    },

    _objectExpressionContainsOnlySimpleProperties: function(objectExpression)
    {
        try
        {
            var properties = objectExpression.properties;
            var generatedProperties = 0;
            for (var i = 0, length = properties.length; i < length; i++)
            {
                var property = properties[i];

                if(this.isSlicing && !property.shouldBeIncluded) { continue; }

                if(property.value != null && !ASTHelper.isLiteral(property.value))
                {
                    return false
                }
            }

            return true;
        }
        catch(e) { this.notifyError("Error when checking if object expression contains simple properties:" + e); }
    },

    generateFromIfStatement: function(ifStatement)
    {
        var ifBodyCode = this.generateJsCode(ifStatement.consequent);
        var testCode = this.generateJsCode(ifStatement.test);
        var elseBodyCode = "";
        var code = this._IF_KEYWORD + this._LEFT_PARENTHESIS + (testCode === "" ? "false" : testCode )  + this._RIGHT_PARENTHESIS;

        code += ifBodyCode.length != 0 ? this.newLine + ifBodyCode : this._SEMI_COLON + this.newLine;

        if(ifStatement.alternate != null)
        {
            if(this.isSlicing && !ifStatement.alternate.shouldBeIncluded)
            {
                if(ifBodyCode === "" && !ASTHelper.containsCallOrUpdateOrAssignmentExpression(ifStatement.test))
                {
                    return "";
                }

                return code;
            }

            elseBodyCode = this.generateJsCode(ifStatement.alternate);

            if(elseBodyCode !== "")
            {
                code += this.whitespace + this._ELSE_KEYWORD + " " + (! ASTHelper.isIfStatement(ifStatement.alternate) ? this.newLine : "") + elseBodyCode;
            }
        }

        return code;
    },

    generateFromWhileStatement: function(whileStatement)
    {
        var whileBody = this.generateJsCode(whileStatement.body);
        var whileTest = this.generateJsCode(whileStatement.test);

        if(whileBody === "" && !ASTHelper.containsCallOrUpdateOrAssignmentExpression(whileStatement.test)) { return ""; }

        if(whileTest === "") { whileTest = "false"; }

        return this._WHILE_KEYWORD + this._LEFT_PARENTHESIS + whileTest  + this._RIGHT_PARENTHESIS
            + (whileBody.length != 0 ? this.newLine + whileBody : this._SEMI_COLON);
    },

    generateFromDoWhileStatement: function(doWhileStatement)
    {
        var doWhileBody = this.generateJsCode(doWhileStatement.body);
        var doWhileTest = this.generateJsCode(doWhileStatement.test);

        if(doWhileBody === "" && !ASTHelper.containsCallOrUpdateOrAssignmentExpression(doWhileStatement.test)) { return ""; }
        if(doWhileTest === "") { doWhileTest = "false"; }

        doWhileBody = doWhileBody.length != 0 ? doWhileBody : this._SEMI_COLON;

        return this._DO_KEYWORD + this.newLine + doWhileBody
            +  this.whitespace + this._WHILE_KEYWORD + this._LEFT_PARENTHESIS + doWhileTest + this._RIGHT_PARENTHESIS;
    },

    generateFromForStatement: function(forStatement)
    {
        var forBody = this.generateJsCode(forStatement.body);
        var forInit = this.generateJsCode(forStatement.init);
        var forTest = this.generateJsCode(forStatement.test);
        var forUpdate = this.generateJsCode(forStatement.update);

        if(forBody === "" && forUpdate === "" && !ASTHelper.containsCallOrUpdateOrAssignmentExpression(forTest))
        {
            return forInit +  this._SEMI_COLON;
        }

        return this._FOR_KEYWORD + this._LEFT_PARENTHESIS
            +  forInit + this._SEMI_COLON
            +  forTest + this._SEMI_COLON
            +  forUpdate + this._RIGHT_PARENTHESIS
            +  (forBody.length != 0 ? (this.newLine + forBody) : this._SEMI_COLON);
    },

    generateFromForInStatement: function(forInStatement)
    {
        var forInBody = this.generateJsCode(forInStatement.body);
        var leftPart = this.generateJsCode(forInStatement.left);
        var rightPart = this.generateJsCode(forInStatement.right);

        if(leftPart === "" && forInBody === "") { return ""; }

        if(leftPart === "") { leftPart = Firecrow.CodeTextGenerator.generateJsCode(forInStatement.left); }

        forInBody = forInBody.length != 0 ? forInBody : this._SEMI_COLON;

        return this._FOR_KEYWORD + this._LEFT_PARENTHESIS
            +  leftPart + " " +  this._IN_KEYWORD + " "
            +  rightPart + this._RIGHT_PARENTHESIS
            +  this.newLine + forInBody;
    },

    generateFromBreakStatement: function(breakStatement)
    {
        return this._BREAK_KEYWORD + (breakStatement.label != null ? " " + this.generateFromIdentifier(breakStatement.label) : "");
    },

    generateFromContinueStatement: function(continueStatement)
    {
        return this._CONTINUE_KEYWORD + (continueStatement.label != null ? this.generateFromIdentifier(continueStatement.label) : "");
    },

    generateFromReturnStatement: function(returnStatement)
    {
        return this._RETURN_KEYWORD + " " + (returnStatement.argument != null ? this.generateExpression(returnStatement.argument) : "");
    },

    generateFromWithStatement: function(withStatement)
    {
        var withBody = this.generateStandAloneCode(withStatement.body);

        withBody = withBody.length != 0 ? withBody : this._SEMI_COLON;

        return this._WITH_KEYWORD + this._LEFT_PARENTHESIS
             + this.generateExpression(withStatement.object) + this._RIGHT_PARENTHESIS
             + withBody;
    },

    generateFromThrowStatement: function(throwStatement)
    {
        return this._THROW_KEYWORD + " " + this.generateExpression(throwStatement.argument);
    },

    generateFromSwitchStatement: function(switchStatement)
    {
        var discriminant = this.generateExpression(switchStatement.discriminant);

        var code = this._SWITCH_KEYWORD + this._LEFT_PARENTHESIS + (discriminant != "" ? discriminant : "null") + this._RIGHT_PARENTHESIS;

        code += this.newLine + this.whitespace + this._LEFT_GULL_WING + this.newLine;

        this.indent();

        for(var i = 0; i < switchStatement.cases.length; i++)
        {
            var caseClause = switchStatement.cases[i];

            if(this.isSlicing && !caseClause.shouldBeIncluded) { continue; }

            code += this.generateFromSwitchCase(caseClause);
        }

        this.deIndent();

        code += this.whitespace + this._RIGHT_GULL_WING;

        return code;
    },

    generateFromSwitchCase: function(switchCase)
    {
        var code = "";
        if(switchCase.test === null)
        {
            code += this.whitespace + this._DEFAULT_KEYWORD + this._COLON + this.newLine;
        }
        else
        {
            code += this.whitespace + this._CASE_KEYWORD + " " + this.generateExpression(switchCase.test) + this._COLON + this.newLine;
        }

        if(switchCase.consequent)
        {
            this.indent();

            for(var i = 0; i < switchCase.consequent.length; i++)
            {
                var statementCode = this.generateStandAloneCode(switchCase.consequent[i]);

                if(statementCode !== "")
                {
                    code += this.whitespace + statementCode + this.newLine;
                }
            }
            this.deIndent();
        }

        return code;
    },

    generateFromTryStatement: function(tryStatement)
    {
        var code = this._TRY_KEYWORD + this.newLine + (this.generateJsCode(tryStatement.block) || (this._LEFT_GULL_WING + this._RIGHT_GULL_WING));

        var handlers = tryStatement.handlers || (ValueTypeHelper.isArray(tryStatement.handler) ? tryStatement.handler : [tryStatement.handler]);

        if( handlers != null)
        {
            for(var i = 0; i < handlers.length; i++)
            {
                code += this.generateFromCatchClause(handlers[i]);
            }
        }

        if(tryStatement.finalizer != null)
        {
            var finalizerBody = this.generateJsCode(tryStatement.finalizer);

            if(finalizerBody.length != 0)
            {
                code += this._FINALLY_KEYWORD + finalizerBody;
            }
        }

        return code;
    },

    generateFromLabeledStatement: function(labeledStatement)
    {
        return this.generateFromIdentifier(labeledStatement.label) + this._COLON
             + this.generateJsCode(labeledStatement.body).replace(/^(\s)+/, " ");
    },

    generateFromVariableDeclaration: function(variableDeclaration)
    {
        var code = this._VAR_KEYWORD + " ";

        var declarators = variableDeclaration.declarations;
        var generatedDeclarators = 0;

        if(declarators == null || declarators.length == 0) { return ""; }

        for (var i = 0, length = declarators.length; i < length; i++)
        {
            var declarator = declarators[i];

            if(this.isSlicing && !declarator.shouldBeIncluded) { continue; }

            if(generatedDeclarators != 0) { code += this._COMMA + " "; }

            generatedDeclarators++;

            code += this.generateFromVariableDeclarator(declarator);
        }

        return code;
    },

    generateFromVariableDeclarator: function(variableDeclarator)
    {
        var initCode = "";

        if(variableDeclarator.init)
        {
            if(this.isSlicing && !variableDeclarator.init.shouldBeIncluded) {}
            else
            {
                initCode = " = " + this.generateJsCode(variableDeclarator.init);
            }
        }

        return this.generateFromPattern(variableDeclarator.id) + initCode;
    },

    generateFromPattern: function(pattern)
    {
        if(ASTHelper.isIdentifier(pattern)) { return this.generateFromIdentifier(pattern);}
    },

    generateFromCatchClause: function(catchClause)
    {
        if(catchClause == null) { return ""; }

        var body = this.generateStandAloneCode(catchClause.body);

        body = body.length != 0 ? body : this._LEFT_GULL_WING + this._RIGHT_GULL_WING;

        Firecrow.includeNode(catchClause.param);

        return this.whitespace + this._CATCH_KEYWORD + this._LEFT_PARENTHESIS + this.generateJsCode(catchClause.param) + this._RIGHT_PARENTHESIS
             + (body != (this._LEFT_GULL_WING + this._RIGHT_GULL_WING) ? this.newLine + this.whitespace : "" ) + body;
    },

    generateFromIdentifier: function(identifier)
    {
        return identifier.name;
    },

    generateFromLiteral: function(literal)
    {
        if(ValueTypeHelper.isNull(literal.value)) { return "null"; }
        if (ValueTypeHelper.isString(literal.value))
        {
            if(literal.raw != null)
            {
                return literal.raw;
            }

            return "'" + literal.value.replace(/\\/g, "\\\\").replace(/'/g, "\\'").replace(/\n/g, "\\n").replace(/\r/g, "\\r") + "'";
        }
        else if (ValueTypeHelper.isBoolean(literal.value) || ValueTypeHelper.isNumber(literal.value)) { return literal.value; }
        else if(ValueTypeHelper.isObject(literal.value))
        {
            var regExString = "";
            if(literal.value.constructor != null && literal.value.constructor.name === "RegExp")
            {
                regExString = literal.value.toString();
            }
            else //over JSON conversion
            {
                regExString = atob(literal.value.RegExpBase64);
            }

            return ValueTypeHelper.adjustForRegExBug(literal.value, regExString);
        }
    },

    getSequenceCode: function(sequence)
    {
        try
        {
            var code = "";

            if(sequence == null) { return code; }

            for(var i = 0, length = sequence.length; i < length; i++)
            {
                var item = sequence[i];

                if(i != 0 && code.trim() != "") { code += this._COMMA +  " "; }

                if(this.isSlicing && !item.shouldBeIncluded)
                {
                    code += "null";
                    continue;
                }

                code += this.generateJsCode(item);
            }

            return code;
        }
        catch(e)
        {
            this.notifyError("Error when generating sequence code:" + e);
        }
    },

    generateCodeFromStyleElement: function(styleElement)
    {
        try
        {
            var cssText = "";

            var rules = styleElement.cssRules || [];

            this.indent();

            for(var i = 0, length = rules.length; i < length; i++)
            {
                var rule = rules[i];

                if(this.isSlicing && !rule.shouldBeIncluded) { continue; }

                cssText += this.newLine + this.whitespace + rule.cssText;
            }

            if(cssText !== "") { cssText += this.newLine;}

            this.deIndent();

            return cssText;
        }
        catch(e) { this.notifyError("Error when generating code from style element: " + e); }
    },

    generateStartHtmlTagString: function(tagName)
    {
        return "<" + tagName;
    },

    generateHtmlElementAttributes: function(htmlElement)
    {
        try
        {
            var attributes = htmlElement.attributes;
            var attributesText = "";

            if(attributes == null) { return attributesText; }

            for(var i = 0, length = attributes.length; i < length; i++)
            {
                var attribute = attributes[i];

                if(htmlElement.type == "script" && attribute.name == "src")
                {
                    continue;
                }

                attributesText += " " + attribute.name + '="' + attribute.value + '"';
            }

            return attributesText;
        }
        catch(e) { this.notifyError("Error when generating html element attributes: " + e); }
    },

    generateEndHtmlTagString: function(tag)
    {
        return this.isEmptyElementType(tag) ? "" : "</" + tag + ">";
    },

    whitespace: "",
    newLine: "\r\n",
    indent: function()
    {
        this.whitespace += "  ";
    },
    deIndent: function()
    {
        this.whitespace = this.whitespace.replace(/\s\s$/, "");
    },

    notifyError: function(message) { debugger; Firecrow.CodeTextGenerator.notifyError(message); },

    _isExternalScriptElement: function(htmlElement)
    {
        if(htmlElement == null || htmlElement.type == null) { return false; }

        return htmlElement.type.toLowerCase() == "script" && this._hasAttribute(htmlElement, "src");
    },

    _isExternalStyleElement: function(htmlElement)
    {
        if(htmlElement == null || htmlElement.type == null) { return false; }

        return htmlElement.type.toLowerCase() == "link" && this._hasAttribute(htmlElement, "href") && this._hasAttribute(htmlElement, "rel");
    },

    _hasAttribute: function(htmlElement, attributeName)
    {
        if(htmlElement == null || htmlElement.attributes == null || htmlElement.attributes.length == 0) { return false; }

        var attributes = htmlElement.attributes;

        for(var i = 0, length = attributes.length; i < length; i++)
        {
            if(attributes[i].name == attributeName) { return true; }
        }

        return false;
    },

    _LEFT_GULL_WING:  "{",
    _RIGHT_GULL_WING: "}",
    _LEFT_PARENTHESIS: "(",
    _RIGHT_PARENTHESIS: ")",
    _LEFT_BRACKET : "[",
    _RIGHT_BRACKET: "]",
    _SEMI_COLON: ";",
    _QUESTION_MARK: "?",
    _COLON: ":",
    _DOT: ".",
    _COMMA: ",",
    _IF_KEYWORD: "if",
    _ELSE_KEYWORD: "else",
    _FOR_KEYWORD: "for",
    _WHILE_KEYWORD: "while",
    _DO_KEYWORD: "do",
    _WITH_KEYWORD: "with",
    _IN_KEYWORD: "in",
    _FUNCTION_KEYWORD: "function",
    _BREAK_KEYWORD: "break",
    _CONTINUE_KEYWORD: "continue",
    _TRY_KEYWORD: "try",
    _CATCH_KEYWORD: "catch",
    _FINALLY_KEYWORD: "finally",
    _THROW_KEYWORD: "throw",
    _RETURN_KEYWORD: "return",
    _VAR_KEYWORD: "var",
    _SWITCH_KEYWORD: "switch",
    _CASE_KEYWORD: "case",
    _DEFAULT_KEYWORD: "default"
};
}});

if(usesModule)
{
    exports.CodeTextGenerator = CodeTextGenerator;
}/**
 * Created by Josip Maras.
 * User: jomaras
 * Date: 06.03.12.
 * Time: 13:56
 */
FBL.ns(function() { with (FBL) {
/*************************************************************************************/
var ASTHelper = Firecrow.ASTHelper;
var ValueTypeHelper = Firecrow.ValueTypeHelper;

var fcCommands = Firecrow.Interpreter.Commands;

Firecrow.Interpreter.Commands.CommandGenerator =
{
    generateCommands: function(program)
    {
        try
        {
            var executionCommands = [];
            var declarationCommands = [];
            var commandType = fcCommands.Command.COMMAND_TYPE;

            ASTHelper.traverseDirectSourceElements
            (
                program,
                function(sourceElement)
                {
                    ValueTypeHelper.pushAll(declarationCommands, fcCommands.CommandGenerator.generateDeclarationCommands(sourceElement));
                },
                true
            );

            ASTHelper.traverseDirectSourceElements
            (
                program,
                function(sourceElement)
                {
                    ValueTypeHelper.pushAll(executionCommands, fcCommands.CommandGenerator.generateExecutionCommands(sourceElement, null));
                },
                false
            );

            return ValueTypeHelper.concatArray(declarationCommands, executionCommands);
        }
        catch(e) { this.notifyError("Error while generating commands: " + e);}
    },

    generateDeclarationCommands: function(sourceElement, parentFunctionCommand)
    {
        var declarationCommands = [];

        var Command = fcCommands.Command;
        var CommandType = fcCommands.Command.COMMAND_TYPE;

        if(ASTHelper.isVariableDeclaration(sourceElement))
        {
            sourceElement.declarations.forEach(function(variableDeclarator)
            {
                declarationCommands.push(new Command(variableDeclarator, CommandType.DeclareVariable, parentFunctionCommand));
            });
        }
        else if (ASTHelper.isFunctionDeclaration(sourceElement))
        {
            declarationCommands.push(new Command(sourceElement, CommandType.DeclareFunction, parentFunctionCommand));
        }
        else if (ASTHelper.isForStatement(sourceElement))
        {
            if(ASTHelper.isVariableDeclaration(sourceElement.init))
            {
                sourceElement.init.declarations.forEach(function(variableDeclarator)
                {
                    declarationCommands.push(new Command(variableDeclarator, CommandType.DeclareVariable, parentFunctionCommand));
                });
            }
        }
        else if(ASTHelper.isForInStatement(sourceElement))
        {
            if(ASTHelper.isVariableDeclaration(sourceElement.left))
            {
                sourceElement.left.declarations.forEach(function(variableDeclarator)
                {
                    declarationCommands.push(new Command(variableDeclarator, CommandType.DeclareVariable, parentFunctionCommand));
                });
            }
        }

        return declarationCommands;
    },

    generateExecutionCommands: function(sourceElement, parentFunctionCommand)
    {
             if (ASTHelper.isExpressionStatement(sourceElement)) { return this.generateExpressionStatementExecutionCommands(sourceElement, parentFunctionCommand); }
        else if (ASTHelper.isBlockStatement(sourceElement)) { return this.generateBlockStatementExecutionCommands(sourceElement, parentFunctionCommand); }
        else if (ASTHelper.isVariableDeclaration(sourceElement)) { return this.generateVariableDeclarationExecutionCommands(sourceElement, parentFunctionCommand); }
        else if (ASTHelper.isWhileStatement(sourceElement)) { return this.generateWhileStatementExecutionCommands(sourceElement, parentFunctionCommand); }
        else if (ASTHelper.isDoWhileStatement(sourceElement)) { return this.generateDoWhileStatementExecutionCommands(sourceElement, parentFunctionCommand); }
        else if (ASTHelper.isForStatement(sourceElement)) { return this.generateForStatementExecutionCommands(sourceElement, parentFunctionCommand); }
        else if (ASTHelper.isForInStatement(sourceElement)) { return this.generateForInStatementExecutionCommands(sourceElement, parentFunctionCommand); }
        else if (ASTHelper.isIfStatement(sourceElement)) { return this.generateIfStatementExecutionCommands(sourceElement, parentFunctionCommand); }
        else if (ASTHelper.isReturnStatement(sourceElement)) { return this.generateReturnStatementExecutionCommands(sourceElement, parentFunctionCommand); }
        else if (ASTHelper.isWithStatement(sourceElement)) { return this.generateWithStatementExecutionCommands(sourceElement, parentFunctionCommand); }
        else if (ASTHelper.isSwitchStatement(sourceElement)) { return this.generateSwitchStatementExecutionCommands(sourceElement, parentFunctionCommand); }
        else if (ASTHelper.isBreakStatement(sourceElement)) { return this.generateBreakStatementExecutionCommands(sourceElement, parentFunctionCommand); }
        else if (ASTHelper.isContinueStatement(sourceElement)) { return this.generateContinueStatementExecutionCommands(sourceElement, parentFunctionCommand); }
        else if (ASTHelper.isTryStatement(sourceElement)) { return this.generateTryStatementExecutionCommands(sourceElement, parentFunctionCommand); }
        else if (ASTHelper.isThrowStatement(sourceElement)) { return this.generateThrowStatementExecutionCommands(sourceElement, parentFunctionCommand); }
        else if (ASTHelper.isLetStatement(sourceElement)) { return this.generateLetStatementExecutionCommands(sourceElement, parentFunctionCommand); }
        else if (ASTHelper.isLabeledStatement(sourceElement)) { return this.generateLabeledStatementExecutionCommands(sourceElement, parentFunctionCommand); }
        else if (ASTHelper.isFunctionDeclaration(sourceElement)) { return []; }
        else if (ASTHelper.isEmptyStatement(sourceElement)) { return []; }

        else { this.notifyError("Unhandled source element when generating execution command: " + sourceElement.type); return []; }
    },

    generateExpressionStatementExecutionCommands: function (sourceElement, parentFunctionCommand)
    {
        return this.generateExpressionCommands(sourceElement.expression, parentFunctionCommand);
    },

    generateBlockStatementExecutionCommands: function(sourceElement, parentFunctionCommand)
    {
        var commands = [];
        var body = sourceElement.body;

        for(var i = 0, length = body.length; i < length; i++)
        {
            ValueTypeHelper.pushAll(commands, this.generateExecutionCommands(body[i], parentFunctionCommand))
        }

        return commands;
    },

    generateVariableDeclarationExecutionCommands: function (sourceElement, parentFunctionCommand)
    {
        var commands = [];

        sourceElement.declarations.forEach(function(variableDeclarator)
        {
            if(variableDeclarator.init != null)
            {
                ValueTypeHelper.pushAll(commands, this.generateExpressionCommands(variableDeclarator.init, parentFunctionCommand));
                commands.push(fcCommands.Command.createAssignmentCommand(variableDeclarator, parentFunctionCommand));
            }
        }, this);

        return commands;
    },

    generateWhileStatementExecutionCommands: function (sourceElement, parentFunctionCommand)
    {
        var commands = [];

        ValueTypeHelper.pushAll(commands, this.generateExpressionCommands(sourceElement.test, parentFunctionCommand));
        commands.push(new fcCommands.Command(sourceElement, fcCommands.Command.COMMAND_TYPE.WhileStatement, parentFunctionCommand));

        return commands;
    },

    generateDoWhileStatementExecutionCommands: function (sourceElement, parentFunctionCommand)
    {
        var commands = [];

        //This command is required so that we no up to which point we remove commands if break, continue occur in do while..
        commands.push(new fcCommands.Command(sourceElement, fcCommands.Command.COMMAND_TYPE.StartDoWhileStatement, parentFunctionCommand))

        ValueTypeHelper.pushAll(commands, fcCommands.CommandGenerator.generateExecutionCommands(sourceElement.body, parentFunctionCommand));
        ValueTypeHelper.pushAll(commands, this.generateExpressionCommands(sourceElement.test, parentFunctionCommand));

        commands.push(new fcCommands.Command(sourceElement, fcCommands.Command.COMMAND_TYPE.DoWhileStatement, parentFunctionCommand));

        return commands;
    },

    generateForStatementExecutionCommands: function (sourceElement, parentFunctionCommand)
    {
        var commands = [];

        if(sourceElement.init != null)
        {
            if(ASTHelper.isVariableDeclaration(sourceElement.init))
            {
                ValueTypeHelper.pushAll(commands, this.generateVariableDeclarationExecutionCommands(sourceElement.init, parentFunctionCommand));
            }
            else if (ASTHelper.isExpression(sourceElement.init))
            {
                ValueTypeHelper.pushAll(commands, this.generateExpressionCommands(sourceElement.init, parentFunctionCommand));
            }
        }

        if(sourceElement.test != null)
        {
            ValueTypeHelper.pushAll(commands, this.generateExpressionCommands(sourceElement.test, parentFunctionCommand));
        }

        var forStatementCommand = new fcCommands.Command(sourceElement, fcCommands.Command.COMMAND_TYPE.ForStatement, parentFunctionCommand);
        forStatementCommand.isFirstLoopExecution = true;

        commands.push(forStatementCommand);

        return commands;
    },

    generateForInStatementExecutionCommands: function (sourceElement, parentFunctionCommand)
    {
        var commands = [];

        ValueTypeHelper.pushAll(commands, this.generateExpressionCommands(sourceElement.right, parentFunctionCommand));

        commands.push(fcCommands.Command.createForInWhereCommand(sourceElement, undefined, parentFunctionCommand));

        return commands;
    },

    generateIfStatementExecutionCommands: function (sourceElement, parentFunctionCommand)
    {
        var commands = [];

        ValueTypeHelper.pushAll(commands, this.generateExpressionCommands(sourceElement.test, parentFunctionCommand));

        var ifStatementCommand = new fcCommands.Command(sourceElement, fcCommands.Command.COMMAND_TYPE.IfStatement, parentFunctionCommand);

        var endIfCommand = new fcCommands.Command(ifStatementCommand.codeConstruct, fcCommands.Command.COMMAND_TYPE.EndIf, parentFunctionCommand);
        endIfCommand.startCommand = ifStatementCommand;

        commands.push(ifStatementCommand);
        commands.push(endIfCommand);

        return commands;
    },

    generateReturnStatementExecutionCommands: function (sourceElement, parentFunctionCommand)
    {
        var commands = [];

        if(sourceElement.argument != null)
        {
            ValueTypeHelper.pushAll(commands, this.generateExpressionCommands(sourceElement.argument, parentFunctionCommand));
        }

        commands.push(new fcCommands.Command(sourceElement, fcCommands.Command.COMMAND_TYPE.EvalReturnExpression, parentFunctionCommand));

        return commands;
    },

    generateBreakStatementExecutionCommands: function (sourceElement, parentFunctionCommand)
    {
        var commands = [];

        commands.push(new fcCommands.Command(sourceElement, fcCommands.Command.COMMAND_TYPE.EvalBreak, parentFunctionCommand));

        return commands;
    },

    generateContinueStatementExecutionCommands: function (sourceElement, parentFunctionCommand)
    {
        var commands = [];

        commands.push(new fcCommands.Command(sourceElement, fcCommands.Command.COMMAND_TYPE.EvalContinue, parentFunctionCommand));

        return commands;
    },

    generateTryStatementExecutionCommands: function (sourceElement, parentFunctionCommand)
    {
        var commands = [];

        var startTryCommand = new fcCommands.Command(sourceElement, fcCommands.Command.COMMAND_TYPE.StartTryStatement, parentFunctionCommand);
        commands.push(startTryCommand);

        ASTHelper.traverseDirectSourceElements
        (
            sourceElement.block,
            function(sourceElement)
            {
                ValueTypeHelper.pushAll(commands, fcCommands.CommandGenerator.generateExecutionCommands(sourceElement, parentFunctionCommand));
            },
            false
        );

        var endTryCommand = new fcCommands.Command(sourceElement, fcCommands.Command.COMMAND_TYPE.EndTryStatement, parentFunctionCommand);
        endTryCommand.startCommand = startTryCommand;

        commands.push(endTryCommand);

        return commands;
    },

    generateThrowStatementExecutionCommands: function (sourceElement, parentFunctionCommand)
    {
        var commands = [];

        if(sourceElement.argument != null)
        {
            ValueTypeHelper.pushAll(commands, this.generateExpressionCommands(sourceElement.argument, parentFunctionCommand));
        }

        commands.push(new fcCommands.Command(sourceElement, fcCommands.Command.COMMAND_TYPE.EvalThrowExpression, parentFunctionCommand));

        return commands;
    },

    generateWithStatementExecutionCommands: function (sourceElement, parentFunctionCommand)
    {
        var commands = [];

        ValueTypeHelper.pushAll(commands, this.generateExpressionCommands(sourceElement.object, parentFunctionCommand));

        var startWithCommand = new fcCommands.Command(sourceElement, fcCommands.Command.COMMAND_TYPE.StartWithStatement, parentFunctionCommand);

        commands.push(startWithCommand);

        ASTHelper.traverseDirectSourceElements
        (
            sourceElement.body,
            function(sourceElement)
            {
                ValueTypeHelper.pushAll(commands, fcCommands.CommandGenerator.generateExecutionCommands(sourceElement, parentFunctionCommand));
            },
            false
        );

        var endWithCommand = new fcCommands.Command(sourceElement, fcCommands.Command.COMMAND_TYPE.EndWithStatement, parentFunctionCommand);
        commands.push(endWithCommand);

        endWithCommand.startCommand = startWithCommand;

        return commands;
    },

    generateSwitchStatementExecutionCommands: function (sourceElement, parentFunctionCommand)
    {
        var commands = [];

        var startSwitchCommand = new fcCommands.Command(sourceElement, fcCommands.Command.COMMAND_TYPE.StartSwitchStatement, parentFunctionCommand);

        startSwitchCommand.caseCommands = [];
        startSwitchCommand.hasBeenMatched = false;

        ValueTypeHelper.pushAll(commands, this.generateExpressionCommands(sourceElement.discriminant, parentFunctionCommand));

        commands.push(startSwitchCommand);

        sourceElement.cases.forEach(function(caseElement)
        {
            if(caseElement.test != null)
            {
                ValueTypeHelper.pushAll(commands, this.generateExpressionCommands(caseElement.test, parentFunctionCommand));
            }

            var caseCommand = new fcCommands.Command(caseElement, fcCommands.Command.COMMAND_TYPE.Case, parentFunctionCommand);

            caseCommand.parent = startSwitchCommand;
            startSwitchCommand.caseCommands.push(caseCommand);

            commands.push(caseCommand);
        }, this);

        var endSwitchCommand = new fcCommands.Command(sourceElement, fcCommands.Command.COMMAND_TYPE.EndSwitchStatement, parentFunctionCommand);
        endSwitchCommand.startCommand = startSwitchCommand;

        commands.push(endSwitchCommand);

        return commands;
    },

    generateLetStatementExecutionCommands: function (sourceElement, parentFunctionCommand)
    {
        this.notifyError("Let statement not yet handled");
        return [];
    },

    generateLabeledStatementExecutionCommands: function (labelElement, parentFunctionCommand)
    {
        return [new fcCommands.Command(labelElement, fcCommands.Command.COMMAND_TYPE.Label, parentFunctionCommand)];
    },

    generateFunctionExecutionCommands: function(callExpressionCommand, functionObject, thisObject)
    {
        try
        {
            var commands = [];

            if(functionObject == null) { this.notifyError("function object can not be null when generating commands for function execution!"); return commands; }

            if(functionObject.isInternalFunction && !callExpressionCommand.isCall && !callExpressionCommand.isApply)
            {
                return this._generateInternalFunctionExecutionCommands(callExpressionCommand, functionObject, thisObject);
            }
            else if(functionObject.isInternalFunction && (callExpressionCommand.isCall || callExpressionCommand.isApply))
            {
                return this._generateInternalFunctionExecutionCallApplyCommands(callExpressionCommand, functionObject, thisObject);
            }

            var enterFunctionContextCommand = fcCommands.Command.createEnterFunctionContextCommand(functionObject, thisObject, callExpressionCommand);
            var exitFunctionContextCommand = fcCommands.Command.createExitFunctionContextCommand(functionObject, callExpressionCommand);

            commands.push(enterFunctionContextCommand);
            callExpressionCommand.exitFunctionContextCommand = exitFunctionContextCommand;
            exitFunctionContextCommand.callExpressionCommand = callExpressionCommand;

            var functionConstruct = functionObject.codeConstruct;

            ASTHelper.traverseDirectSourceElements
            (
                functionConstruct.body,
                function(sourceElement)
                {
                    ValueTypeHelper.pushAll
                    (
                        commands,
                        fcCommands.CommandGenerator.generateDeclarationCommands(sourceElement, callExpressionCommand)
                    );
                },
                true
            );

            ASTHelper.traverseDirectSourceElements
            (
                functionConstruct.body,
                function(sourceElement)
                {
                    ValueTypeHelper.pushAll
                    (
                        commands,
                        fcCommands.CommandGenerator.generateExecutionCommands(sourceElement, callExpressionCommand)
                    );
                },
                false
            );

            commands.push(exitFunctionContextCommand);

            return commands;
        }
        catch (e)
        {
            this.notifyError("An error occurred when generating function execution commands: " + e + " " + callExpressionCommand.codeConstruct.loc.source);
        }
    },

    _generateInternalFunctionExecutionCommands: function(callExpressionCommand, functionObject, thisObject)
    {
        var commands = [];

        if(functionObject == null) { this.notifyError("function object can not be null when generating commands for internal function execution!"); return commands; }
        if(!functionObject.isInternalFunction) { this.notifyError("function must be an internal function"); return commands; }

        var command = null;

        if (callExpressionCommand.isEvalNewExpressionCommand())
        {
            command = fcCommands.Command.createCallInternalConstructorCommand
            (
                callExpressionCommand.codeConstruct,
                functionObject,
                callExpressionCommand.parentFunctionCommand
            );
        }
        else
        {
            command = fcCommands.Command.createCallInternalFunctionCommand
            (
                callExpressionCommand.codeConstruct,
                functionObject,
                thisObject,
                callExpressionCommand.parentFunctionCommand,
                callExpressionCommand
            );
        }

        commands.push(command);

        return commands;
    },

    _generateInternalFunctionExecutionCallApplyCommands: function(callExpressionCommand, functionObject, thisObject)
    {
       var command = fcCommands.Command.createCallInternalFunctionCommand
       (
           callExpressionCommand.codeConstruct,
           functionObject,
           thisObject,
           callExpressionCommand.parentFunctionCommand
       );

       command.isCall = callExpressionCommand.isCall;
       command.isApply = callExpressionCommand.isApply;

       return [command];
    },

    generateCallbackFunctionExecutionCommands: function(callbackCommand)
    {
        var commands = [];

        var argumentGroups = callbackCommand.callbackArgumentGroups;

        if(argumentGroups == null) { return commands; }

        callbackCommand.intermediateResults = [];
        callbackCommand.childCommands = [];

        for(var i = 0, length = argumentGroups.length; i < length; i++)
        {
            var executeCallbackCommand = fcCommands.Command.createExecuteCallbackCommand(callbackCommand, argumentGroups[i], i);
            executeCallbackCommand.parentInitCallbackCommand = callbackCommand;
            callbackCommand.childCommands.push(executeCallbackCommand);

            commands.push(executeCallbackCommand);

            ValueTypeHelper.pushAll(commands, this.generateFunctionExecutionCommands(executeCallbackCommand, callbackCommand.callbackFunction, callbackCommand.thisObject));

            var evalCallbackCommand =  new fcCommands.Command
            (
                callbackCommand.callbackFunction.codeConstruct,
                fcCommands.Command.COMMAND_TYPE.EvalCallbackFunction,
                callbackCommand
            );

            evalCallbackCommand.parentInitCallbackCommand = callbackCommand;
            evalCallbackCommand.thisObject = executeCallbackCommand.thisObject;
            evalCallbackCommand.originatingObject = executeCallbackCommand.originatingObject;
            evalCallbackCommand.targetObject = executeCallbackCommand.targetObject;
            evalCallbackCommand.executeCallbackCommand = executeCallbackCommand;

            if(i == length - 1)
            {
                evalCallbackCommand.isLastCallbackCommand = true;
                executeCallbackCommand.isLastCallbackCommand = true;
                callbackCommand.lastCallbackCommand = evalCallbackCommand;
            }

            commands.push(evalCallbackCommand);
        }

        return commands;
    },

    generateIfStatementBodyCommands: function(ifStatementCommand, conditionEvaluationResult, parentFunctionCommand)
    {
        var commands = [];

        if(conditionEvaluationResult)
        {
            ASTHelper.traverseDirectSourceElements
            (
                ifStatementCommand.codeConstruct.consequent,
                function(sourceElement)
                {
                    ValueTypeHelper.pushAll(commands, fcCommands.CommandGenerator.generateExecutionCommands(sourceElement, parentFunctionCommand));
                },
                false
            );
        }
        else
        {
            if(ifStatementCommand.codeConstruct.alternate != null)
            {
                ASTHelper.traverseDirectSourceElements
                (
                    ifStatementCommand.codeConstruct.alternate,
                    function(sourceElement)
                    {
                        ValueTypeHelper.pushAll(commands, fcCommands.CommandGenerator.generateExecutionCommands(sourceElement, parentFunctionCommand));
                    },
                    false
                );
            }
        }

        return commands;
    },

    generateCaseExecutionCommands: function(caseCommand)
    {
        var commands = [];

        ASTHelper.traverseArrayOfDirectStatements
        (
            caseCommand.codeConstruct.consequent,
            caseCommand.codeConstruct,
            function(sourceElement)
            {
                ValueTypeHelper.pushAll(commands, fcCommands.CommandGenerator.generateExecutionCommands(sourceElement, caseCommand.parentFunctionCommand));
            },
            false
        );

        return commands;
    },

    generateCatchStatementExecutionCommands: function(tryCommand, exceptionArgument, throwingCommand)
    {
        var commands = [];

        var tryStatement = tryCommand.codeConstruct;

        var handlers = tryStatement.handlers || (ValueTypeHelper.isArray(tryStatement.handler) ? tryStatement.handler : [tryStatement.handler]);

        if(handlers.length > 1) { this.notifyError("Not handling more than 1 catch"); return commands; }

        var catchElement = handlers[0];

        var startCatchCommand = new fcCommands.Command(catchElement, fcCommands.Command.COMMAND_TYPE.StartCatchStatement, tryCommand.parentFunctionCommand);
        startCatchCommand.throwingCommand = throwingCommand;

        commands.push(startCatchCommand);

        commands[0].exceptionArgument = exceptionArgument;

        ASTHelper.traverseDirectSourceElements
        (
            catchElement.body,
            function(sourceElement)
            {
                ValueTypeHelper.pushAll(commands, fcCommands.CommandGenerator.generateExecutionCommands
                (
                    sourceElement,
                    tryCommand.parentFunctionCommand
                ));
            },
            false
        );

        var endCatchCommand = new fcCommands.Command(catchElement, fcCommands.Command.COMMAND_TYPE.EndCatchStatement, tryCommand.parentFunctionCommand);
        endCatchCommand.startCommand = startCatchCommand;

        commands.push(endCatchCommand);

        return commands;
    },

    generateLoopExecutionCommands: function(loopStatementCommand, evaldCondition)
    {
        try
        {
            if(loopStatementCommand.isForStatementCommand()) { return this.generateForBodyExecutionCommands(loopStatementCommand, evaldCondition); }
            else if (loopStatementCommand.isDoWhileStatementCommand()) { return this.generateDoWhileBodyExecutionCommands(loopStatementCommand, evaldCondition); }
            else if (loopStatementCommand.isWhileStatementCommand()) { return this.generateWhileBodyExecutionCommands(loopStatementCommand, evaldCondition); }
            else if (loopStatementCommand.isEvalForInWhereCommand()) { return this.generateForInBodyExecutionCommands(loopStatementCommand, evaldCondition); }
            else { this.notifyError("Unknown loop statement!"); }
        }
        catch(e) { this.notifyError("Error when generating loop execution commands: " + e); }
    },

    generateWhileBodyExecutionCommands: function(whileStatementCommand, evaldCondition)
    {
        var commands = [];

        var endWhileCommand = new fcCommands.Command(whileStatementCommand.codeConstruct, fcCommands.Command.COMMAND_TYPE.EndLoopStatement, whileStatementCommand.parentFunctionCommand);
        endWhileCommand.startCommand = whileStatementCommand;

        if(evaldCondition)
        {
            ASTHelper.traverseDirectSourceElements
            (
                whileStatementCommand.codeConstruct.body,
                function(sourceElement)
                {
                    ValueTypeHelper.pushAll(commands, fcCommands.CommandGenerator.generateExecutionCommands(sourceElement, whileStatementCommand.parentFunctionCommand));
                },
                false
            );

            ValueTypeHelper.pushAll(commands, this.generateExpressionCommands(whileStatementCommand.codeConstruct.test, whileStatementCommand.parentFunctionCommand));

            commands.push(endWhileCommand);

            commands.push(new fcCommands.Command(whileStatementCommand.codeConstruct, fcCommands.Command.COMMAND_TYPE.WhileStatement, whileStatementCommand.parentFunctionCommand));
        }
        else
        {
            commands.push(endWhileCommand);
        }

        return commands;
    },

    generateDoWhileBodyExecutionCommands: function(doWhileStatementCommand, evaldCondition)
    {
        var commands = [];

        var endDoWhileCommand = new fcCommands.Command(doWhileStatementCommand.codeConstruct, fcCommands.Command.COMMAND_TYPE.EndLoopStatement, doWhileStatementCommand.parentFunctionCommand);
        endDoWhileCommand.startCommand = doWhileStatementCommand;

        if(evaldCondition)
        {
            ASTHelper.traverseDirectSourceElements
            (
                doWhileStatementCommand.codeConstruct.body,
                function(sourceElement)
                {
                    ValueTypeHelper.pushAll(commands, fcCommands.CommandGenerator.generateExecutionCommands(sourceElement, doWhileStatementCommand.parentFunctionCommand));
                },
                false
            );

            ValueTypeHelper.pushAll(commands, this.generateExpressionCommands(doWhileStatementCommand.codeConstruct.test, doWhileStatementCommand.parentFunctionCommand));

            commands.push(endDoWhileCommand);

            commands.push(new fcCommands.Command(doWhileStatementCommand.codeConstruct, fcCommands.Command.COMMAND_TYPE.DoWhileStatement, doWhileStatementCommand.parentFunctionCommand));
        }
        else
        {
            commands.push(endDoWhileCommand);
        }

        return commands;
    },

    generateForBodyExecutionCommands: function(forStatementCommand, evaldCondition)
    {
        var commands = [];
        var forConstruct = forStatementCommand.codeConstruct;

        var endLoopCommand = new fcCommands.Command(forConstruct, fcCommands.Command.COMMAND_TYPE.EndLoopStatement, forStatementCommand.parentFunctionCommand);
        endLoopCommand.startCommand = forStatementCommand;

        if(evaldCondition)
        {
            ASTHelper.traverseDirectSourceElements
            (
                forConstruct.body,
                function(sourceElement)
                {
                    ValueTypeHelper.pushAll(commands, fcCommands.CommandGenerator.generateExecutionCommands(sourceElement, forStatementCommand.parentFunctionCommand));
                },
                false
            );

            commands.push(new fcCommands.Command(forConstruct, fcCommands.Command.COMMAND_TYPE.ForUpdateStatement, forStatementCommand.parentFunctionCommand));

            if(forConstruct.update != null)
            {
                ValueTypeHelper.pushAll(commands, this.generateExpressionCommands(forConstruct.update, forStatementCommand.parentFunctionCommand));
            }

            if(forConstruct.test != null)
            {
                ValueTypeHelper.pushAll(commands, this.generateExpressionCommands(forConstruct.test, forStatementCommand.parentFunctionCommand));
            }

            commands.push(endLoopCommand);

            commands.push(new fcCommands.Command(forConstruct, fcCommands.Command.COMMAND_TYPE.ForStatement, forStatementCommand.parentFunctionCommand));
        }
        else
        {
            commands.push(endLoopCommand);
        }

        return commands;
    },

    generateForInBodyExecutionCommands: function(forInCommand)
    {
        var commands = [];

        var endLoopCommand = new fcCommands.Command(forInCommand.codeConstruct, fcCommands.Command.COMMAND_TYPE.EndLoopStatement, forInCommand.parentFunctionCommand);
        endLoopCommand.startCommand = forInCommand;

        if(forInCommand.willBodyBeExecuted)
        {
            ASTHelper.traverseDirectSourceElements
            (
                forInCommand.codeConstruct.body,
                function(sourceElement)
                {
                    ValueTypeHelper.pushAll(commands, fcCommands.CommandGenerator.generateExecutionCommands(sourceElement, forInCommand.parentFunctionCommand));
                },
                false
            );

            commands.push(endLoopCommand);
            commands.push(fcCommands.Command.createForInWhereCommand(forInCommand.codeConstruct, forInCommand.propertyNames, forInCommand.parentFunctionCommand));
        }
        else
        {
            commands.push(endLoopCommand);
        }

        return commands;
    },

    generateExpressionCommands: function(sourceElement, parentFunctionCommand)
    {
             if (ASTHelper.isThisExpression(sourceElement)) { return this.generateThisCommands(sourceElement, parentFunctionCommand); }
        else if (ASTHelper.isIdentifier(sourceElement)) { return this.generateIdentifierCommands(sourceElement, parentFunctionCommand); }
        else if (ASTHelper.isLiteral(sourceElement)) { return this.generateLiteralCommands(sourceElement, parentFunctionCommand); }
        else if (ASTHelper.isArrayExpression(sourceElement)) { return this.generateArrayExpressionCommands(sourceElement, parentFunctionCommand); }
        else if (ASTHelper.isObjectExpression(sourceElement)) { return this.generateObjectExpressionCommands(sourceElement, parentFunctionCommand); }
        else if (ASTHelper.isFunctionExpression(sourceElement)) { return this.generateFunctionExpressionCommands(sourceElement, parentFunctionCommand); }
        else if (ASTHelper.isSequenceExpression(sourceElement)) { return this.generateSequenceExpressionCommands(sourceElement, parentFunctionCommand); }
        else if (ASTHelper.isUnaryExpression(sourceElement)) { return this.generateUnaryExpressionCommands(sourceElement, parentFunctionCommand); }
        else if (ASTHelper.isBinaryExpression(sourceElement)) { return this.generateBinaryExpressionCommands(sourceElement, parentFunctionCommand); }
        else if (ASTHelper.isAssignmentExpression(sourceElement)) { return this.generateAssignmentExpressionCommands(sourceElement, parentFunctionCommand); }
        else if (ASTHelper.isUpdateExpression(sourceElement)) { return this.generateUpdateExpressionCommands(sourceElement, parentFunctionCommand); }
        else if (ASTHelper.isLogicalExpression(sourceElement)) { return this.generateLogicalExpressionCommands(sourceElement, parentFunctionCommand); }
        else if (ASTHelper.isConditionalExpression(sourceElement)) { return this.generateConditionalExpressionCommands(sourceElement, parentFunctionCommand); }
        else if (ASTHelper.isNewExpression(sourceElement)) { return this.generateNewExpressionCommands(sourceElement, parentFunctionCommand); }
        else if (ASTHelper.isCallExpression(sourceElement)) { return this.generateCallExpressionCommands(sourceElement, parentFunctionCommand);}
        else if (ASTHelper.isMemberExpression(sourceElement)) { return this.generateMemberExpressionCommands(sourceElement, parentFunctionCommand); }
        else if (ASTHelper.isYieldExpression(sourceElement)
            ||  ASTHelper.isComprehensionExpression(sourceElement)
            ||  ASTHelper.isGeneratorExpression(sourceElement)
            ||  ASTHelper.isLetExpression(sourceElement))
        {
            this.notifyError("Yield, Comprehension, Generator and Let not yet implemented!");
        }
    },

    generateThisCommands: function(sourceElement, parentFunctionCommand)
    {
        var commands = [];

        commands.push(new fcCommands.Command(sourceElement, fcCommands.Command.COMMAND_TYPE.ThisExpression, parentFunctionCommand));

        return commands;
    },

    generateIdentifierCommands: function(sourceElement, parentFunctionCommand)
    {
        var commands = [];

        commands.push(new fcCommands.Command(sourceElement, fcCommands.Command.COMMAND_TYPE.EvalIdentifier, parentFunctionCommand));

        return commands;
    },

    generateLiteralCommands: function(sourceElement, parentFunctionCommand)
    {
        var commands = [];

        if(ValueTypeHelper.isObject(sourceElement.value))
        {
            var regExCommand = new fcCommands.Command(sourceElement, fcCommands.Command.COMMAND_TYPE.EvalRegExLiteral, parentFunctionCommand);

            //If it is directly gotten from mdc parser
            if(sourceElement.value.constructor != null && sourceElement.value.constructor.name === "RegExp")
            {
                regExCommand.regExLiteral = sourceElement.value;
            }
            else //over JSON conversion
            {
                regExCommand.regExLiteral = ValueTypeHelper.adjustForRegExBug(sourceElement.value, atob(sourceElement.value.RegExpBase64));
            }

            commands.push(regExCommand);

            return commands;
        }

        commands.push(new fcCommands.Command(sourceElement, fcCommands.Command.COMMAND_TYPE.EvalLiteral, parentFunctionCommand));

        return commands;
    },

    generateArrayExpressionCommands: function(sourceElement, parentFunctionCommand)
    {
        var commands = [];

        var arrayExpressionCommand = new fcCommands.Command(sourceElement, fcCommands.Command.COMMAND_TYPE.ArrayExpression, parentFunctionCommand);

        commands.push(arrayExpressionCommand);

        var elements = sourceElement.elements;

        if(elements == null || elements.length == 0) { return commands; }

        for(var i = 0, length = elements.length; i < length; i++)
        {
            var item = elements[i];

            if(item != null)
            {
                ValueTypeHelper.pushAll(commands, this.generateExpressionCommands(item, parentFunctionCommand));
            }

            commands.push(fcCommands.Command.createArrayExpressionItemCommand(item, arrayExpressionCommand, parentFunctionCommand));
        }

        return commands;
    },

    generateObjectExpressionCommands: function(sourceElement, parentFunctionCommand)
    {
        var commands = [];

        var objectExpressionCommand = new fcCommands.Command(sourceElement, fcCommands.Command.COMMAND_TYPE.ObjectExpression, parentFunctionCommand);

        commands.push(objectExpressionCommand);

        var properties = sourceElement.properties;

        if(properties == null || properties.length == 0) { return commands; }

        for(var i = 0, length = properties.length; i < length; i++)
        {
            var property = properties[i];

            ValueTypeHelper.pushAll(commands, this.generateExpressionCommands(property.value, parentFunctionCommand));

            if(property.kind == "get" || property.kind == "set") { this.notifyError("Getters and setters not supported!"); }

            commands.push(fcCommands.Command.createObjectPropertyCommand(property, objectExpressionCommand, parentFunctionCommand));
        }

        return commands;
    },

    generateFunctionExpressionCommands: function(sourceElement, parentFunctionCommand)
    {
        var commands = [];

        commands.push(new fcCommands.Command(sourceElement, fcCommands.Command.COMMAND_TYPE.FunctionExpressionCreation, parentFunctionCommand));

        return commands;
    },

    generateSequenceExpressionCommands: function(sourceElement, parentFunctionCommand)
    {
        var commands = [];

        sourceElement.expressions.forEach(function(expression)
        {
            ValueTypeHelper.pushAll(commands, this.generateExpressionCommands(expression, parentFunctionCommand));
        }, this);

        commands.push(new fcCommands.Command(sourceElement, fcCommands.Command.COMMAND_TYPE.EvalSequenceExpression, parentFunctionCommand));

        return commands;
    },

    generateUnaryExpressionCommands: function(sourceElement, parentFunctionCommand)
    {
        var commands = [];

        ValueTypeHelper.pushAll(commands, this.generateExpressionCommands(sourceElement.argument, parentFunctionCommand));

        commands.push(new fcCommands.Command(sourceElement, fcCommands.Command.COMMAND_TYPE.EvalUnaryExpression, parentFunctionCommand));

        return commands;
    },

    generateBinaryExpressionCommands: function(sourceElement, parentFunctionCommand)
    {
        var commands = [];

        ValueTypeHelper.pushAll(commands, this.generateExpressionCommands(sourceElement.left, parentFunctionCommand));
        commands.push(new fcCommands.Command(sourceElement.left, fcCommands.Command.COMMAND_TYPE.ConvertToPrimitive, parentFunctionCommand));

        ValueTypeHelper.pushAll(commands, this.generateExpressionCommands(sourceElement.right, parentFunctionCommand));
        commands.push(new fcCommands.Command(sourceElement.right, fcCommands.Command.COMMAND_TYPE.ConvertToPrimitive, parentFunctionCommand));

        commands.push(new fcCommands.Command(sourceElement, fcCommands.Command.COMMAND_TYPE.EvalBinaryExpression, parentFunctionCommand));

        return commands;
    },

    generateAssignmentExpressionCommands: function(sourceElement, parentFunctionCommand)
    {
        var commands = [];

        ValueTypeHelper.pushAll(commands, this.generateExpressionCommands(sourceElement.right, parentFunctionCommand));
        ValueTypeHelper.pushAll(commands, this.generateExpressionCommands(sourceElement.left, parentFunctionCommand));

        commands.push(fcCommands.Command.createAssignmentCommand(sourceElement, parentFunctionCommand));

        return commands;
    },

    generateUpdateExpressionCommands: function(sourceElement, parentFunctionCommand)
    {
        var commands = [];

        ValueTypeHelper.pushAll(commands, this.generateExpressionCommands(sourceElement.argument, parentFunctionCommand));

        commands.push(new fcCommands.Command(sourceElement, fcCommands.Command.COMMAND_TYPE.EvalUpdateExpression, parentFunctionCommand));

        return commands;
    },

    generateLogicalExpressionCommands: function(sourceElement, parentFunctionCommand)
    {
        var commands = [];

        var startLogicalExpressionCommand = new fcCommands.Command(sourceElement, fcCommands.Command.COMMAND_TYPE.StartEvalLogicalExpression, parentFunctionCommand);

        ValueTypeHelper.pushAll(commands, this.generateExpressionCommands(sourceElement.left, parentFunctionCommand));

        var evalLeft = new fcCommands.Command(sourceElement.left, fcCommands.Command.COMMAND_TYPE.EvalLogicalExpressionItem, parentFunctionCommand);
        evalLeft.parentLogicalExpressionCommand = startLogicalExpressionCommand;
        commands.push(evalLeft);
        startLogicalExpressionCommand.evalLeftCommand = evalLeft;

        ValueTypeHelper.pushAll(commands, this.generateExpressionCommands(sourceElement.right, parentFunctionCommand));

        var evalRight = new fcCommands.Command(sourceElement.right, fcCommands.Command.COMMAND_TYPE.EvalLogicalExpressionItem, parentFunctionCommand);
        evalRight.parentLogicalExpressionCommand = startLogicalExpressionCommand;
        commands.push(evalRight);
        startLogicalExpressionCommand.evalRightCommand = evalRight;

        var endLogicalExpressionCommand = new fcCommands.Command(sourceElement, fcCommands.Command.COMMAND_TYPE.EndEvalLogicalExpression, parentFunctionCommand);

        evalLeft.parentEndLogicalExpressionCommand = endLogicalExpressionCommand;
        evalRight.parentEndLogicalExpressionCommand = endLogicalExpressionCommand;

        endLogicalExpressionCommand.startCommand = startLogicalExpressionCommand;
        endLogicalExpressionCommand.executedLogicalItemExpressionCommands = [];

        commands.push(endLogicalExpressionCommand);

        return commands;
    },

    generateConditionalExpressionCommands: function(sourceElement, parentFunctionCommand)
    {
        var commands = [];

        ValueTypeHelper.pushAll(commands, this.generateExpressionCommands(sourceElement.test, parentFunctionCommand));

        commands.push(new fcCommands.Command(sourceElement, fcCommands.Command.COMMAND_TYPE.EvalConditionalExpressionBody, parentFunctionCommand));

        return commands;
    },

    generateConditionalExpressionEvalBodyCommands: function(executeConditionalExpressionBodyCommand, willConsequentBeExecuted)
    {
        var commands = [];

        var evalConditionalExpressionCommand = new fcCommands.Command(executeConditionalExpressionBodyCommand.codeConstruct, fcCommands.Command.COMMAND_TYPE.EvalConditionalExpression, executeConditionalExpressionBodyCommand.codeConstruct.parentFunctionCommand);

        commands.push(evalConditionalExpressionCommand);

        if(willConsequentBeExecuted)
        {
            ValueTypeHelper.pushAll(commands, this.generateExpressionCommands(executeConditionalExpressionBodyCommand.codeConstruct.consequent, executeConditionalExpressionBodyCommand.parentFunctionCommand));
            evalConditionalExpressionCommand.body = executeConditionalExpressionBodyCommand.codeConstruct.consequent;
        }
        else
        {
            ValueTypeHelper.pushAll(commands, this.generateExpressionCommands(executeConditionalExpressionBodyCommand.codeConstruct.alternate, executeConditionalExpressionBodyCommand.parentFunctionCommand));
            evalConditionalExpressionCommand.body = executeConditionalExpressionBodyCommand.codeConstruct.alternate;
        }

        var endConditionalExpressionCommand = new fcCommands.Command(executeConditionalExpressionBodyCommand.codeConstruct, fcCommands.Command.COMMAND_TYPE.EndEvalConditionalExpression, executeConditionalExpressionBodyCommand.codeConstruct.parentFunctionCommand);
        endConditionalExpressionCommand.startCommand = evalConditionalExpressionCommand;

        commands.push(endConditionalExpressionCommand);

        return commands;
    },

    generateNewExpressionCommands: function(sourceElement, parentFunctionCommand)
    {
        var commands = [];

        ValueTypeHelper.pushAll(commands, this.generateExpressionCommands(sourceElement.callee, parentFunctionCommand));

        if(sourceElement.arguments != null)
        {
            sourceElement.arguments.forEach(function(argument)
            {
                ValueTypeHelper.pushAll(commands, this.generateExpressionCommands(argument, parentFunctionCommand));
            }, this);
        }

        commands.push(new fcCommands.Command(sourceElement, fcCommands.Command.COMMAND_TYPE.EvalNewExpression, parentFunctionCommand));

        return commands;
    },

    generateCallExpressionCommands: function(sourceElement, parentFunctionCommand)
    {
        var commands = [];

        ValueTypeHelper.pushAll(commands, this.generateExpressionCommands(sourceElement.callee, parentFunctionCommand));

        if(sourceElement.arguments != null)
        {
            sourceElement.arguments.forEach(function(argument)
            {
                ValueTypeHelper.pushAll(commands, this.generateExpressionCommands(argument, parentFunctionCommand));
            }, this);
        }

        commands.push(new fcCommands.Command(sourceElement, fcCommands.Command.COMMAND_TYPE.EvalCallExpression, parentFunctionCommand));

        return commands;
    },

    generateMemberExpressionCommands: function(sourceElement, parentFunctionCommand)
    {
        var commands = [];

        ValueTypeHelper.pushAll(commands, this.generateExpressionCommands(sourceElement.object,parentFunctionCommand));

        if(sourceElement.computed)
        {
            ValueTypeHelper.pushAll(commands, this.generateExpressionCommands(sourceElement.property, parentFunctionCommand));
        }

        var evalMemberExpressionCommand = new fcCommands.Command(sourceElement, fcCommands.Command.COMMAND_TYPE.EvalMemberExpression, parentFunctionCommand);
        var evalMemberPropertyExpressionCommand = new fcCommands.Command(sourceElement, fcCommands.Command.COMMAND_TYPE.EvalMemberExpressionProperty, parentFunctionCommand);

        evalMemberPropertyExpressionCommand.parentMemberExpressionCommand = evalMemberExpressionCommand;

        commands.push(evalMemberPropertyExpressionCommand);
        commands.push(evalMemberExpressionCommand);

        return commands;
    },

    toString: function(commands) { return commands.join("\n"); },

    notifyError: function(message) { debugger; alert("CommandGenerator - " + message); }
};
/*************************************************************************************/
}});/**
 * User: Jomaras
 * Date: 05.11.12.
 * Time: 09:21
 */
FBL.ns(function() { with (FBL) {
/*************************************************************************************/
var fcCommands = Firecrow.Interpreter.Commands;
var ASTHelper = Firecrow.ASTHelper;

Firecrow.Interpreter.Commands.Command = function(codeConstruct, type, parentFunctionCommand)
{
    this.id = fcCommands.Command.LAST_COMMAND_ID++;
    this.codeConstruct = codeConstruct;
    this.type = type;
    this.parentFunctionCommand = parentFunctionCommand;

    this.removesCommands = this.isEvalReturnExpressionCommand() || this.isEvalBreakCommand() || this.isEvalContinueCommand()
                        || this.isEvalThrowExpressionCommand() || this.isEvalLogicalExpressionItemCommand();

    this.generatesNewCommands = this.isEvalCallbackFunctionCommand() ||  this.isEvalNewExpressionCommand() || this.isEvalCallExpressionCommand()
                             || this.isLoopStatementCommand() || this.isIfStatementCommand() ||  this.isEvalConditionalExpressionBodyCommand()
                             || this.isCaseCommand() || this.isCallCallbackMethodCommand() || this.isConvertToPrimitiveCommand();
};

Firecrow.Interpreter.Commands.Command.LAST_COMMAND_ID = 0;

Firecrow.Interpreter.Commands.Command.notifyError = function(message) { debugger; alert("Command - " + message); }

Firecrow.Interpreter.Commands.Command.createAssignmentCommand = function(codeConstruct, parentFunctionCommand)
{
    var command = new fcCommands.Command(codeConstruct, fcCommands.Command.COMMAND_TYPE.EvalAssignmentExpression, parentFunctionCommand);

    if (ASTHelper.isVariableDeclarator(codeConstruct))
    {
        command.leftSide = codeConstruct.id;
        command.rightSide = codeConstruct.init;
        command.operator = "=";
    }
    else if (ASTHelper.isAssignmentExpression(codeConstruct))
    {
        command.leftSide = codeConstruct.left;
        command.rightSide = codeConstruct.right;
        command.operator = codeConstruct.operator;
    }
    else
    {
        this.notifyError("Assignment command can only be created on variable declarators and assignment expressions!");
    }

    return command;
};

Firecrow.Interpreter.Commands.Command.createEnterFunctionContextCommand = function(functionObject, thisObject, parentFunctionCommand)
{
    var command = new fcCommands.Command(functionObject.codeConstruct, fcCommands.Command.COMMAND_TYPE.EnterFunctionContext, parentFunctionCommand);

    if(functionObject == null || !ASTHelper.isFunction(functionObject.codeConstruct))
    {
        debugger;
        this.notifyError("Callee code construct has to be a function");
    }

    command.callee = functionObject;
    command.thisObject = thisObject;

    if(functionObject.iValue.bounder != null && functionObject.iValue.bounder.jsValue != null)
    {
        command.thisObject = functionObject.iValue.bounder;
    }

    return command;
};

Firecrow.Interpreter.Commands.Command.createEnterEventHandlerContextCommand = function(handlerInfo)
{
    var command = new fcCommands.Command(handlerInfo.functionHandler.codeConstruct, fcCommands.Command.COMMAND_TYPE.EnterFunctionContext, null);

    command.callee = handlerInfo.functionHandler;
    command.thisObject = handlerInfo.thisObject;
    command.argumentValues = handlerInfo.argumentValues;
    command.codeConstruct = handlerInfo.registrationPoint.codeConstruct;
    command.isEnterEventHandler = true;

    return command;
};

Firecrow.Interpreter.Commands.Command.createExitFunctionContextCommand = function(functionObject, parentFunctionCommand)
{
    return new fcCommands.Command(functionObject.codeConstruct, fcCommands.Command.COMMAND_TYPE.ExitFunctionContext, parentFunctionCommand);
};

Firecrow.Interpreter.Commands.Command.createObjectPropertyCommand = function(codeConstruct, objectExpressionCommand, parentFunctionCommand)
{
    var command = new fcCommands.Command(codeConstruct, fcCommands.Command.COMMAND_TYPE.ObjectPropertyCreation, parentFunctionCommand );

    command.objectExpressionCommand = objectExpressionCommand;

    return command;
};

Firecrow.Interpreter.Commands.Command.createArrayExpressionItemCommand = function(codeConstruct, arrayExpressionCommand, parentFunctionCommand)
{
    var command = new fcCommands.Command(codeConstruct, fcCommands.Command.COMMAND_TYPE.ArrayExpressionItemCreation, parentFunctionCommand);

    command.arrayExpressionCommand = arrayExpressionCommand;

    return command;
};

Firecrow.Interpreter.Commands.Command.createForInWhereCommand = function(codeConstruct, propertyNames, parentFunctionCommand)
{
    var command = new fcCommands.Command(codeConstruct, fcCommands.Command.COMMAND_TYPE.EvalForInWhere, parentFunctionCommand);

    command.propertyNames = propertyNames;

    return command;
};

Firecrow.Interpreter.Commands.Command.createCallInternalConstructorCommand = function(codeConstruct, functionObject, parentFunctionCommand)
{
    var command = new fcCommands.Command(codeConstruct, fcCommands.Command.COMMAND_TYPE.CallInternalConstructor, parentFunctionCommand);

    command.functionObject = functionObject;

    return command;
};

Firecrow.Interpreter.Commands.Command.createCallInternalConstructorCommand = function(codeConstruct, functionObject, parentFunctionCommand)
{
    var command = new fcCommands.Command(codeConstruct, fcCommands.Command.COMMAND_TYPE.CallInternalConstructor, parentFunctionCommand);

    command.functionObject = functionObject;

    return command;
};

Firecrow.Interpreter.Commands.Command.createCallInternalFunctionCommand = function(codeConstruct, functionObject, thisObject, parentFunctionCommand, parentCallExpressionCommand)
{
    var command = new fcCommands.Command(codeConstruct, fcCommands.Command.COMMAND_TYPE.CallInternalFunction, parentFunctionCommand);

    command.functionObject = functionObject;
    command.thisObject = thisObject;

    command.parentCallExpressionCommand = parentCallExpressionCommand;

    return command;
};

Firecrow.Interpreter.Commands.Command.createCallCallbackMethodCommand = function(codeConstruct, callCommand, parentFunctionCommand)
{
    var command = new fcCommands.Command(codeConstruct, fcCommands.Command.COMMAND_TYPE.CallCallbackMethod, parentFunctionCommand);

    command.generatesNewCommands = true;
    command.generatesCallbacks = true;
    command.setCallbackFunction(callCommand.callbackFunction);
    command.callbackArgumentGroups = callCommand.callbackArgumentGroups;
    command.thisObject = callCommand.thisObject;
    command.originatingObject = callCommand.originatingObject;
    command.callerFunction = callCommand.callerFunction;
    command.targetObject = callCommand.targetObject;

    return command;
};

Firecrow.Interpreter.Commands.Command.createExecuteCallbackCommand = function(callCallbackCommand, arguments, index)
{
    var command = new fcCommands.Command(callCallbackCommand.callbackFunction.codeConstruct, fcCommands.Command.COMMAND_TYPE.ExecuteCallback, callCallbackCommand.parentFunctionCommand);

    command.setCallbackFunction(callCallbackCommand.callbackFunction);
    command.callbackArgumentGroups = callCallbackCommand.callbackArgumentGroups;
    command.thisObject = callCallbackCommand.thisObject;
    command.originatingObject = callCallbackCommand.originatingObject;
    command.callerFunction = callCallbackCommand.callerFunction;
    command.targetObject = callCallbackCommand.targetObject;
    command.arguments = arguments;
    command.callCallbackCommand = callCallbackCommand;
    command.index = index;

    return command;
};

Firecrow.Interpreter.Commands.Command.prototype =
{
    isDeclareVariableCommand: function() { return this.type == fcCommands.Command.COMMAND_TYPE.DeclareVariable; },
    isDeclareFunctionCommand: function() { return this.type == fcCommands.Command.COMMAND_TYPE.DeclareFunction; },
    isThisExpressionCommand: function() { return this.type == fcCommands.Command.COMMAND_TYPE.ThisExpression; },

    isArrayExpressionCommand: function() { return this.type == fcCommands.Command.COMMAND_TYPE.ArrayExpression; },
    isArrayExpressionItemCreationCommand: function() { return this.type == fcCommands.Command.COMMAND_TYPE.ArrayExpressionItemCreation; },

    isObjectExpressionCommand: function() { return this.type == fcCommands.Command.COMMAND_TYPE.ObjectExpression; },
    isObjectPropertyCreationCommand: function() { return this.type == fcCommands.Command.COMMAND_TYPE.ObjectPropertyCreation; },

    isStartWithStatementCommand: function() { return this.type == fcCommands.Command.COMMAND_TYPE.StartWithStatement; },
    isEndWithStatementCommand: function() { return this.type == fcCommands.Command.COMMAND_TYPE.EndWithStatement; },

    isStartTryStatementCommand: function() { return this.type == fcCommands.Command.COMMAND_TYPE.StartTryStatement; },
    isEndTryStatementCommand: function() { return this.type == fcCommands.Command.COMMAND_TYPE.EndTryStatement; },

    isStartCatchStatementCommand: function() { return this.type == fcCommands.Command.COMMAND_TYPE.StartCatchStatement; },
    isEndCatchStatementCommand: function() { return this.type == fcCommands.Command.COMMAND_TYPE.EndCatchStatement; },

    isStartSwitchStatementCommand: function() { return this.type == fcCommands.Command.COMMAND_TYPE.StartSwitchStatement; },
    isCaseCommand: function() { return this.type == fcCommands.Command.COMMAND_TYPE.Case; },
    isEndSwitchStatementCommand: function() { return this.type == fcCommands.Command.COMMAND_TYPE.EndSwitchStatement; },

    isFunctionExpressionCreationCommand: function() { return this.type == fcCommands.Command.COMMAND_TYPE.FunctionExpressionCreation; },

    isEvalSequenceExpressionCommand: function() { return this.type == fcCommands.Command.COMMAND_TYPE.EvalSequenceExpression; },

    isEvalUnaryExpressionCommand: function() { return this.type == fcCommands.Command.COMMAND_TYPE.EvalUnaryExpression; },
    isEvalBinaryExpressionCommand: function() { return this.type == fcCommands.Command.COMMAND_TYPE.EvalBinaryExpression; },

    isStartLogicalExpressionCommand: function() { return this.type == fcCommands.Command.COMMAND_TYPE.StartEvalLogicalExpression; },
    isEvalLogicalExpressionItemCommand: function() { return this.type == fcCommands.Command.COMMAND_TYPE.EvalLogicalExpressionItem; },
    isEndLogicalExpressionCommand: function() { return this.type == fcCommands.Command.COMMAND_TYPE.EndEvalLogicalExpression; },

    isEvalAssignmentExpressionCommand: function() { return this.type == fcCommands.Command.COMMAND_TYPE.EvalAssignmentExpression; },
    isEvalUpdateExpressionCommand: function() { return this.type == fcCommands.Command.COMMAND_TYPE.EvalUpdateExpression; },

    isEvalBreakCommand: function() { return this.type == fcCommands.Command.COMMAND_TYPE.EvalBreak; },
    isEvalContinueCommand: function() { return this.type == fcCommands.Command.COMMAND_TYPE.EvalContinue; },

    isEvalConditionalExpressionCommand: function() { return this.type == fcCommands.Command.COMMAND_TYPE.EvalConditionalExpression; },
    isEndEvalConditionalExpressionCommand: function() { return this.type == fcCommands.Command.COMMAND_TYPE.EndEvalConditionalExpression; },
    isEvalConditionalExpressionBodyCommand: function() { return this.type == fcCommands.Command.COMMAND_TYPE.EvalConditionalExpressionBody; },

    isEvalNewExpressionCommand: function() { return this.type == fcCommands.Command.COMMAND_TYPE.EvalNewExpression; },

    isEvalCallExpressionCommand: function() { return this.type == fcCommands.Command.COMMAND_TYPE.EvalCallExpression; },

    isEnterFunctionContextCommand: function() { return this.type == fcCommands.Command.COMMAND_TYPE.EnterFunctionContext; },
    isExitFunctionContextCommand: function() { return this.type == fcCommands.Command.COMMAND_TYPE.ExitFunctionContext; },

    isEvalCallbackFunctionCommand: function() { return this.type == fcCommands.Command.COMMAND_TYPE.EvalCallbackFunction; },

    isEvalMemberExpressionCommand: function() { return this.type == fcCommands.Command.COMMAND_TYPE.EvalMemberExpression; },
    isEvalMemberExpressionPropertyCommand: function() { return this.type == fcCommands.Command.COMMAND_TYPE.EvalMemberExpressionProperty; },

    isEvalReturnExpressionCommand: function() { return this.type == fcCommands.Command.COMMAND_TYPE.EvalReturnExpression; },

    isEvalThrowExpressionCommand: function() { return this.type == fcCommands.Command.COMMAND_TYPE.EvalThrowExpression; },

    isEvalIdentifierCommand: function() { return this.type == fcCommands.Command.COMMAND_TYPE.EvalIdentifier; },
    isEvalLiteralCommand: function() { return this.type == fcCommands.Command.COMMAND_TYPE.EvalLiteral; },
    isEvalRegExCommand: function() { return this.type == fcCommands.Command.COMMAND_TYPE.EvalRegExLiteral; },

    isIfStatementCommand: function() { return this.type == fcCommands.Command.COMMAND_TYPE.IfStatement; },
    isEndIfCommand: function() { return this.type == fcCommands.Command.COMMAND_TYPE.EndIf; },

    isLoopStatementCommand: function()
    {
        return this.isWhileStatementCommand() || this.isDoWhileStatementCommand()
            || this.isForStatementCommand() || this.isEvalForInWhereCommand()
            || this.isStartDoWhileCommand();
    },

    isStartDoWhileCommand: function() { return this.type == fcCommands.Command.COMMAND_TYPE.StartDoWhileStatement; },
    isWhileStatementCommand: function() { return this.type == fcCommands.Command.COMMAND_TYPE.WhileStatement; },
    isDoWhileStatementCommand: function() { return this.type == fcCommands.Command.COMMAND_TYPE.DoWhileStatement; },
    isForStatementCommand: function() { return this.type == fcCommands.Command.COMMAND_TYPE.ForStatement; },
    isForUpdateStatementCommand: function() { return this.type == fcCommands.Command.COMMAND_TYPE.ForUpdateStatement; },
    isEvalForInWhereCommand: function() { return this.type == fcCommands.Command.COMMAND_TYPE.EvalForInWhere; },
    isEndLoopStatementCommand: function() { return this.type == fcCommands.Command.COMMAND_TYPE.EndLoopStatement ;},

    isCallInternalConstructorCommand: function() { return this.type == fcCommands.Command.COMMAND_TYPE.CallInternalConstructor; },
    isCallInternalFunctionCommand: function() { return this.type == fcCommands.Command.COMMAND_TYPE.CallInternalFunction; },
    isCallCallbackMethodCommand: function() { return this.type == fcCommands.Command.COMMAND_TYPE.CallCallbackMethod; },

    isExecuteCallbackCommand: function() { return this.type == fcCommands.Command.COMMAND_TYPE.ExecuteCallback; },

    isLabelCommand: function() { return this.type == fcCommands.Command.COMMAND_TYPE.Label; },

    isConvertToPrimitiveCommand: function() { return this.type == fcCommands.Command.COMMAND_TYPE.ConvertToPrimitive; },

    setCallbackFunction: function(callbackFunction)
    {
        this.callbackFunction = callbackFunction;
    },

    getLineNo: function()
    {
        return this.codeConstruct != null && this.codeConstruct.loc != null ? this.codeConstruct.loc.start.line : -1;
    },

    toString: function() { return this.id + ":" + this.type + "@" + this.codeConstruct.loc.start.line; }
};

Firecrow.Interpreter.Commands.Command.COMMAND_TYPE =
{
    DeclareVariable: "DeclareVariable",
    DeclareFunction: "DeclareFunction",

    ThisExpression: "ThisExpression",

    ArrayExpression: "ArrayExpression",
    ArrayExpressionItemCreation: "ArrayExpressionItemCreation",

    ObjectExpression: "ObjectExpression",
    ObjectPropertyCreation: "ObjectPropertyCreation",

    StartWithStatement: "StartWithStatement",
    EndWithStatement: "EndWithStatement",

    StartTryStatement: "StartTryStatement",
    EndTryStatement: "EndTryStatement",

    StartCatchStatement: "StartCatchStatement",
    EndCatchStatement: "EndCatchStatement",

    StartSwitchStatement: "StartSwitchStatement",
    EndSwitchStatement: "EndSwitchStatement",

    Case: "Case",

    FunctionExpressionCreation: "FunctionExpressionCreation",

    EvalSequenceExpression: "EvalSequenceExpression",
    EvalUnaryExpression: "EvalUnaryExpression",
    EvalBinaryExpression: "EvalBinaryExpression",
    EvalAssignmentExpression: "EvalAssignmentExpression",
    EvalUpdateExpression: "EvalUpdateExpression",

    EvalBreak: "EvalBreak",
    EvalContinue: "EvalContinue",

    EvalCallbackFunction: "EvalCallbackFunction",

    StartEvalLogicalExpression: "StartEvalLogicalExpression",
    EvalLogicalExpressionItem: "EvalLogicalExpressionItem",
    EndEvalLogicalExpression: "EndEvalLogicalExpression",

    EvalConditionalExpression: "EvalConditionalExpression",
    EndEvalConditionalExpression: "EndEvalConditionalExpression",
    EvalNewExpression: "EvalNewExpression",

    EvalCallExpression: "EvalCallExpression",

    EnterFunctionContext: "EnterFunctionContext",
    ExitFunctionContext: "ExitFunctionContext",

    EvalMemberExpression: "EvalMemberExpression",
    EvalMemberExpressionProperty: "EvalMemberExpressionProperty",

    EvalReturnExpression: "EvalReturnExpression",
    EvalThrowExpression: "EvalThrowExpression",

    EvalIdentifier: "EvalIdentifier",
    EvalLiteral: "EvalLiteral",
    EvalRegExLiteral: "EvalRegExLiteral",

    IfStatement: "IfStatement",
    EndIf: "EndIf",
    StartDoWhileStatement: "StartDoWhileStatement",
    WhileStatement: "WhileStatement",
    DoWhileStatement: "DoWhileStatement",

    ForStatement: "ForStatement",
    ForUpdateStatement: "ForUpdateStatement",

    EndLoopStatement: "EndLoopStatement",

    EvalForInWhere: "EvalForInWhere",

    EvalConditionalExpressionBody: "EvalConditionalExpressionBody",

    CallInternalConstructor: "CallInternalConstructor",
    CallInternalFunction: "CallInternalFunction",
    CallCallbackMethod: "CallCallbackMethod",

    ExecuteCallback: "ExecuteCallback",

    ConvertToPrimitive: "ConvertToPrimitive",

    Label: "Label"
};
/*************************************************************************************/
}});
FBL.ns(function() { with (FBL) {
/*************************************************************************************/
var fcModel = Firecrow.Interpreter.Model;
var ValueTypeHelper = Firecrow.ValueTypeHelper;

fcModel.fcValue = function(jsValue, iValue, codeConstruct, symbolicValue)
{
    try
    {
        this.id = fcModel.fcValue.LAST_ID++;
        this.jsValue = jsValue;
        this.iValue = iValue;
        this.codeConstruct = codeConstruct;
        this.symbolicValue = symbolicValue;

        if(this.iValue != null && this.iValue.isInternalFunction != undefined)
        {
            this.isInternalFunction = this.iValue.isInternalFunction;
        }
    }
    catch(e) { fcModel.fcValue.notifyError("Error when creating: " + e); }
};

fcModel.fcValue.LAST_ID = 0;
fcModel.fcValue.notifyError = function(message) { alert("FcValue - " + message); }

fcModel.fcValue.prototype =
{
    isFunction: function() { return ValueTypeHelper.isFunction(this.jsValue); },
    isPrimitive: function() { return ValueTypeHelper.isPrimitive(this.jsValue); },
    isSymbolic: function() { return this.symbolicValue != null; },
    isNotSymbolic: function() { return this.symbolicValue == null; },

    getPropertyValue: function(propertyName)
    {
        if(propertyName == null || propertyName == "") { fcModel.fcValue.notifyError("When getting property value, the property name must not be empty!"); return; }

        if(ValueTypeHelper.isPrimitive(this.jsValue)) { fcModel.fcValue.notifyError("Still not handling getting properties from primitives"); return; }

        return null;
    },

    createCopy: function(codeConstruct)
    {
        return new fcModel.fcValue(this.jsValue, this.iValue, this.codeConstruct, this.symbolicValue);
    }
};
}});FBL.ns(function() { with (FBL) {
/*************************************************************************************/
var fcModel = Firecrow.Interpreter.Model;
var ValueTypeHelper = Firecrow.ValueTypeHelper;
var fcSimulator = Firecrow.Interpreter.Simulator;

fcModel.Object = function() {};

//<editor-fold desc="'Static' functions">
fcModel.Object.createObjectWithInit = function(globalObject, codeConstruct, implementationObject, proto)
{
    return (new fcModel.Object()).initObject(globalObject, codeConstruct, implementationObject, proto);
}

fcModel.Object.LAST_ID = 0;
//a flag that disables slicing of array objects, setting it to false causes that dependencies between items in array-like objects are not created.
fcModel.Object.MONOLITIC_ARRAYS = true;

fcModel.Object.notifyError = function(message) { debugger; alert("Object - " + message); }
//</editor-fold>

//<editor-fold desc="Prototype definition">
fcModel.Object.prototype =
{
    //<editor-fold desc="Object Initialization">
    initObject: function(globalObject, codeConstruct, implementationObject, proto)
    {
        this.id = fcModel.Object.LAST_ID++;

        this.globalObject = globalObject;
        this.implementationObject = implementationObject;
        this.creationCodeConstruct = codeConstruct;

        this.properties = [];
        this.enumeratedProperties = [];
        this.modifications = [];
        this.propertyDeletionPositionMap = {};

        this.addProperty("__proto__", proto, codeConstruct, false);

        if(codeConstruct != null && globalObject != null)
        {
            this._addModification(codeConstruct, globalObject.getPreciseEvaluationPositionId());
        }

        this.objectModifiedCallbackDescriptors = null;
        this.addPropertyCallbackDescriptors = null;
        this.getPropertyCallbackDescriptors = null;

        if(this.globalObject.executionContextStack != null)
        {
            this.creationContext = this.globalObject.executionContextStack.activeContext;
        }

        return this;
    },

    deconstructObject: function()
    {
        delete this.globalObject;
        delete this.implementationObject;
        delete this.creationCodeConstruct;

        delete this.properties;
        delete this.enumeratedProperties;
        delete this.modifications;

        delete this.objectModifiedCallbackDescriptors;
        delete this.addPropertyCallbackDescriptors;
        delete this.getPropertyCallbackDescriptors;

        delete this.creationContext;
    },
    //</editor-fold>

    //<editor-fold desc="Property Getters">
    getOwnProperty: function(propertyName)
    {
        return ValueTypeHelper.findInArray
        (
            this.properties,
            propertyName,
            function(property, propertyName) { return property.name == propertyName; }
        );
    },

    getEnumeratedPropertyNames: function()
    {
        return this._getEnumeratedPropertiesFromImplementationObject();
    },

    getOwnPropertyNames: function()
    {
        var propertyNames = [];

        var properties = this.properties;

        for(var i = 0, propertyLength = properties.length; i < propertyLength; i++)
        {
            propertyNames.push(properties[i].name);
        }

        return propertyNames;
    },

    isOwnProperty: function(propertyName)
    {
        return this.getOwnProperty(propertyName) != null;
    },

    getInternalPrototypeChain: function()
    {
        var prototypeChain = this.getPrototypeChain().concat([this]);

        var internalPrototypeChain = [];

        for(var i = 0; i < prototypeChain.length; i++)
        {
            if(this.globalObject.isInternalPrototype(prototypeChain[i]))
            {
                internalPrototypeChain.push(prototypeChain[i]);
            }
        }

        return internalPrototypeChain;
    },

    getPrototypeChain: function()
    {
        var chain = [];

        if(this.proto != null)
        {
            chain.push(this.proto.iValue);
            ValueTypeHelper.pushAll(chain, this.proto.iValue.getPrototypeChain());
        }

        return chain;
    },

    getProperty: function(propertyName, readPropertyConstruct)
    {
        try
        {
            var property = this.getOwnProperty(propertyName);

            if(property != null)
            {
                this._callCallbacks(this.getPropertyCallbackDescriptors, [readPropertyConstruct, propertyName]);

                return property;
            }

            if(this.proto == null) { return null; }

            property = this.proto.iValue.getProperty(propertyName, readPropertyConstruct);

            this._addDependenciesToPrototypeProperty(property, readPropertyConstruct);

            return property;
        }
        catch(e)
        {
            fcModel.Object.notifyError("Error when getting property:" + e);
        }
    },

    getJsPropertyValue: function(propertyName, codeConstruct)
    {
        return this.getPropertyValue(propertyName, codeConstruct);
    },

    getPropertyValue: function(propertyName, codeConstruct)
    {
        var property = this.getProperty(propertyName, codeConstruct);

        return property != null ? property.value
                                : undefined;
    },

    getLastPropertyModifications: function(codeConstruct)
    {
        var propertyNames = this._getEnumeratedPropertiesFromImplementationObject();

        var lastModifications = [];

        for(var i = 0, length = propertyNames.length; i < length; i++)
        {
            var property = this.getProperty(propertyNames[i], codeConstruct);

            if(property != null && property.lastModificationPosition != null)
            {
                lastModifications.push(property.lastModificationPosition);
            }
        }

        return lastModifications;
    },

    getPropertyNames: function()
    {
        return this._getEnumeratedPropertiesFromImplementationObject();
    },

    getPropertyNameAtIndex: function(index, codeConstruct)
    {
        var propertyName = this._getEnumeratedPropertiesFromImplementationObject()[index];
        return this.globalObject.internalExecutor.createInternalPrimitiveObject(codeConstruct, propertyName);
    },

    getPropertiesWithIndexNames: function()
    {
        var indexProperties = [];

        for(var i = 0; i < this.properties.length; i++)
        {
            if(ValueTypeHelper.isInteger(parseInt(this.properties[i].name)))
            {
                indexProperties.push(this.properties[i]);
            }
        }

        return indexProperties;
    },

    getUserDefinedProperties: function()
    {
        var userDefinedProperties = [];

        for(var i = 0; i < this.properties.length; i++)
        {
            var property = this.properties[i];

            if(property.declarationPosition != null)
            {
                userDefinedProperties.push(property);
            }
        }

        return userDefinedProperties;
    },
    //</editor-fold>

    //<editor-fold desc="Property Setters">
    addProperty: function(propertyName, propertyValue, codeConstruct, isEnumerable, optConfigurable, optWritable)
    {
        try
        {
            if(this.preventExtensions) { return; }
            if(propertyName == "__proto__") { this.setProto(propertyValue, codeConstruct); return; }

            var property = this.getOwnProperty(propertyName);

            if(property == null)
            {
                property = new fcModel.Identifier(propertyName, propertyValue, codeConstruct, this.globalObject);

                this.properties.push(property);

                if(isEnumerable) { this.enumeratedProperties.push(property); }
            }
            else
            {
                property.setValue(propertyValue, codeConstruct);
            }

            if(isEnumerable === true || isEnumerable === false)
            {
                property.enumerable = isEnumerable;
            }

            if(optConfigurable === true || optConfigurable === false)
            {
                property.configurable = optConfigurable;
            }

            if(optWritable === true || optWritable === false)
            {
                property.writable = optWritable;
            }

            if(propertyName == "prototype" && propertyValue != null && codeConstruct != null)
            {
                this.prototypeDefinitionConstruct = { codeConstruct: codeConstruct, evaluationPositionId: this.globalObject.getPreciseEvaluationPositionId()};
            }

            if(codeConstruct != null)
            {
                this._addModification(codeConstruct, this.globalObject.getPreciseEvaluationPositionId(), propertyName);
            }

            this._callCallbacks(this.addPropertyCallbackDescriptors, [propertyName, propertyValue, codeConstruct]);
        }
        catch(e) { fcModel.Object.notifyError("Error when adding property:" + e); }
    },

    setProto: function(proto, codeConstruct)
    {
        this.proto = proto;

        if(this.implementationObject != null && proto != null)
        {
            try
            {
                //Firefox throws an exception
                this.implementationObject.__proto__ = proto.jsValue;
            }
            catch(e)
            {
                //debugger;
            }
        }

        if(codeConstruct != null)
        {
            this._addModification(codeConstruct, this.globalObject.getPreciseEvaluationPositionId());
        }
    },
    //</editor-fold>

    //<editor-fold desc="Property Deleter">
    deleteProperty: function(propertyName, codeConstruct)
    {
        try
        {
            for(var i = 0; i < this.properties.length; i++)
            {
                if(this.properties[i].name == propertyName)
                {
                    ValueTypeHelper.removeFromArrayByIndex(this.properties, i);
                    this.propertyDeletionPositionMap[propertyName] =
                    {
                        codeConstruct: codeConstruct,
                        evaluationPosition: this.globalObject.getPreciseEvaluationPositionId()
                    };
                    this._addModification(codeConstruct, this.globalObject.getPreciseEvaluationPositionId(), propertyName);
                    break;
                }
            }

            for(var i = 0; i < this.enumeratedProperties.length; i++)
            {
                if(this.enumeratedProperties[i].name == propertyName)
                {
                    ValueTypeHelper.removeFromArrayByIndex(this.enumeratedProperties, i);
                    break;
                }
            }
        }
        catch(e) { fcModel.Object.notifyError("Error when deleting property:" + e);}
    },

    getPropertyDeletionPosition: function(propertyName)
    {
        return this.propertyDeletionPositionMap[propertyName];
    },
    //</editor-fold>

    //<editor-fold desc="Misc public methods">
    registerPreventExtensionPosition: function(codeConstruct)
    {
        this.preventExtensionPosition = { codeConstruct : codeConstruct, evaluationPositionId: this.globalObject.getPreciseEvaluationPositionId() };
    },

    isPrimitive: function() { return false },
    //</editor-fold>

    //<editor-fold desc="Callbacks">
    registerObjectModifiedCallbackDescriptor: function(callback, thisValue)
    {
        if(this.objectModifiedCallbackDescriptors == null) { this.objectModifiedCallbackDescriptors = [];}

        this.objectModifiedCallbackDescriptors.push({callback: callback, thisValue: thisValue});
    },

    registerGetPropertyCallback: function(callback, thisValue)
    {
        if(this.getPropertyCallbackDescriptors == null) { this.getPropertyCallbackDescriptors = []; }

        this.getPropertyCallbackDescriptors.push({ callback: callback, thisValue: thisValue});
    },

    registerAddPropertyCallback: function(callback, thisValue)
    {
        if(this.addPropertyCallbackDescriptors == null) { this.addPropertyCallbackDescriptors = []; }

        this.addPropertyCallbackDescriptors.push({ callback: callback, thisValue: thisValue});
    },

    _callCallbacks: function(callbackDescriptors, args)
    {
        if(callbackDescriptors == null || callbackDescriptors.length == 0) { return; }

        for(var i = 0, length = callbackDescriptors.length; i < length; i++)
        {
            var callbackDescriptor = callbackDescriptors[i];
            callbackDescriptor.callback.apply(callbackDescriptor.thisValue, args);
        }
    },
    //</editor-fold>

    //<editor-fold desc="Dependencies to Modifications">
    addDependencyToAllModifications: function(codeConstruct, modifications)
    {
        modifications = modifications || this.modifications;
        if(codeConstruct == null || modifications == null || modifications.length == 0 || !fcModel.Object.MONOLITIC_ARRAYS) { return; }

        var evaluationPosition = this.globalObject.getPreciseEvaluationPositionId();

        for(var i = 0, length = modifications.length; i < length; i++)
        {
            var modification = modifications[i];

            this.globalObject.dependencyCreator.createDataDependency
            (
                codeConstruct,
                modification.codeConstruct,
                evaluationPosition,
                modification.evaluationPositionId
            );
        }
    },

    addDependenciesToAllProperties: function(codeConstruct)
    {
        try
        {
            if(codeConstruct == null || !fcModel.Object.MONOLITIC_ARRAYS) { return; }

            if(this.dummyDependencyNode == null)
            {
                this.dummyDependencyNode = { type: "DummyCodeElement", id: this.id, mainObjectCreationCodeConstruct: this.creationCodeConstruct, nodeId: "D" + this.globalObject.DYNAMIC_NODE_COUNTER++};
                this.globalObject.browser.callNodeCreatedCallbacks(this.dummyDependencyNode, "js", true);
            }

            this.globalObject.dependencyCreator.createDataDependency
            (
                codeConstruct,
                this.dummyDependencyNode,
                this.globalObject.getPreciseEvaluationPositionId()
            );
        }
        catch(e) { debugger; fcModel.Object.notifyError("Error when adding dependencies to all properties: " + e); }
    },

    addModification: function(codeConstruct, propertyName)
    {
        if(codeConstruct == null) { return; }

        this._addModification(codeConstruct, this.globalObject.getPreciseEvaluationPositionId(), propertyName);
    },
    //</editor-fold>

    //<editor-fold desc="'Private' methods">
    _addModification: function(codeConstruct, evaluationPositionId, propertyName)
    {
        try
        {
            if(codeConstruct == null) { return; }
            if(!ValueTypeHelper.isStringInteger(propertyName) && propertyName != "length") { return; }

            var modificationDescription = { codeConstruct: codeConstruct, evaluationPositionId: evaluationPositionId };

            this.modifications.push(modificationDescription);

            this._callCallbacks(this.objectModifiedCallbackDescriptors, [modificationDescription]);
        }
        catch(e) { fcModel.Object.notifyError("Error when adding modification:" + e);}
    },

    _addDependenciesToPrototypeProperty: function(property, readPropertyConstruct)
    {
        if(property == null) { return; }

        if(this.prototypeDefinitionConstruct != null)
        {
            this.globalObject.dependencyCreator.createDataDependency
            (
                readPropertyConstruct,
                this.prototypeDefinitionConstruct.codeConstruct,
                this.globalObject.getPreciseEvaluationPositionId(),
                this.prototypeDefinitionConstruct.evaluationPositionId
            );
        }

        if(property.lastModificationPosition != null)
        {
            this.globalObject.dependencyCreator.createDataDependency
            (
                readPropertyConstruct,
                property.lastModificationPosition.codeConstruct,
                this.globalObject.getPreciseEvaluationPositionId(),
                property.lastModificationPosition.evaluationPositionId
            );
        }
    },

    _getEnumeratedPropertiesFromImplementationObject: function()
    {
        var properties = [];

        if(this.implementationObject != null)
        {
            for(var property in this.implementationObject)
            {
                //TODO - possible problem
                if(property == "constructor" && !this.implementationObject.hasOwnProperty(property)) { continue; }

                properties.push(property);
            }
        }

        return properties;
    },
    //</editor-fold>

    isDefinedInCurrentContext: function()
    {
        return this.creationContext == this.globalObject.executionContextStack.activeContext;
    }
};
//</editor-fold>
/*************************************************************************************/
}});/**
 * User: Jomaras
 * Date: 06.11.12.
 * Time: 08:34
 */
FBL.ns(function() { with (FBL) {
/*************************************************************************************/
var fcModel = Firecrow.Interpreter.Model;

fcModel.ObjectPrototype = function(globalObject)
{
    this.initObject(globalObject);
    this.constructor = fcModel.ObjectPrototype;
    this.name = "ObjectPrototype";
};

fcModel.ObjectPrototype.prototype = new fcModel.Object();
fcModel.ObjectPrototype.prototype.initMethods = function()
{
    fcModel.ObjectPrototype.CONST.INTERNAL_PROPERTIES.METHODS.forEach(function(propertyName)
    {
        this.addProperty
        (
            propertyName,
            new fcModel.fcValue
            (
                Object.prototype[propertyName],
                fcModel.Function.createInternalNamedFunction(this.globalObject, propertyName, this),
                null
            ),
            null,
            false
        );
    }, this);
};

fcModel.ObjectPrototype.CONST =
{
    INTERNAL_PROPERTIES :
    {
        METHODS: ["toString", "hasOwnProperty", "isPrototypeOf", "valueOf", "propertyIsEnumerable"]
    }
};
/*************************************************************************************/
}});FBL.ns(function() { with (FBL) {
/*************************************************************************************/
var fcModel = Firecrow.Interpreter.Model;
fcModel.ObjectFunction = function(globalObject)
{
    try
    {
        this.initObject(globalObject);

        this.addProperty("prototype", globalObject.fcObjectPrototype);

        this.isInternalFunction = true;
        this.name = "Object";

        fcModel.ObjectFunction.CONST.INTERNAL_PROPERTIES.METHODS.forEach(function(propertyName)
        {
            this.addProperty
            (
                propertyName,
                new fcModel.fcValue
                (
                    Object[propertyName],
                    fcModel.Function.createInternalNamedFunction(globalObject, propertyName, this),
                    null
                ),
                null,
                false
            );
        }, this);
    }
    catch(e){ fcModel.Object.notifyError("Error when creating Object Function:" + e); }
};

fcModel.ObjectFunction.prototype = new fcModel.Object();

fcModel.ObjectFunction.CONST =
{
    INTERNAL_PROPERTIES:
    {
        METHODS:
        [
            "create", "defineProperty", "defineProperties", "getOwnPropertyDescriptor",
            "keys", "getOwnPropertyNames", "getPrototypeOf", "preventExtensions", "seal",
            "isSealed", "freeze", "isFrozen", "isExtensible", "propertyIsEnumerable"
        ]
    }
};
/*************************************************************************************/
}});FBL.ns(function() { with (FBL) {
/*************************************************************************************/
var fcModel = Firecrow.Interpreter.Model;
var ASTHelper = Firecrow.ASTHelper;
var fcSimulator = Firecrow.Interpreter.Simulator;
var ValueTypeHelper = Firecrow.ValueTypeHelper;

fcModel.ObjectExecutor =
{
    isInternalObjectMethod: function(potentialFunction)
    {
        var methods = fcModel.ObjectFunction.CONST.INTERNAL_PROPERTIES.METHODS;

        for(var i = 0; i < methods.length; i++)
        {
            if(Object[methods[i]] === potentialFunction)
            {
                return true;
            }
        }

        return false;
    },

    executeInternalMethod: function(thisObject, functionObject, args, callExpression, callCommand)
    {
        if(functionObject.jsValue.name == "hasOwnProperty")
        {
            return this._executeHasOwnProperty(thisObject, args, callExpression);
        }
        else if (functionObject.jsValue.name == "toString")
        {
            var result = "";

            if(callCommand != null && (callCommand.isCall || callCommand.isApply))
            {
                result = Object.prototype.toString.call(thisObject.jsValue);
            }
            else
            {
                result = thisObject.jsValue.toString();
            }

            return functionObject.iValue.globalObject.internalExecutor.createInternalPrimitiveObject(callExpression, result);
        }
        else
        {
            fcModel.Object.notifyError("Unknown ObjectExecutor method");
        }
    },

    executeInternalObjectFunctionMethod: function(thisObject, functionObject, args, callExpression, callCommand)
    {
        var functionObjectValue = functionObject.jsValue;
        var thisObjectValue = thisObject.jsValue;
        var functionName = functionObjectValue.name;
        var fcThisValue =  thisObject.iValue;
        var globalObject = fcThisValue != null ? fcThisValue.globalObject
                                               : functionObjectValue.fcValue.iValue.globalObject;
        var argumentValues = globalObject.getJsValues(args);

        switch(functionName)
        {
            case "create":
                return this._executeCreate(callExpression, args, globalObject);
            case "defineProperty":
                return this._executeDefineProperty(callExpression, args, globalObject);
            case "defineProperties":
                return this._executeDefineProperties(callExpression, args, globalObject);
            case "getOwnPropertyDescriptor":
                return this._executeGetOwnPropertyDescriptor(callExpression, args, globalObject);
            case "getOwnPropertyNames":
                return this._getOwnPropertyNames(callExpression, args, globalObject);
            case "keys":
                return this._executeKeys(callExpression, args, globalObject);
            case "getPrototypeOf":
                return this._executeGetPrototypeOf(callExpression, args, globalObject);
            case "preventExtensions":
                return this._preventExtensions(callExpression, args, globalObject);
            case "isExtensible":
                return this._isExtensible(callExpression, args, globalObject);
            case "seal":
                return this._seal(callExpression, args, globalObject);
            case "isSealed":
                return this._isSealed(callExpression, args, globalObject);
            case "propertyIsEnumerable":
                return this._propertyIsEnumerable(thisObject, argumentValues, globalObject, callExpression)
            default:
                alert("Object Function unhandled function: " + functionName);
        }
    },

    _executeCreate: function(callExpression, args, globalObject)
    {
        if(args.length == 0) { fcModel.Object.notifyError("Can not call Object.create with zero parameters"); return null; }

        var baseObject = {};

        var newlyCreatedObject = new fcModel.fcValue
        (
            baseObject,
            fcModel.Object.createObjectWithInit(globalObject, callExpression, baseObject, args[0]),
            callExpression
        );

        if(args.length > 1)
        {
            this._definePropertiesOnObject(newlyCreatedObject, args[1], globalObject, callExpression);
        }

        return newlyCreatedObject;
    },

    _executeDefineProperties: function(callExpression, args, globalObject)
    {
        if(args.length < 2) { fcModel.Object.notifyError("Object.defineProperties can not have less than 2 arguments"); return null;}

        this._definePropertiesOnObject(args[0], args[1], globalObject, callExpression);
    },

    _definePropertiesOnObject: function(fcBaseObject, propertyDescriptorsMap, globalObject, callExpression)
    {
        var jsPropertyDescriptorsMap = propertyDescriptorsMap.jsValue;
        var fcPropertyDescriptorsMap = propertyDescriptorsMap.iValue;

        var iObject = fcBaseObject.iValue;

        var dependencyCreator = globalObject.dependencyCreator;

        for(var propName in jsPropertyDescriptorsMap)
        {
            var propertyDescriptor = fcPropertyDescriptorsMap.getPropertyValue(propName);

            var configurable = this._getPropertyDescriptorValue(propertyDescriptor.jsValue, "configurable", false);
            var enumerable = this._getPropertyDescriptorValue(propertyDescriptor.jsValue, "enumerable", false);
            var writable = this._getPropertyDescriptorValue(propertyDescriptor.jsValue, "writable", false);
            var get = this._getPropertyDescriptorValue(propertyDescriptor.jsValue, "get", null);
            var set = this._getPropertyDescriptorValue(propertyDescriptor.jsValue, "set", null);

            if(get != null || set != null) { fcModel.Object.notifyError("Still does not handle defining getters and setters"); return; }

            var propertyValue = propertyDescriptor.iValue.getPropertyValue("value");

            dependencyCreator.createDataDependency(propertyDescriptor.codeConstruct, callExpression);
            dependencyCreator.createDependenciesForObjectPropertyDefinition(propertyDescriptor.codeConstruct);

            Object.defineProperty(fcBaseObject.jsValue, propName,
            {
                configurable: configurable,
                enumerable: enumerable,
                writable: writable,
                value: propertyValue
            });

            iObject.addModification(callExpression, propName);
            iObject.addProperty(propName, propertyValue, propertyDescriptor.codeConstruct, enumerable, configurable, writable);
        }
    },

    _executeDefineProperty: function(callExpression, args, globalObject)
    {
        if(args.length < 3) { fcModel.Object.notifyError("Can not call Object.defineProperty with less than 3 parameters"); return; }

        var propertyName = args[1].jsValue;

        var jsPropertyDescriptorMap = args[2].jsValue;

        var configurable = this._getPropertyDescriptorValue(jsPropertyDescriptorMap, "configurable", false);
        var enumerable = this._getPropertyDescriptorValue(jsPropertyDescriptorMap, "enumerable", false);
        var writable = this._getPropertyDescriptorValue(jsPropertyDescriptorMap, "writable", false);
        var get = this._getPropertyDescriptorValue(jsPropertyDescriptorMap, "get", null);
        var set = this._getPropertyDescriptorValue(jsPropertyDescriptorMap, "set", null);
        var value = jsPropertyDescriptorMap.value;

        if(get != null || set != null) { fcModel.Object.notifyError("Still does not handle defining getters and setters"); return; }
        if(value == null) { fcModel.Object.notifyError("Value must be set when definining property"); return; }

        args[0].iValue.addModification(callExpression, propertyName);

        var dependencyCreator = globalObject.dependencyCreator;

        dependencyCreator.createDataDependency(args[2].codeConstruct, callExpression);
        dependencyCreator.createDependenciesForObjectPropertyDefinition(args[2].codeConstruct);

        Object.defineProperty(args[0].jsValue, propertyName,
        {
            configurable: configurable,
            enumerable: enumerable,
            writable: writable,
            value: value
        });

        args[0].iValue.addProperty(propertyName, jsPropertyDescriptorMap.value, args[2].codeConstruct, enumerable, configurable, writable);
    },

    _executeGetOwnPropertyDescriptor: function(callExpression, args, globalObject)
    {
        if(args.length < 1) { fcModel.Object.notifyError("Can not call getOwnPropertyDescriptor with 0 arguments"); return null; }

        if(args.length == 1) { return globalObject.internalExecutor.createInternalPrimitiveObject(callExpression, undefined); }

        var property = args[0].iValue.getOwnProperty(args[1].jsValue);

        if(property == null) { return globalObject.internalExecutor.createInternalPrimitiveObject(callExpression, undefined); }

        var baseObject = {};

        var newlyCreatedObject = new fcModel.fcValue
        (
            baseObject,
            fcModel.Object.createObjectWithInit(globalObject, callExpression, baseObject),
            callExpression
        );

        baseObject.configurable = globalObject.internalExecutor.createInternalPrimitiveObject(callExpression, property.configurable);
        baseObject.enumerable = globalObject.internalExecutor.createInternalPrimitiveObject(callExpression, property.enumerable);
        baseObject.writable = globalObject.internalExecutor.createInternalPrimitiveObject(callExpression, property.writable);
        baseObject.value = property.value;

        newlyCreatedObject.iValue.addProperty("configurable", baseObject.configurable, callExpression, true, true, true);
        newlyCreatedObject.iValue.addProperty("enumerable", baseObject.enumerable, callExpression, true, true, true);
        newlyCreatedObject.iValue.addProperty("writable", baseObject.writable, callExpression, true, true, true);
        newlyCreatedObject.iValue.addProperty("value", baseObject.value, callExpression, true, true, true);

        return newlyCreatedObject;
    },

    _executeKeys: function(callExpression, args, globalObject)
    {
        if(args.length == 0) { fcModel.Object.notifyError("Can not call Object.keys with 0 arguments"); return null; }

        if(args[0] == null || args[0].iValue == null) { fcModel.Object.notifyError("Object keys argument hast to have iValue"); return null; }

        return this._createArrayFromPropertyNames(args[0].iValue, args[0].iValue.getEnumeratedPropertyNames(), globalObject, callExpression);
    },

    _getOwnPropertyNames: function(callExpression, args, globalObject)
    {
        if(args.length == 0) { fcModel.Object.notifyError("Can not call Object.keys with 0 arguments"); return null; }

        if(args[0] == null || args[0].iValue == null) { fcModel.Object.notifyError("Object keys argument hast to have iValue"); return null; }

        return this._createArrayFromPropertyNames(args[0].iValue, args[0].iValue.getOwnPropertyNames(), globalObject, callExpression);
    },

    _executeGetPrototypeOf: function(callExpression, args, globalObject)
    {
        if(args.length == 0) { fcModel.Object.notifyError("Can not call Object.getPrototypeOf with 0 arguments"); return null; }

        if(args[0] == null || args[0].iValue == null) { fcModel.Object.notifyError("Object getPrototypeOf argument hast to have iValue"); return null; }

        return args[0].iValue.proto;
    },

    _preventExtensions: function(callExpression, args, globalObject)
    {
        if(args.length == 0) { fcModel.Object.notifyError("Can not call Object.preventExtensions with 0 arguments"); return null; }

        if(args[0] == null || args[0].iValue == null) { fcModel.Object.notifyError("Object preventExtensions argument hast to have iValue"); return null; }

        Object.preventExtensions(args[0].jsValue);
        args[0].iValue.preventExtensions = true;
        args[0].iValue.registerPreventExtensionPosition(callExpression);

        return args[0];
    },

    _isExtensible: function(callExpression, args, globalObject)
    {
        if(args.length == 0) { fcModel.Object.notifyError("Can not call Object.isExtensible with 0 arguments"); return null; }

        if(args[0] == null || args[0].iValue == null) { fcModel.Object.notifyError("Object isExtensible argument hast to have iValue"); return null; }

        var dependencyCreator = globalObject.dependencyCreator;

        if(args[0].iValue.preventExtensionPosition != null)
        {
            dependencyCreator.createDataDependency(callExpression, args[0].iValue.preventExtensionPosition.codeConstruct, args[0].iValue.preventExtensionPosition.evaluationPositionId);
        }

        return globalObject.internalExecutor.createInternalPrimitiveObject(callExpression, !args[0].iValue.preventExtensions);
    },

    _propertyIsEnumerable: function(thisObject, argumentValues, globalObject, callExpression)
    {
        return globalObject.internalExecutor.createInternalPrimitiveObject(callExpression, thisObject.jsValue.propertyIsEnumerable(argumentValues[0]));
    },

    _createArrayFromPropertyNames: function(iObject, propertyNames, globalObject, callExpression)
    {
        var propertyKeysArray = [];

        for(var i = 0; i < propertyNames.length; i++)
        {
            var propertyName = propertyNames[i];

            var property = iObject.getProperty(propertyName);

            if(property == null) { continue; }

            var propertyConstruct = property.declarationPosition != null ? property.declarationPosition.codeConstruct : null;

            propertyKeysArray.push
            (
                globalObject.internalExecutor.createInternalPrimitiveObject
                (
                    propertyConstruct,
                    propertyName
                )
            );
        }

        return globalObject.internalExecutor.createArray(callExpression, propertyKeysArray);
    },

    _getPropertyDescriptorValue: function(propertyDescriptorMap, propertyName, defaultValue)
    {
        return propertyDescriptorMap[propertyName] != null ? propertyDescriptorMap[propertyName].jsValue
                                                           : defaultValue;
    },

    executeInternalConstructor: function(constructorConstruct, args, globalObject)
    {
        var newlyCreatedObject = null;

        if (args.length == 0)
        {
            return globalObject.internalExecutor.createNonConstructorObject(constructorConstruct, new Object());
        }

        var firstArgument = args[0];

        if(firstArgument.jsValue == null)
        {
            return globalObject.internalExecutor.createNonConstructorObject(constructorConstruct, new Object(firstArgument.jsValue));
        }
        else if (ValueTypeHelper.isBoolean(firstArgument.jsValue))
        {
            return new fcModel.fcValue
            (
                new Boolean(firstArgument.jsValue),
                new fcModel.Boolean(firstArgument.jsValue, globalObject, constructorConstruct),
                constructorConstruct
            );
        }
        else if(ValueTypeHelper.isString(firstArgument.jsValue))
        {
            return new fcModel.fcValue
            (
                new String(firstArgument.jsValue),
                new fcModel.String(firstArgument.jsValue, globalObject, constructorConstruct),
                constructorConstruct
            );
        }
        else if(ValueTypeHelper.isNumber(firstArgument.jsValue))
        {
            return new fcModel.fcValue
            (
                new Number(firstArgument.jsValue),
                new fcModel.Number(firstArgument.jsValue, globalObject, constructorConstruct),
                constructorConstruct
            );
        }
        else
        {
            return args[0];
        }
    },

    _executeHasOwnProperty: function(thisObject, args, callExpression)
    {
        if(thisObject == null || thisObject.iValue == null || args == null || args.length <= 0) { fcModel.Object.notifyError("Invalid argument when executing hasOwnProperty");}

        var result = thisObject.iValue.isOwnProperty(args[0].jsValue);

        return thisObject.iValue.globalObject.internalExecutor.createInternalPrimitiveObject(callExpression, result);
    }
};
/*************************************************************************************/
}});FBL.ns(function() { with (FBL) {
/*************************************************************************************/
var fcModel = Firecrow.Interpreter.Model;
var ValueTypeHelper = Firecrow.ValueTypeHelper;

fcModel.GlobalObject = function(browser)
{
    try
    {
        this.initObject(this);

        this._expandToFcValue();
        ValueTypeHelper.expand(this, fcModel.EventListenerMixin);

        Firecrow.Interpreter.Simulator.VariableObject.liftToVariableObject(this);

        this.internalExecutor = new Firecrow.Interpreter.Simulator.InternalExecutor(this);

        this._setExecutionEnvironment(browser);
        this._detectExecutionEnvironmentProperties();

        this._createInternalPrototypes();
        this._createInternalObjects();
        this._createInternalVariables();
        this._createInternalFunctions();

        this._createSlicingVariables();

        this._createHandlerMaps();

        this._createEvaluationPositionProperties();

        this._EXECUTION_COMMAND_COUNTER = 0;
        this.TIMEOUT_ID_COUNTER = 0;
        this.DYNAMIC_NODE_COUNTER = 0;

        this.isGlobalObject = true;
        this.shouldTrackIdentifiers = fcModel.GlobalObject.shouldTrackIdentifiers;
    }
    catch(e)
    {
        fcModel.GlobalObject.notifyError("Error when initializing global object:" + e + ";; " + e.stack);
    }
};

//<editor-fold desc="'Static' properties">
fcModel.GlobalObject.notifyError = function(message) { debugger; alert("GlobalObject - " + message); }
fcModel.GlobalObject.CONST =
{
    INTERNAL_PROPERTIES:
    {
        METHODS :
        [
            "decodeURI", "decodeURIComponent", "encodeURI",
            "encodeURIComponent", "eval", "isFinite", "isNaN",
            "parseFloat", "parseInt", "addEventListener", "removeEventListener",
            "setTimeout", "clearTimeout", "setInterval", "clearInterval",
            "getComputedStyle", "unescape", "escape", "alert",
            //Testing methods
            "assert", "assertEquals", "assertMatch", "assertNull", "assertNotNull", "assertEqual", "assertNotEquals"
        ],
        EVENT_PROPERTIES:
        [
            "onabort", "onbeforeunload", "onblur", "onchange", "onclick", "onclose",
            "oncontextmenu", "ondevicemotion", "ondeviceorientation", "ondragdrop",
            "onerror", "onfocus", "onhaschange", "onkeydown", "onkeypress", "onkeyup",
            "onload", "onmousedown", "onmousemove", "onmouseout", "onmouseover", "onmouseup",
            "onmozbeforepaint", "onpaint", "onpopstate", "onreset", "onresize", "onscroll",
            "onselect", "onsubmit", "onunload", "onpageshow", "onpagehide", "onmousewheel "
        ],
        SIZE_PROPERTIES: ["screenX", "screenY", "innerWidth", "innerHeight"]
    },
    isSizeProperty: function(propertyName) { return this.INTERNAL_PROPERTIES.SIZE_PROPERTIES.indexOf(propertyName) != -1; },
    isMethod: function(methodName) { return this.INTERNAL_PROPERTIES.METHODS.indexOf(methodName) != -1; },
    isEventProperty: function(propertyName) { return this.INTERNAL_PROPERTIES.EVENT_PROPERTIES.indexOf(propertyName) != -1; }
};
//</editor-fold>

fcModel.GlobalObject.prototype = new fcModel.Object();

//<editor-fold desc="Property Accessors">
fcModel.GlobalObject.prototype.getJsPropertyValue = function(propertyName, codeConstruct)
{
    var propertyValue = this.getPropertyValue(propertyName, codeConstruct);

    if(propertyValue === undefined) { this.browser.logAccessingUndefinedProperty(propertyName, codeConstruct); }
    if(fcModel.GlobalObject.CONST.isSizeProperty(propertyName)) { this.browser.logAccessingSizeProperty(propertyName, codeConstruct); }

    return propertyValue;
};

fcModel.GlobalObject.prototype.addJsProperty = function(propertyName, value, codeConstruct)
{
    this.addProperty(propertyName, value, codeConstruct);

    if(fcModel.GlobalObject.CONST.isEventProperty(propertyName))
    {
        this.eventHandlerPropertiesMap[propertyName] = codeConstruct;

        if(propertyName == "onresize")
        {
            this._registerResizeHandler(value, codeConstruct);
        }
    }
};
//</editor-fold>

//<editor-fold desc="Event Handling">
fcModel.GlobalObject.prototype._registerResizeHandler = function(value, codeConstruct)
{
    this.browser.executionInfo.logEventRegistered
    (
        "window",
        "window",
        "onresize",
        codeConstruct,
        value.codeConstruct,
        this.browser.loadingEventsExecuted
    );

    this.resizeHandlers.push
    ({
        handler: value,
        registrationPoint:
        {
            codeConstruct: codeConstruct,
            evaluationPositionId: this.getPreciseEvaluationPositionId()
        },
        registrationConstruct: codeConstruct,
        handlerConstruct: value.codeConstruct,
        thisObject: this,
        eventType: "onresize",
        thisObjectDescriptor: "window",
        thisObjectModel: "window"
    });
};

fcModel.GlobalObject.prototype.registerTimeout = function(timeoutId, handler, timePeriod, callArguments, registrationPoint)
{
    this.timeoutHandlers.push
    ({
        timeoutId: timeoutId,
        handler: handler,
        timePeriod: timePeriod,
        callArguments: callArguments,
        registrationPoint: registrationPoint,
        registrationConstruct: registrationPoint.codeConstruct,
        handlerConstruct: handler.codeConstruct,
        thisObject: this.globalObject,
        eventType: "timeout",
        thisObjectDescriptor: "window",
        thisObjectModel: "window"
    });

    this.browser.executionInfo.logEventRegistered
    (
        "window",
        "window",
        "timeout",
        registrationPoint.codeConstruct,
        handler.codeConstruct,
        this.browser.loadingEventsExecuted,
        timeoutId,
        timePeriod
    );
};

fcModel.GlobalObject.prototype.unregisterTimeout = function(timeoutId, codeConstruct)
{
    if(timeoutId == null) { return; }

    for(var i = 0; i < this.timeoutHandlers.length; i++)
    {
        if(this.timeoutHandlers[i].timeoutId == timeoutId)
        {
            this.dependencyCreator.createDataDependency
            (
                this.timeoutHandlers[i].registrationPoint.codeConstruct,
                codeConstruct,
                this.timeoutHandlers[i].registrationPoint.evaluationPositionId,
                this.getPreciseEvaluationPositionId()
            );

            ValueTypeHelper.removeFromArrayByIndex(this.timeoutHandlers, i);
            return;
        }
    }
};

fcModel.GlobalObject.prototype.preRegisterAjaxEvent = function(baseObject, registrationPoint)
{
    this.ajaxPreregistrations.push({
        baseObject: baseObject,
        registrationPoint: registrationPoint
    });
};

fcModel.GlobalObject.prototype.registerPreRegisteredAjaxEvents = function()
{
    for(var i = 0; i < this.ajaxPreregistrations.length; i++)
    {
        var ajaxPreregistration = this.ajaxPreregistrations[i];

        this.registerAjaxEvent
        (
            ajaxPreregistration.baseObject,
            ajaxPreregistration.baseObject.getPropertyValue("onreadystatechange"),
            ajaxPreregistration.registrationPoint
        );
    }

    this.ajaxPreregistrations = [];
};

fcModel.GlobalObject.prototype.registerAjaxEvent = function(baseObject, handler, registrationPoint)
{
    //the onreadystatechange property does not have to be set before the
    this.ajaxHandlers.push
    ({
        thisObject: baseObject,
        ajaxObject: baseObject,
        handler: handler,
        registrationPoint: registrationPoint,
        registrationConstruct: registrationPoint.codeConstruct,
        handlerConstruct: handler.codeConstruct,
        eventType: "onreadystatechange",
        thisObjectDescriptor: "ajax",
        thisObjectModel: "ajax"
    });

    this.browser.executionInfo.logEventRegistered
    (
        "ajax",
        "ajax",
        "onreadystatechange",
        registrationPoint.codeConstruct,
        handler.codeConstruct,
        this.browser.loadingEventsExecuted
    );
};

fcModel.GlobalObject.prototype.registerInterval = function(intervalId, handler, timePeriod, callArguments, registrationPoint)
{
    this.intervalHandlers.push
    ({
        intervalId: intervalId,
        handler: handler,
        timePeriod: timePeriod,
        callArguments: callArguments,
        registrationPoint: registrationPoint,
        registrationConstruct: registrationPoint.codeConstruct,
        handlerConstruct: handler.codeConstruct,
        thisObject: this.globalObject,
        eventType: "interval",
        thisObjectDescriptor: "window",
        thisObjectModel: "window"
    });

    this.browser.executionInfo.logEventRegistered
    (
        "window",
        "window",
        "interval",
        registrationPoint.codeConstruct,
        handler.codeConstruct,
        this.browser.loadingEventsExecuted,
        intervalId,
        timePeriod
    );
};

fcModel.GlobalObject.prototype.unregisterInterval = function(intervalId, codeConstruct)
{
    if(intervalId == null) { return; }

    for(var i = 0; i < this.intervalHandlers.length; i++)
    {
        if(this.intervalHandlers[i].intervalId == intervalId)
        {
            var dependencyCreationInfo = this.getPreciseEvaluationPositionId();
            dependencyCreationInfo.shouldAlwaysBeFollowed = true;

            this.dependencyCreator.createDataDependency
            (
                this.intervalHandlers[i].registrationPoint.codeConstruct,
                codeConstruct,
                dependencyCreationInfo,
                this.getPreciseEvaluationPositionId()
            );

            ValueTypeHelper.removeFromArrayByIndex(this.intervalHandlers, i);

            return;
        }
    }

    this.browser.executionInfo.logEventDeRegistered(null, "interval", codeConstruct, intervalId);
};

fcModel.GlobalObject._EVENT_HANDLER_REGISTRATION_POINT_LAST_ID = 0;
fcModel.GlobalObject.prototype.registerHtmlElementEventHandler = function(fcHtmlElement, eventType, handler, evaluationPosition)
{
    var eventDescriptor =
    {
        fcHtmlElement: fcHtmlElement,
        eventType: eventType,
        handler: handler,
        registrationPoint: evaluationPosition,
        registrationConstruct: evaluationPosition.codeConstruct,
        handlerConstruct: handler.codeConstruct,
        thisObject: fcHtmlElement,
        id: fcModel.GlobalObject._EVENT_HANDLER_REGISTRATION_POINT_LAST_ID++,
        thisObjectModel: this._getEventObjectModel(fcHtmlElement),
        thisObjectDescriptor: this._getEventObjectDescriptor(fcHtmlElement),
        thisObjectCssSelector: this._getEventObjectCssSelector(fcHtmlElement)
    };

    this.htmlElementEventHandlingRegistrations.push(eventDescriptor);

    this.browser.executionInfo.logEventRegistered
    (
        eventDescriptor.thisObjectDescriptor,
        eventDescriptor.thisObjectModel,
        eventType,
        evaluationPosition.codeConstruct,
        handler.codeConstruct,
        this.browser.loadingEventsExecuted,
        null,
        null,
        eventDescriptor.thisObjectCssSelector
    );
};


fcModel.GlobalObject.prototype._getEventObjectDescriptor = function(eventObject)
{
    if(eventObject.globalObject.document == eventObject) { return "document"; }
    if(eventObject.htmlElement != null) { return Firecrow.htmlHelper.getElementXPath(eventObject.htmlElement); }
    if(eventObject.globalObject == eventObject) { return "window"; }

    debugger;

    return "unknown base object in event";
};

fcModel.GlobalObject.prototype._getEventObjectCssSelector = function(eventObject)
{
    if(eventObject.globalObject.document == eventObject) { return "document"; }
    if(eventObject.globalObject == eventObject) { return "window"; }
    if(eventObject.htmlElement != null)
    {
        if(eventObject.htmlElement.nodeName == null) { debugger; }
        var type = eventObject.htmlElement.nodeName.toLowerCase();
        var id = eventObject.htmlElement.id;
        var classes = eventObject.htmlElement.className.replace(/(\s)+/g, ".")

        return type + (id != null && id != "" ? ("#" + id) : "")
                    + (classes != null && classes != "" ? ("." + classes) : "");
    }

    debugger;

    return "unknown base object in event";
};

fcModel.GlobalObject.prototype._getEventObjectModel = function(eventObject)
{
    if(eventObject.htmlElement != null) { return eventObject.htmlElement.modelElement; }
    if(eventObject.globalObject.document == eventObject) { return "document"; }
    if(eventObject.globalObject == eventObject) { return "window"; }

    debugger;

    return null;
};
//</editor-fold>

//<editor-fold desc="'Public' methods">
fcModel.GlobalObject.prototype.isPrimitive = function() { return false; }

fcModel.GlobalObject.prototype.getSimplifiedUserSetGlobalProperties = function()
{
    return this.convertToSimplifiedUserSetProperties(this.getUserSetGlobalProperties());

};

fcModel.GlobalObject.prototype.convertToSimplifiedUserSetProperties = function(properties)
{
    var simplifiedProperties = [];

    for(var i = 0; i < properties.length; i++)
    {
        var property = properties[i];
        simplifiedProperties.push
        ({
            name: property.name,
            declarationConstructId: property.declarationPosition.codeConstruct != null
                                  ? property.declarationPosition.codeConstruct.nodeId
                                  : -1,
            isEventProperty: fcModel.GlobalObject.CONST.isEventProperty(property.name)
        });
    }

    return simplifiedProperties;
};

fcModel.GlobalObject.prototype.getUserSetGlobalProperties = function()
{
    var userSetGlobalProperties = [];

    for(var i = 0; i < this.properties.length; i++)
    {
        var property = this.properties[i];

        if(property.declarationPosition == null) { continue; }

        userSetGlobalProperties.push(property);
    }

    return userSetGlobalProperties;
};

fcModel.GlobalObject.prototype.getSimplifiedEventHandlerPropertiesMap = function()
{
    var simplifiedEventHandlerPropertiesMap = {};

    for(var handlerName in this.eventHandlerPropertiesMap)
    {
        simplifiedEventHandlerPropertiesMap[handlerName] = this.eventHandlerPropertiesMap[handlerName].nodeId;
    }

    return simplifiedEventHandlerPropertiesMap;
}

fcModel.GlobalObject.prototype.getSimplifiedUserSetDocumentProperties = function()
{
    return this.convertToSimplifiedUserSetProperties(this.document.getUserDefinedProperties());
};

fcModel.GlobalObject.prototype.getUserSetDocumentProperties = function()
{
    return this.document.getUserDefinedProperties();
};

fcModel.GlobalObject.prototype.logCallbackExecution = function(callbackConstruct, callCallbackConstruct)
{
    if(callbackConstruct == null) { return; }

    this.browser.callCallbackCalledCallbacks(callbackConstruct, callCallbackConstruct, this.getPreciseEvaluationPositionId());
};

fcModel.GlobalObject.prototype.logResourceSetting = function(codeConstruct, resourcePath)
{
    this.browser.logResourceSetting(codeConstruct, resourcePath);
};

fcModel.GlobalObject.prototype.logForInIteration = function(codeConstruct, objectPrototype)
{
    this.browser.logForInIteration(codeConstruct, objectPrototype);
};

fcModel.GlobalObject.prototype.getLoadedHandlers = function()
{
    return this.getDOMContentLoadedHandlers().concat(this.getOnLoadFunctions());
};

fcModel.GlobalObject.prototype.simpleDependencyEstablished = function(fromConstruct, toConstruct)
{
    this.browser.simpleDependencyEstablished(fromConstruct, toConstruct);
};

fcModel.GlobalObject.prototype.getDOMContentLoadedHandlers = function()
{
    if(this.document == null || this.document.getEventListeners == null) { return this.getEventListeners("DOMContentLoaded"); }

    return this.document.getEventListeners("DOMContentLoaded").concat(this.getEventListeners("DOMContentLoaded"));
};

fcModel.GlobalObject.prototype.getOnLoadFunctions = function()
{
    var onLoadFunctions =  this.getEventListeners("load");
    var onLoadFunction = this.getPropertyValue("onload");

    if(onLoadFunction != null && onLoadFunction.jsValue != null)
    {
        var registrationPoint = this.getProperty("onload").lastModificationPosition;
        onLoadFunctions.push
        ({
            handler: onLoadFunction,
            registrationPoint: registrationPoint,
            eventType: "onload",
            thisObject: this,
            registrationConstruct: registrationPoint.codeConstruct,
            handlerConstruct: onLoadFunction.codeConstruct,
            thisObjectDescriptor: "window",
            thisObjectModel: "window"
        });
    }
    else //if window.onload is not set check the body element onload attribute
    {

    }

    return onLoadFunctions;
};

fcModel.GlobalObject.prototype.destruct = function()
{
    this._retractFromFcValue();
    this._removeExecutionEnvironment();

    this._deleteInternalPrototypes();
    this._deleteInternalFunctions();
    this._deleteHandlerMaps();
    this._deleteInternalObjects();
    this._deleteInternalPrototypes();

    this.deconstructObject();
};

fcModel.GlobalObject.prototype.getJsValues = function(internalValues)
{
    var jsValues = [];

    for(var i = 0; i < internalValues.length; i++)
    {
        jsValues.push(internalValues[i].jsValue);
    }

    return jsValues;
},
//</editor-fold>

//<editor-fold desc="Evaluation Position">
fcModel.GlobalObject.prototype.getPreciseEvaluationPositionId = function()
{
    return {
        groupId : this.evaluationPositionId,
        currentCommandId : (this.currentCommand != null ? this.currentCommand.executionId : "0")
    };
};

fcModel.GlobalObject.prototype.getPrecisePreviousEvaluationPositionId = function()
{
    return {
        groupId : this.evaluationPositionId,
        currentCommandId : (this.currentCommand != null ? this.currentCommand.executionId-1 : "0")
    };
};

fcModel.GlobalObject.prototype.getReturnExpressionPreciseEvaluationPositionId = function()
{
    var evaluationPositionId = this.getPreciseEvaluationPositionId();
    evaluationPositionId.isReturnDependency = true;

    var offset = null;
    evaluationPositionId.groupId.replace(/-[0-9]+f/g, function(match)
    {
        offset = arguments[arguments.length - 2];
    });

    if(offset)
    {
        evaluationPositionId.groupId = evaluationPositionId.groupId.substring(0, offset);
    }

    return evaluationPositionId;
};

fcModel.GlobalObject.prototype.setCurrentCommand = function(command)
{
    if(command == null) { fcModel.GlobalObject.notifyError("Command can not be null!");}

    this.currentCommand = command;
    this.currentCommand.executionId = this._EXECUTION_COMMAND_COUNTER++;
};

fcModel.GlobalObject.prototype._createEvaluationPositionProperties = function()
{
    this.evaluationPositionId = "root";
    this.currentCommand = null;
};
//</editor-fold>

//<editor-fold desc="Slicing Criteria">
fcModel.GlobalObject.prototype.registerSlicingCriteria = function(slicingCriteria)
{
    if(slicingCriteria == null) { return; }

    this.identifierSlicingCriteria = [];
    this.domModificationSlicingCriteria = [];

    for(var i = 0; i < slicingCriteria.length; i++)
    {
        var criterion = slicingCriteria[i];

        if(criterion.type == "READ_IDENTIFIER") { this.identifierSlicingCriteria.push(criterion); }
        else if (criterion.type == "DOM_MODIFICATION")
        {
            if(criterion.cssSelector === "all") { this.includeAllDomModifications = true; }
            this.domModificationSlicingCriteria.push(criterion);
        }
    }
};

fcModel.GlobalObject.prototype.satisfiesDomSlicingCriteria = function(htmlElement)
{
    try
    {
        if(htmlElement == null || htmlElement instanceof Text) { return false; }
        if(this.domModificationSlicingCriteria.length == 0) { return false; }

        if(this.includeAllDomModifications) { return true; }

        for(var i = 0; i < this.domModificationSlicingCriteria.length; i++)
        {
            var element = htmlElement;

            while(element != null)
            {
                if(this.browser.matchesSelector(element, this.domModificationSlicingCriteria[i].cssSelector))
                {
                    return true;
                }

                element = element.parentElement;
            }
        }
    }
    catch(e) { fcModel.GlobalObject.notifyError("Global object error when checking if satisfies dom slicing: " + e);}

    return false;
};

fcModel.GlobalObject.prototype.satisfiesIdentifierSlicingCriteria = function(codeConstruct)
{
    if(codeConstruct == null || this.identifierSlicingCriteria.length == 0) { return false; }

    for(var i = 0; i < this.identifierSlicingCriteria.length; i++)
    {
        var slicingCriterion = this.identifierSlicingCriteria[i];

        //if(slicingCriterion.fileName != codeConstruct.loc.source) { continue; }
        //TODO - uncomment this!
        //if(slicingCriterion.lineNumber != codeConstruct.loc.start.line) { continue; }
        if(slicingCriterion.identifierName != codeConstruct.name) { continue; }

        return true;
    }

    return false;
};

fcModel.GlobalObject.prototype._createSlicingVariables = function()
{
    this.identifierSlicingCriteria = [];
    this.domModificationSlicingCriteria = [];
    this.includeAllDomModifications = false;
};
//</editor-fold>

//<editor-fold desc="'Private methods'">
fcModel.GlobalObject.prototype._expandToFcValue = function()
{
    this.iValue = this;
    this.jsValue = this;
    this.codeConstruct = null;

    this.isFunction = function() { return false; };
    this.isPrimitive = function() { return false; };
    this.isSymbolic = function() { return false; }
    this.isNotSymbolic = function() { return true; }
};

fcModel.GlobalObject.prototype._retractFromFcValue = function()
{
    delete this.iValue;
    delete this.jsValue;
    delete this.codeConstruct;

    delete this.isFunction;
    delete this.isPrimitive;
    delete this.isSymbolic;
    delete this.isNotSymbolic;
};

fcModel.GlobalObject.prototype._setExecutionEnvironment = function(browser)
{
    this.browser = browser;

    this.origWindow = Firecrow.getWindow();
    this.origDocument = Firecrow.getDocument();

    this.origWindow.assert = function assert(){};
    this.origWindow.assertEquals = function assertEquals(){};
    this.origWindow.assertEqual = function assertEqual(){};
    this.origWindow.assertMatch = function assertMatch(){};
    this.origWindow.assertNull = function assertNull(){};
    this.origWindow.assertNotNull = function assertNotNull(){};
    this.origWindow.assertNotEquals = function assertNotEquals(){};
};

fcModel.GlobalObject.prototype._detectExecutionEnvironmentProperties = function()
{
    this.throwsExceptionOnPushWithNodeList = (function()
    {
        try
        {
            Array.prototype.push.apply([], this.origDocument.childNodes);
            return false;
        }
        catch(e)
        {
            return true;
        }
    }).call(this);
};

fcModel.GlobalObject.prototype._removeExecutionEnvironment = function()
{
    delete this.browser;

    delete this.origWindow;
    delete this.origDocument;
};

fcModel.GlobalObject.prototype._createInternalPrototypes = function ()
{
    this.objectPrototype = new fcModel.ObjectPrototype(this);
    this.fcObjectPrototype = new fcModel.fcValue(Object.prototype, this.objectPrototype, null);

    this.functionPrototype = new fcModel.FunctionPrototype(this);
    this.fcFunctionPrototype = new fcModel.fcValue(Function.prototype, this.functionPrototype, null);
    this.functionPrototype.initFunctionPrototype();

    this.objectPrototype.initMethods();

    this.booleanPrototype = new fcModel.BooleanPrototype(this);
    this.fcBooleanPrototype = new fcModel.fcValue(Boolean.prototype, this.booleanPrototype, null);

    this.arrayPrototype = new fcModel.ArrayPrototype(this);
    this.fcArrayPrototype = new fcModel.fcValue(Array.prototype, this.arrayPrototype, null);

    this.regExPrototype = new fcModel.RegExPrototype(this);
    this.fcRegExPrototype = new fcModel.fcValue(RegExp.prototype, this.regExPrototype, null);

    this.xmlHttpRequestPrototype = new fcModel.XMLHttpRequestPrototype(this);
    this.fcXMLHttpRequestPrototype = new fcModel.fcValue(XMLHttpRequest.prototype, this.xmlHttpRequestPrototype, null);

    this.stringPrototype = new fcModel.StringPrototype(this);
    this.fcStringPrototype = new fcModel.fcValue(String.prototype, this.stringPrototype, null);

    this.numberPrototype = new fcModel.NumberPrototype(this);
    this.fcNumberPrototype = new fcModel.fcValue(Number.prototype, this.numberPrototype, null);

    this.datePrototype = new fcModel.DatePrototype(this);
    this.fcDatePrototype = new fcModel.fcValue(Date.prototype, this.datePrototype, null);

    this.errorPrototype = new fcModel.ErrorPrototype(this);
    this.fcErrorPrototype = new fcModel.fcValue(Error.prototype, this.errorPrototype, null);

    this.eventPrototype = new fcModel.EventPrototype(this);
    this.fcEventPrototype = new fcModel.fcValue(Event.prototype, this.eventPrototype, null);

    this.htmlImageElementPrototype = new fcModel.HTMLImageElementPrototype(this);
    this.fcHtmlImagePrototype = new fcModel.fcValue(HTMLImageElement.prototype, this.htmlImageElementPrototype, null);

    this.canvasPrototype = new fcModel.CanvasPrototype(this);
    this.fcCanvasPrototype = new fcModel.fcValue(HTMLCanvasElement.prototype, this.canvasPrototype, null);

    this.canvasContextPrototype = new fcModel.CanvasContextPrototype(this);
    this.fcCanvasContextPrototype = new fcModel.fcValue(CanvasRenderingContext2D.prototype, this.canvasContextPrototype, null);

    this.elementPrototype = new fcModel.ElementPrototype(this);
    this.fcElementPrototype = new fcModel.fcValue(Element.prototype, this.elementPrototype, null);

    this.htmlElementPrototype = new fcModel.HTMLElementPrototype(this);
    this.fcHtmlElementPrototype = new fcModel.fcValue(HTMLElement.prototype, this.htmlElementPrototype, null);

    if(typeof Window !== "undefined")
    {
        this.windowPrototype = new fcModel.WindowPrototype(this);
        this.fcWindowPrototype = new fcModel.fcValue(Window.prototype, this.windowPrototype, null);
    }

    this.documentPrototype = new fcModel.DocumentPrototype(this);
    this.fcDocumentPrototype = new fcModel.fcValue(Document.prototype, this.documentPrototype, null);

    this.internalPrototypes =
    [
        this.objectPrototype, this.functionPrototype, this.booleanPrototype,
        this.arrayPrototype, this.regExPrototype, this.stringPrototype,
        this.numberPrototype, this.datePrototype, this.htmlImageElementPrototype,
        this.canvasPrototype, this.xmlHttpRequestPrototype,
        this.eventPrototype, this.errorPrototype, this.elementPrototype
    ];
};

fcModel.GlobalObject.prototype._deleteInternalPrototypes = function ()
{
    delete this.objectPrototype;
    delete this.fcObjectPrototype;

    delete this.functionPrototype;
    delete this.fcFunctionPrototype;

    delete this.objectPrototype;

    delete this.booleanPrototype;
    delete this.fcBooleanPrototype;

    delete this.arrayPrototype;
    delete this.fcArrayPrototype;

    delete this.regExPrototype;
    delete this.fcRegExPrototype;

    delete this.xmlHttpRequestPrototype;
    delete this.fcXMLHttpRequestPrototype;

    delete this.stringPrototype;
    delete this.fcStringPrototype;

    delete this.numberPrototype;
    delete this.fcNumberPrototype;

    delete this.datePrototype;
    delete this.fcDatePrototype;

    delete this.errorPrototype;
    delete this.fcErrorPrototype;

    delete this.eventPrototype;
    delete this.fcEventPrototype;

    delete this.htmlImageElementPrototype;
    delete this.fcHtmlImagePrototype;

    delete this.canvasPrototype;
    delete this.fcCanvasPrototype;

    delete this.canvasContextPrototype;
    delete this.fcCanvasContextPrototype;

    delete this.elementPrototype;
    delete this.fcElementPrototype;

    delete this.windowPrototype;
    delete this.fcWindowPrototype;

    delete this.documentPrototype;
    delete this.fcDocumentPrototype;

    delete this.internalPrototypes;
};

fcModel.GlobalObject.prototype._createInternalFunctions = function()
{
    this.objectFunction = new fcModel.ObjectFunction(this);
    this.fcObjectFunction = new fcModel.fcValue(Object, this.objectFunction);
    this.addProperty("Object", this.fcObjectFunction, null);
    this.objectPrototype.addProperty("constructor", this.fcObjectFunction, null, false);

    this.arrayFunction = new fcModel.ArrayFunction(this);
    this.fcArrayFunction = new fcModel.fcValue(Array, this.arrayFunction, null);
    this.addProperty("Array", this.fcArrayFunction, null);

    this.booleanFunction = new fcModel.BooleanFunction(this);
    this.addProperty("Boolean", new fcModel.fcValue(Boolean, this.booleanFunction, null), null);

    this.stringFunction = new fcModel.StringFunction(this);
    this.fcStringFunction = new fcModel.fcValue(String, this.stringFunction, null);
    this.addProperty("String", this.fcStringFunction, null);

    this.imageFunction = new fcModel.ImageFunction(this);
    this.addProperty("Image", new fcModel.fcValue(Image, this.imageFunction, null), null);

    this.regExFunction = new fcModel.RegExFunction(this);
    this.addProperty("RegExp", new fcModel.fcValue(RegExp, this.regExFunction, null), null);

    this.numberFunction = new fcModel.NumberFunction(this);
    this.addProperty("Number", new fcModel.fcValue(Number, this.numberFunction, null), null);

    this.dateFunction = new fcModel.DateFunction(this);
    this.addProperty("Date", new fcModel.fcValue(Date, this.dateFunction, null), null);

    this.errorFunction = new fcModel.ErrorFunction(this);
    this.addProperty("Error", new fcModel.fcValue(Error, this.errorFunction, null), null);

    this.eventFunction = new fcModel.EventFunction(this);
    this.addProperty("Event", new fcModel.fcValue(Event, this.eventFunction, null), null),

    this.functionFunction = new fcModel.FunctionFunction(this);
    this.addProperty("Function", new fcModel.fcValue(Function, this.functionFunction), null);

    this.xmlHttpRequestFunction = new fcModel.XMLHttpRequestFunction(this);
    this.addProperty("XMLHttpRequest", new fcModel.fcValue(XMLHttpRequest, this.xmlHttpRequestFunction, null), null);

    this.windowFunction = new fcModel.WindowFunction(this);

    if(typeof Window !== "undefined")
    {
        this.addProperty("Window", new fcModel.fcValue(Window, this.windowFunction, null), null);
    }

    this.documentFunction = new fcModel.DocumentFunction(this);
    this.addProperty("Document", new fcModel.fcValue(Document, this.documentFunction, null), null);

    fcModel.GlobalObject.CONST.INTERNAL_PROPERTIES.METHODS.forEach(function(methodName)
    {
        this.addProperty
        (
            methodName,
            new fcModel.fcValue
            (
                this.origWindow[methodName] || eval(methodName),
                fcModel.Function.createInternalNamedFunction(this, methodName, this),
                null
            ),
            null,
            false
        );
    }, this);

    this.internalFunctions =
    [
        this.objectFunction, this.arrayFunction, this.booleanFunction,
        this.stringFunction, this.imageFunction, this.regExFunction,
        this.numberFunction, this.dateFunction, this.functionFunction,
        this.xmlHttpRequestFunction, this.eventFunction, this.errorFunction
    ];
};

fcModel.GlobalObject.prototype._deleteInternalFunctions = function()
{
    delete this.objectFunction;
    delete this.fcObjectFunction;

    delete this.arrayFunction;
    delete this.fcArrayFunction;

    delete this.booleanFunction;

    delete this.stringFunction;
    delete this.fcStringFunction;

    delete this.imageFunction;
    delete this.regExFunction;

    delete this.numberFunction;

    delete this.dateFunction;

    delete this.errorFunction;

    delete this.eventFunction;

    delete this.functionFunction;

    delete this.xmlHttpRequestFunction;

    delete this.windowFunction;

    delete this.documentFunction;

    delete this.internalFunctions;
};

fcModel.GlobalObject.prototype._createInternalObjects = function()
{
    this.document = new fcModel.Document(this.origDocument, this);
    this.jsFcDocument = new fcModel.fcValue(this.origDocument, this.document, null);
    this.addProperty("document", this.jsFcDocument, null);

    this.math = new fcModel.Math(this);
    this.fcMath = new fcModel.fcValue(Math, this.math, null);
    this.addProperty("Math", this.fcMath, null);

    this.addProperty("window", this, null);

    this.addProperty("location", this.internalExecutor.createLocationObject());
    this.addProperty("navigator", this.internalExecutor.createNavigatorObject());
    this.addProperty("screen", this.internalExecutor.createScreenObject());

    this.fcHTMLImageElement = new fcModel.HTMLImageElement(this);
    this.htmlImageElement = new fcModel.fcValue(HTMLImageElement, this.fcHTMLImageElement, null);
    this.addProperty("HTMLImageElement", this.htmlImageElement, null);

    this.fcElement = new fcModel.Element(this);
    this.element = new fcModel.fcValue(Element, this.fcElement, null);
    this.addProperty("Element", this.element, null);

    this.fcHtmlElement = new fcModel.HTMLElement(this);
    this.htmlElement = new fcModel.fcValue(HTMLElement, this.fcHtmlElement, null);
    this.addProperty("HTMLElement", this.htmlElement, null);

    //this.fcEvent = new fcModel.Event(this);
    //this.event = new fcModel.fcValue(Event, this.fcEvent, null);
    //this.addProperty("Event", this.event, null);
};

fcModel.GlobalObject.prototype._deleteInternalObjects = function()
{
    delete this.document;
    delete this.jsFcDocument;

    delete this.math;
    delete this.fcMath;

    delete this.fcHTMLImageElement;
    delete this.htmlImageElement;

    delete this.fcElement;
    delete this.element;

    delete this.fcEvent;
    delete this.event;
};

fcModel.GlobalObject.prototype.isInternalPrototype = function(object)
{
    for(var i = 0; i < this.internalPrototypes.length; i++)
    {
        if(this.internalPrototypes[i] == object) { return true;}
    }

    return false;
};

fcModel.GlobalObject.prototype._createInternalVariables = function()
{
    this.addProperty("undefined", this.internalExecutor.createInternalPrimitiveObject(null, undefined));
    this.addProperty("Infinity", this.internalExecutor.createInternalPrimitiveObject(null, Infinity));
    this.addProperty("NaN", this.internalExecutor.createInternalPrimitiveObject(null, NaN));
    this.addProperty("mozInnerScreenX", this.internalExecutor.createInternalPrimitiveObject(null, window.mozInnerScreenX));
    this.addProperty("mozInnerScreenY", this.internalExecutor.createInternalPrimitiveObject(null, window.mozInnerScreenY));
    this.addProperty("screenX", this.internalExecutor.createInternalPrimitiveObject(null, window.screenX));
    this.addProperty("screenY", this.internalExecutor.createInternalPrimitiveObject(null, window.screenY));
    this.addProperty("innerWidth", this.internalExecutor.createInternalPrimitiveObject(null, window.innerWidth));
    this.addProperty("innerHeight", this.internalExecutor.createInternalPrimitiveObject(null, window.innerHeight));

    var eventHandlerNames = ("onafterprint, onbeforeprint, onbeforeunload, onhashchange, onmessage, onoffline, ononline, onpopstate"
    +"onpagehide, onpageshow, onresize, onunload, ondevicemotion, ondeviceorientation, ondeviceproximity"
    +"onuserproximity, ondevicelight, onabort, onblur, oncanplay, oncanplaythrough, onchange, onclick"
    +"oncontextmenu, ondblclick, ondrag, ondragend, ondragenter, ondragleave, ondragover, ondragstart"
    + "ondrop, ondurationchange, onemptied, onended, onerror, onfocus, oninput, oninvalid, onkeydown, onkeypress"
    + "onkeyup, onload, onloadeddata, onloadedmetadata, onloadstart, onmousedown, onmousemove, onmouseout, onmouseover"
    + "onmouseup, onmozfullscreenchange, onmozfullscreenerror, onmozpointerlockchange, onmozpointerlockerror, onpause"
    + "onplay, onplaying, onprogress, onratechange, onreset, onscroll, onseeked, onseeking, onselect, onshow, onstalled"
    + "onsubmit, onsuspend, ontimeupdate, onvolumechange, onwaiting, oncopy, oncut, onpaste, onbeforescriptexecute, onafterscriptexecute").split(",");

    for(var i = 0 ; i < eventHandlerNames.length; i++)
    {
        var eventHandlerName = eventHandlerNames[i].trim();

        this.addProperty(eventHandlerName, this.internalExecutor.createInternalPrimitiveObject(null, null));
    }
};

fcModel.GlobalObject.prototype._createHandlerMaps = function()
{
    this.eventHandlerPropertiesMap = {};
    this.htmlElementEventHandlingRegistrations = [];
    this.ajaxPreregistrations = [];
    this.ajaxHandlers = [];

    this.timeoutHandlers = [];
    this.intervalHandlers = [];
    this.resizeHandlers = [];
};
fcModel.GlobalObject.prototype._deleteHandlerMaps = function()
{
    delete this.eventHandlerPropertiesMap;
    delete this.htmlElementEventHandlingRegistrations;
    delete this.ajaxHandlers;
    delete this.ajaxPreregistrations;

    delete this.timeoutHandlers;
    delete this.intervalHandlers;
    delete this.resizeHandlers;
};

fcModel.GlobalObject.prototype.setBrowserVersion = function(browserVersion)
{
    if(browserVersion == null || browserVersion == "") { return; }

    if(browserVersion.indexOf("IE") == 0)
    {
        this.addProperty("ActiveXObject", new fcModel.fcValue(XMLHttpRequest, this.xmlHttpRequestFunction, null), null);
    }
};
//</editor-fold>

fcModel.WindowFunction = function(globalObject)
{
    try
    {
        this.initObject(globalObject);

        this.name = "Window";

        this.addProperty("prototype", globalObject.fcWindowPrototype);
        this.proto = globalObject.fcFunctionPrototype;
    }
    catch(e){ fcModel.GlobalObject.notifyError("Error when creating Window Function:" + e); }
};

fcModel.WindowFunction.prototype = new fcModel.Object();

fcModel.WindowPrototype = function(globalObject)
{
    this.initObject(globalObject);
    this.constructor = fcModel.WindowPrototype;
};

fcModel.WindowPrototype.prototype = new fcModel.Object();
/*************************************************************************************/
}});FBL.ns(function() { with (FBL) {
/*************************************************************************************/
var fcModel = Firecrow.Interpreter.Model;
var ValueTypeHelper = Firecrow.ValueTypeHelper;

fcModel.GlobalObjectExecutor =
{
    executeInternalFunction: function(fcFunction, args, callExpression, globalObject)
    {
        try
        {
                 if (fcFunction.jsValue.name == "eval") { return _handleEval(fcFunction, args, callExpression, globalObject); }
            else if (fcFunction.jsValue.name == "addEventListener") { return globalObject.addEventListener(args, callExpression, globalObject); }
            else if (fcFunction.jsValue.name == "removeEventListener") { return globalObject.removeEventListener(args, callExpression, globalObject); }
            else if (fcFunction.jsValue.name == "setTimeout" || fcFunction.jsValue.name == "setInterval") { return this._setTimingEvents(fcFunction.jsValue.name, args[0], args[1] != null ? args[1].jsValue : 0, args.slice(2), globalObject, callExpression); }
            else if (fcFunction.jsValue.name == "clearTimeout" || fcFunction.jsValue.name == "clearInterval") { return this._clearTimingEvents(fcFunction.jsValue.name, args[0] != null ? args[0].jsValue : 0, globalObject, callExpression); }
            else if (fcFunction.jsValue.name == "getComputedStyle") { return this._getComputedStyle(args[0], globalObject.getJsValues(args), globalObject, callExpression) }
            else if (fcFunction.jsValue.name == "alert") { return null; }
            else if (fcFunction.jsValue.name.indexOf("assert") != -1)
            {
                globalObject.browser.callImportantConstructReachedCallbacks(callExpression);
            }
            else if (fcModel.GlobalObject.CONST.INTERNAL_PROPERTIES.METHODS.indexOf(fcFunction.jsValue.name) != -1)
            {
                return globalObject.internalExecutor.createInternalPrimitiveObject
                (
                    callExpression,
                    (globalObject.origWindow[fcFunction.jsValue.name] || eval(fcFunction.jsValue.name)).apply(globalObject.origWindow, globalObject.getJsValues(args))
                );
            }
            else if (globalObject.internalExecutor.isInternalConstructor(fcFunction))
            {
                return globalObject.internalExecutor.executeInternalConstructor(callExpression, fcFunction, args);
            }
            else
            {
                fcModel.GlobalObject.notifyError("Unhandled internal function: " + e);
            }
        }
        catch(e)
        {
            fcModel.GlobalObject.notifyError("Error when executing global object function internal function: " + e);
        }
    },

    _getComputedStyle: function(jsHtmlElement, args, globalObject, callExpression)
    {
        if(!ValueTypeHelper.isHtmlElement(jsHtmlElement.jsValue)) { this.notifyError("Wrong argument when getting computed style"); return; }

        var htmlElement = jsHtmlElement.jsValue;
        var computedStyle = globalObject.origWindow.getComputedStyle.apply(globalObject.origWindow, args);

        return fcModel.CSSStyleDeclaration.createStyleDeclaration(htmlElement, computedStyle, globalObject, callExpression);
    },

    _setTimingEvents: function(functionName, handler, timePeriod, sentArguments, globalObject, callExpression)
    {
        var timeoutId = globalObject.TIMEOUT_ID_COUNTER++;

        var timingEventArguments = [timeoutId, handler, timePeriod, sentArguments, { codeConstruct:callExpression, evaluationPositionId: globalObject.getPreciseEvaluationPositionId()}];

        if(functionName == "setTimeout") { globalObject.registerTimeout.apply(globalObject, timingEventArguments); }
        else if(functionName == "setInterval") { globalObject.registerInterval.apply(globalObject, timingEventArguments); }

        return globalObject.internalExecutor.createInternalPrimitiveObject(callExpression, timeoutId);
    },

    _clearTimingEvents: function(functionName, timerId, globalObject, callExpression)
    {
        if(functionName == "clearTimeout") { globalObject.unregisterTimeout(arguments[0] != null ? timerId : null, callExpression); }
        else { globalObject.unregisterInterval(arguments[0] != null ? timerId : null, callExpression); }

        return globalObject.internalExecutor.createInternalPrimitiveObject(callExpression, undefined);
    },

    _handleEval: function(fcFunction, arguments, callExpression, globalObject)
    {
        fcModel.GlobalObject.notifyError("Not handling eval function!");

        return globalObject.internalExecutor.createInternalPrimitiveObject(callExpression, null);
    },

    executesFunction: function(globalObject, functionName)
    {
        return (globalObject.origWindow[functionName] != null || eval(functionName))
             && ValueTypeHelper.isFunction(globalObject.origWindow[functionName] || eval(functionName));
    }
};
/*************************************************************************************/
}});FBL.ns(function() { with (FBL) {
/*************************************************************************************/
var fcModel = Firecrow.Interpreter.Model;
var fcSimulator = Firecrow.Interpreter.Simulator;
var ValueTypeHelper = Firecrow.ValueTypeHelper;
var ASTHelper = Firecrow.ASTHelper;

fcModel.Array = function fcModelArray(jsArray, globalObject, codeConstruct)
{
    try
    {
        this.initObject(globalObject, codeConstruct, (this.jsArray = jsArray || []));

        this.constructor = fcModel.Array;
        this.items = [];

        this._addDefaultProperties();
        this._addPreexistingObjects();

        this._registerCallbacks();
    }
    catch(e) { fcModel.Array.notifyError("Error when creating array object: " + e); }
};

//<editor-fold desc="'Static' Methods">
fcModel.Array.notifyError = function(message) { debugger; alert("Array - " + message);}
//</editor-fold>

//<editor-fold desc="Prototype Definition">
fcModel.Array.prototype = new fcModel.Object();

fcModel.Array.prototype.removePrototypeMethods = function()
{
    fcModel.ArrayPrototype.CONST.INTERNAL_PROPERTIES.METHODS.forEach(function(propertyName)
    {
        this.addProperty(propertyName, this.globalObject.internalExecutor.createInternalPrimitiveObject(null, undefined));
    }, this);
};

fcModel.Array.prototype.markAsNodeList = function()
{
    this.isNodeList = true;
    try
    {
        Object.defineProperty(this.jsArray, "isNodeList", {
            enumerable: false,
            configurable: false,
            writable: false,
            value: true
        });
    }
    catch(e) { fcModel.Array.notifyError("Failed in defining non-enumerable property for isNodeList"); }
    this.removePrototypeMethods();
};

//<editor-fold desc="Internal array methods">
fcModel.Array.prototype.push = function(jsArray, args, codeConstruct, fcValue, dontFillJsArray)
{
    try
    {
        this.addDependenciesToAllProperties(codeConstruct);

        var isCalledOnArray = this.constructor === fcModel.Array;

        if(args != null && args.isNodeList && this.globalObject.throwsExceptionOnPushWithNodeList)
        {
            this.globalObject.executionContextStack.callExceptionCallbacks
            ({
                exceptionGeneratingConstruct: codeConstruct,
                isPushExpectedException: true
            });

            return;
        }

        if(!isCalledOnArray) { this.addDependencyToAllModifications(codeConstruct); }

        var lengthProperty = this.getPropertyValue("length");
        var length = lengthProperty != null ? lengthProperty.jsValue : 0;

        args = args.length !== null && args.length !== undefined ? args : [args];

        for(var i = 0, argsLength = args.length; i < argsLength; i++, length++)
        {
            var argument = args[i];

            if(isCalledOnArray)
            {
                this.items.push(argument);
                if(!dontFillJsArray) { jsArray.push(argument); }
            }
            else
            {
                jsArray[length] = argument;
            }

            this.addProperty(length, argument, codeConstruct, true);
        }

        var lengthValue = this.globalObject.internalExecutor.createInternalPrimitiveObject(codeConstruct, length);
        this.addProperty("length", lengthValue, codeConstruct);

        if(!isCalledOnArray) { jsArray.length = lengthValue; }

        return lengthValue;
    }
    catch(e) { fcModel.Array.notifyError("Error when pushing item: " + e + " " + e.fileName + " " + e.lineNumber); }
};

fcModel.Array.prototype.pop = function(jsArray, args, codeConstruct)
{
    try
    {
        this.addDependenciesToAllProperties(codeConstruct);
        var isCalledOnArray = this.constructor === fcModel.Array;

        if(!isCalledOnArray) { this.addDependencyToAllModifications(codeConstruct); }

        var lengthProperty = this.getPropertyValue("length");
        var length = lengthProperty != null ? lengthProperty.jsValue : 0;

        var poppedItem = null;

        if(isCalledOnArray)
        {
            poppedItem = this.items.pop();
            jsArray.pop();
        }
        else
        {
            poppedItem = this.getPropertyValue(length - 1);
        }

        this.deleteProperty(length - 1, codeConstruct);

        this.addProperty("length", this.globalObject.internalExecutor.createInternalPrimitiveObject(codeConstruct, length - 1), codeConstruct, false);

        return poppedItem;
    }
    catch(e) { fcModel.Array.notifyError("Error when popping item: " + e); }
};

fcModel.Array.prototype.reverse = function(jsArray, args, codeConstruct, fcValue)
{
    try
    {
        this.addDependenciesToAllProperties(codeConstruct);

        var isCalledOnArray = this.constructor === fcModel.Array;

        if(!isCalledOnArray) { this.addDependencyToAllModifications(codeConstruct); }

        var lengthProperty = this.getPropertyValue("length");
        var length = lengthProperty != null ? lengthProperty.jsValue : 0;

        if(isCalledOnArray)
        {
            ValueTypeHelper.reverseArray(this.items);
            ValueTypeHelper.reverseArray(jsArray);

            for(var i = 0; i < length; i++)
            {
                this.addProperty(i, this.items[i], codeConstruct, true);
            }
        }
        else { fcModel.Array.notifyError("Not handling reverse on non arrays!"); }

        return fcValue;
    }
    catch(e) { fcModel.Array.notifyError("Error when reversing the array: " + e); }
};

fcModel.Array.prototype.shift = function(jsArray, args, codeConstruct)
{
    try
    {
        this.addDependenciesToAllProperties(codeConstruct);

        var isCalledOnArray = this.constructor === fcModel.Array;

        if(!isCalledOnArray) { this.addDependencyToAllModifications(codeConstruct); }

        var lengthProperty = this.getPropertyValue("length");
        var length = lengthProperty != null ? lengthProperty.jsValue : 0;

        var shiftedItem = null;

        if(isCalledOnArray)
        {
            shiftedItem = this.items.shift();
            jsArray.shift();

            for(var i = 0; i < this.items.length; i++)
            {
                this.addProperty(i, this.items[i], codeConstruct, true);
            }
        }
        else
        {
            shiftedItem = this.getPropertyValue("0");

            for(var i = 1; i < length; i++)
            {
                this.addProperty(i - 1, this.getPropertyValue(i), codeConstruct, true);
            }
        }


        this.deleteProperty(length - 1, codeConstruct);
        this.addProperty("length", this.globalObject.internalExecutor.createInternalPrimitiveObject(codeConstruct, length - 1), codeConstruct, false);

        return shiftedItem;
    }
    catch(e) { fcModel.Array.notifyError("Error when shifting items in array: " + e); }
};

fcModel.Array.prototype.unshift = function(jsArray, callArguments, callExpression)
{
    try
    {
        this.addDependenciesToAllProperties(callExpression);

        var isCalledOnArray = this.constructor === fcModel.Array;

        if(!isCalledOnArray) { alert("Unshift called on non-array!"); return;}

        var lengthProperty = this.getPropertyValue("length");
        var length = lengthProperty != null ? lengthProperty.jsValue : 0;

        for(var i = 0; i < this.items.length; i++) { this.deleteProperty(i, callExpression); }

        for(var i = callArguments.length - 1; i >= 0; i--)
        {
            this.items.unshift(callArguments[i]);
            jsArray.unshift(callArguments[i]);
        }

        for(var i = 0; i < this.items.length; i++)
        {
            this.addProperty(i, this.items[i], callExpression, true);
        }

        var lengthValue = this.globalObject.internalExecutor.createInternalPrimitiveObject(callExpression, this.items.length);

        this.addProperty("length", lengthValue, callExpression, false);

        return lengthValue;
    }
    catch(e) { fcModel.Array.notifyError("Error when unshifting items in array: " + e); }
};

fcModel.Array.prototype.sort = function(jsArray, args, codeConstruct, fcValue)
{
    this.addDependenciesToAllProperties(codeConstruct);

    var isCalledOnArray = this.constructor === fcModel.Array;

    if(!isCalledOnArray) { alert("Sort called on non-array!"); }

    var lengthProperty = this.getPropertyValue("length");
    var length = lengthProperty != null ? lengthProperty.jsValue : 0;

    for(var i = 0; i < this.items.length; i++) { this.deleteProperty(i, codeConstruct); }

    var sortFunction = null;

    if(args.length > 0) { return fcValue; }

    var sortFunction = function(a, b)
    {
        //just sort lexicographically
        if(a.jsValue == b.jsValue) { return 0;}

        return a.jsValue < b.jsValue ? -1 : 1;
    };

    this.items.sort(sortFunction);
    jsArray.sort(sortFunction);

    for(var i = 0; i < this.items.length; i++)
    {
        this.addProperty(i, this.items[i], codeConstruct, true);
    }

    return fcValue;
};

fcModel.Array.prototype.splice = function(jsArray, args, codeConstruct)
{
    try
    {
        this.addDependenciesToAllProperties(codeConstruct);

        var isCalledOnArray = this.constructor === fcModel.Array;

        if(!isCalledOnArray) { return fcModel.Array.prototype._spliceOnNonArray.call(this, jsArray, args, codeConstruct); }

        var lengthProperty = this.getPropertyValue("length");
        var length = lengthProperty != null ? lengthProperty.jsValue : 0;

        for(var i = 0; i < this.items.length; i++) { this.deleteProperty(i, codeConstruct); }

        var argumentValues = [];

        for(i = 0; i < args.length; i++)
        {
            if(i <= 1) { argumentValues.push(args[i].jsValue);}
            else { argumentValues.push(args[i]); }
        }

        var splicedItems = this.items.splice.apply(this.items, argumentValues);
        jsArray.splice.apply(jsArray, argumentValues);

        for(i = 0; i < this.items.length; i++) { this.addProperty(i, this.items[i], codeConstruct, true); }

        this.addProperty("length", this.globalObject.internalExecutor.createInternalPrimitiveObject(codeConstruct, this.items.length),codeConstruct, false);

        return this.globalObject.internalExecutor.createArray(codeConstruct, splicedItems);
    }
    catch(e) { fcModel.Array.notifyError("Error when splicing item: " + e); }
};

fcModel.Array.prototype._spliceOnNonArray = function(jsArray, args, codeConstruct)
{
    this.addDependencyToAllModifications(codeConstruct);
    if(jsArray.length != null)
    {
        this.globalObject.dependencyCreator.createDataDependency(codeConstruct, jsArray.length.codeConstruct)
    }

    var adjustedArguments = [];

    jsArray.length = jsArray.length != null ? jsArray.length.jsValue : null;

    for(var i = 0; i < args.length; i++)
    {
        if(i <= 1) { adjustedArguments.push(args[i].jsValue); }
        else  { adjustedArguments.push(args[i]); }
    }

    var oldLength = jsArray.length;

    var resultArray = Array.prototype.splice.apply(jsArray, adjustedArguments);

    var newLength = jsArray.length;

    for(var i = 0; i < newLength; i++) { this.addProperty(i + "", jsArray[i], codeConstruct, true); }
    for(i = newLength; i < oldLength; i++) { this.deleteProperty(i + "", codeConstruct);}

    jsArray.length = this.globalObject.internalExecutor.createInternalPrimitiveObject(codeConstruct, jsArray.length);
    this.addProperty("length", jsArray.length, codeConstruct, false);

    return this.globalObject.internalExecutor.createArray(codeConstruct, resultArray);
};

fcModel.Array.prototype.concat = function(jsArray, callArguments, callExpression)
{
    try
    {
        this.addDependenciesToAllProperties(callExpression);

        var isCalledOnArray = this.constructor === fcModel.Array || this == this.globalObject.arrayPrototype;

        var lengthProperty = this.getPropertyValue("length");
        var length = lengthProperty != null ? lengthProperty.jsValue : 0;

        var newArray = this.globalObject.internalExecutor.createArray(callExpression);

        for(var i = 0; i < jsArray.length; i++)
        {
            newArray.iValue.push(newArray.jsValue, jsArray[i], callExpression);
        }

        for(var i = 0; i < callArguments.length; i++)
        {
            var argument = callArguments[i];

            if(ValueTypeHelper.isArray(argument.jsValue))
            {
                argument.iValue.addDependenciesToAllProperties(callExpression);
                for(var j = 0; j < argument.jsValue.length; j++)
                {
                    var item = argument.jsValue[j];
                    if(item == null)
                    {
                        item = this.globalObject.internalExecutor.createInternalPrimitiveObject(callExpression, undefined);
                    }

                    newArray.iValue.push(newArray.jsValue, item, callExpression);
                }
            }
            else
            {
                newArray.iValue.push(newArray.jsValue, argument, callExpression);
            }
        }

        return newArray;
    }
    catch(e) { fcModel.Array.notifyError("Error when concat array: " + e);}
};

fcModel.Array.prototype.slice = function(jsArray, callArguments, callExpression)
{
    try
    {
        this.addDependenciesToAllProperties(callExpression);
        var isCalledOnArray = this.constructor === fcModel.Array;

        var lengthProperty = this.getProperty("length");
        var length = lengthProperty != null ? lengthProperty.value.jsValue : 0;

        if(!isCalledOnArray)
        {
            this.addDependencyToAllModifications(callExpression);

            if(lengthProperty != null && lengthProperty.lastModificationPosition != null)
            {
                this.globalObject.dependencyCreator.createDataDependency
                (
                    callExpression,
                    lengthProperty.lastModificationPosition.codeConstruct,
                    this.globalObject.getPreciseEvaluationPositionId(),
                    lengthProperty.lastModificationPosition.evaluationPositionId
                );
            }

            var indexProperties = this.getPropertiesWithIndexNames();

            var substituteObject = {};

            for(var i = 0; i < indexProperties.length; i++)
            {
                var property = indexProperties[i];
                substituteObject[property.name] = property.value;
            }

            substituteObject.length = length;
        }

        return this.globalObject.internalExecutor.createArray
        (
            callExpression,
            [].slice.apply((isCalledOnArray ? jsArray : substituteObject), this.globalObject.getJsValues(callArguments))
        );
    }
    catch(e) { fcModel.Array.notifyError("When slicing array: " + e);}
};

fcModel.Array.prototype.indexOf = function(jsArray, callArguments, callExpression)
{
    try
    {
        this.addDependenciesToAllProperties(callExpression);
        var isCalledOnArray = this.constructor === fcModel.Array;

        var lengthProperty = this.getProperty("length");
        var lengthPropertyValue = lengthProperty.value;
        var length = lengthPropertyValue != null ? lengthPropertyValue.jsValue : 0;

        var searchObject = jsArray;

        if(!isCalledOnArray)
        {
            this.addDependencyToAllModifications(callExpression);

            if(lengthProperty != null && lengthProperty.lastModificationPosition != null)
            {
                this.globalObject.dependencyCreator.createDataDependency
                (
                    callExpression,
                    lengthProperty.lastModificationPosition.codeConstruct,
                    this.globalObject.getPreciseEvaluationPositionId(),
                    lengthProperty.lastModificationPosition.evaluationPositionId
                );
            }

            var indexProperties = this.getPropertiesWithIndexNames();

            var substituteObject = {};

            for(var i = 0; i < indexProperties.length; i++)
            {
                var property = indexProperties[i];
                substituteObject[property.name] = property.value;
            }

            substituteObject.length = length;

            searchObject = substituteObject;
        }

        var searchForItem = callArguments[0];
        var fromIndex = callArguments[1] != null ? callArguments[1].jsValue : 0;

        if(fromIndex == null) { fromIndex = 0; }

        if(fromIndex < 0)
        {
            fromIndex = length + fromIndex;
        }

        for(var i = fromIndex; i < length; i++)
        {
            if(searchObject[i] === undefined) { return; }

            if(searchObject[i].jsValue === searchForItem.jsValue)
            {
                return this.globalObject.internalExecutor.createInternalPrimitiveObject(callExpression, i);
            }
        }

        return this.globalObject.internalExecutor.createInternalPrimitiveObject(callExpression, -1)
    }
    catch(e) { fcModel.Array.notifyError("When indexOf array: " + e); }
};

fcModel.Array.prototype.lastIndexOf = function(jsArray, callArguments, callExpression)
{
    try
    {
        this.addDependenciesToAllProperties(callExpression);
        var isCalledOnArray = this.constructor === fcModel.Array;

        if(!isCalledOnArray) { alert("lastIndexOf called on non-array!");}

        var lengthProperty = this.getPropertyValue("length");
        var length = lengthProperty != null ? lengthProperty.jsValue : 0;

        var searchForItem = callArguments[0];
        var fromIndex = callArguments[1] != null ? callArguments[1].jsValue : jsArray.length - 1;

        for(var i = fromIndex; i >= 0; i--)
        {
            if(jsArray[i].jsValue === searchForItem.jsValue)
            {
                return this.globalObject.internalExecutor.createInternalPrimitiveObject(callExpression, i);
            }
        }

        return this.globalObject.internalExecutor.createInternalPrimitiveObject(callExpression, -1);
    }
    catch(e) { fcModel.Array.notifyError("When lastIndexOf array: " + e);}
};

fcModel.Array.prototype.join = function(jsArray, callArguments, callExpression)
{
    try
    {
        this.addDependenciesToAllProperties(callExpression);
        var isCalledOnArray = this.constructor === fcModel.Array;

        if(!isCalledOnArray) { alert("join called on non-array!");}

        var lengthProperty = this.getPropertyValue("length");
        var length = lengthProperty != null ? lengthProperty.jsValue : 0;

        var glue = callArguments[0] != null ? callArguments[0].jsValue : ",";
        var result = "";

        var items = this.items;
        for(var i = 0, length = items.length; i < length; i++)
        {
            result += (i != 0 ? glue : "") + items[i].jsValue;
        }

        return this.globalObject.internalExecutor.createInternalPrimitiveObject(callExpression, result);
    }
    catch(e) { fcModel.Array.notifyError("When join array: " + e); }
};
//</editor-fold>

//<editor-fold desc="Js Property Access">
fcModel.Array.prototype.getJsPropertyValue = function(propertyName, codeConstruct)
{
    return this.getPropertyValue(propertyName, codeConstruct);
};

fcModel.Array.prototype.addJsProperty = function(propertyName, propertyValue, codeConstruct)
{
    if(ValueTypeHelper.isInteger(propertyName))
    {
        this.addDependenciesToAllProperties(codeConstruct);
        var oldLength = this.items.length;
        this.items[propertyName] = propertyValue;
        this.jsArray[propertyName] = propertyValue;
        this.addProperty(propertyName, propertyValue, codeConstruct, true);

        if(this.items.length != oldLength)
        {
            this.addProperty("length", this.globalObject.internalExecutor.createInternalPrimitiveObject(codeConstruct, this.items.length), codeConstruct, false);
        }
    }
    else
    {
        if(propertyName == "length")
        {
            if(this.jsArray[propertyName] !== propertyValue.jsValue)
            {
                var oldLength = this.jsArray.length;
                var newLength = propertyValue.jsValue

                if(newLength < oldLength)
                {
                    this.jsArray.length = newLength;
                    this.items.length = newLength;
                }

                for(var i = newLength; i < oldLength; i++)
                {
                    this.deleteProperty(i, codeConstruct);
                }
            }
        }

        this.addProperty(propertyName, propertyValue, codeConstruct, propertyName != "length");
    }
};
//</editor-fold>

//<editor-fold desc="'Private' methods">
fcModel.Array.prototype._registerCallbacks = function()
{
    this.registerGetPropertyCallback(function(getPropertyConstruct) { this.addDependenciesToAllProperties(getPropertyConstruct); }, this);

    this.registerObjectModifiedCallbackDescriptor
    (
        function(modification)
        {
            this.globalObject.dependencyCreator.createDataDependency
            (
                this.dummyDependencyNode,
                modification.codeConstruct,
                this.globalObject.getPreciseEvaluationPositionId(),
                modification.evaluationPositionId
            );
        },
        this
    );
};

fcModel.Array.prototype._addDefaultProperties = function()
{
    this.addProperty("length", this.globalObject.internalExecutor.createInternalPrimitiveObject(this.creationCodeConstruct, 0), this.creationCodeConstruct, false);
    this.addProperty("__proto__", this.globalObject.fcArrayPrototype, null, false);

    this._addRegExResultArrayProperties();
};

fcModel.Array.prototype._addRegExResultArrayProperties = function()
{
    if(this.jsArray.hasOwnProperty("index")) { this.addProperty("index", this.globalObject.internalExecutor.createInternalPrimitiveObject(this.creationCodeConstruct, this.jsArray.index), this.creationCodeConstruct); }
    if(this.jsArray.hasOwnProperty("input")) { this.addProperty("input", this.globalObject.internalExecutor.createInternalPrimitiveObject(this.creationCodeConstruct, this.jsArray.input), this.creationCodeConstruct); }
};

fcModel.Array.prototype._addPreexistingObjects = function()
{
    var dependencyCreator = this.globalObject.dependencyCreator;

    for(var i = 0; i < this.jsArray.length; i++)
    {
        var item = this.jsArray[i];

        if(item === undefined)
        {
            item = this.globalObject.internalExecutor.createInternalPrimitiveObject(this.creationCodeConstruct, undefined);
        }

        this.push(this.jsArray, item, this.creationCodeConstruct, this, true);

        if(this.jsArray[i] != null && this.jsArray[i].codeConstruct != null)
        {
            dependencyCreator.createDataDependency(this.creationCodeConstruct, this.jsArray[i].codeConstruct);
        }
    }
};
//</editor-fold>
//</editor-fold>
}});FBL.ns(function() { with (FBL) {
/*************************************************************************************/
var fcModel = Firecrow.Interpreter.Model;
var ValueTypeHelper = Firecrow.ValueTypeHelper;
fcModel.ArrayCallbackEvaluator =
{
    evaluateCallbackReturn: function(callbackCommand, returnValue, returnExpression)
    {
        try
        {
            var originatingObject = callbackCommand.originatingObject;

            var callbackFunctionValue = callbackCommand.callerFunction.jsValue;
            var targetObject = callbackCommand.targetObject;

            var valueCodeConstruct = returnExpression;

            if(valueCodeConstruct == null) { valueCodeConstruct = returnValue.codeConstruct; }

                 if(callbackFunctionValue.name == "filter") { this._evaluateFilterCallback(targetObject, returnValue, callbackCommand, valueCodeConstruct); return; }
            else if(callbackFunctionValue.name == "map") { this._evaluateMapCallback(targetObject, returnValue, valueCodeConstruct); return; }
            else if(callbackFunctionValue.name == "sort") { this._evaluateSortCallback(targetObject, returnValue, callbackCommand, valueCodeConstruct); return;}
            else if(callbackFunctionValue.name == "every") { this._evaluateEveryCallback(targetObject, returnValue, callbackCommand, valueCodeConstruct); return; }
            else if(callbackFunctionValue.name == "some") { this._evaluateSomeCallback(targetObject, returnValue, callbackCommand, valueCodeConstruct); return; }
            else if(callbackFunctionValue.name == "reduce") { this._evaluateReduceCallback(targetObject, returnValue, callbackCommand, valueCodeConstruct); return; }
            else if(callbackFunctionValue.name == "reduceRight") { fcModel.Array.notifyError("Still not handling evaluate return from reduceRight"); return; }
            else if(callbackFunctionValue.name == "forEach") { }
            else
            {
                debugger;
                fcModel.Array.notifyError("Unknown callbackFunction!");
            }
        }
        catch(e)
        {
            debugger;
            fcModel.Array.notifyError("Error when evaluating callback return!");
        }
    },

    _evaluateFilterCallback: function(targetObject, returnValue, callbackCommand, valueExpression)
    {
        var targetObjectValue = targetObject.jsValue;

        if(!ValueTypeHelper.isArray(targetObjectValue)) { fcModel.Array.notifyError("A new array should be created when calling filter: "); return; }

        if(returnValue != null && returnValue.jsValue)
        {
            targetObject.iValue.push(targetObjectValue, [callbackCommand.arguments[0]], valueExpression.argument || valueExpression);
        }
    },

    _evaluateMapCallback: function(targetObject, returnValue, valueExpression)
    {
        var targetObjectValue = targetObject.jsValue;

        if(!ValueTypeHelper.isArray(targetObjectValue)) { fcModel.Array.notifyError("A new array should be created when calling filter: "); return; }

        targetObject.iValue.push(targetObjectValue, [returnValue], valueExpression.argument || valueExpression);
    },

    _evaluateReduceCallback: function(targetObject, returnValue, callbackCommand, valueExpression)
    {
        var parentCommand = callbackCommand.parentInitCallbackCommand;
        var nextCommand = parentCommand.childCommands[callbackCommand.index + 1];

        if(nextCommand != null)
        {
            nextCommand.arguments[0] = returnValue;
        }
        else
        {
            parentCommand.originatingObject.iValue.globalObject.executionContextStack.setExpressionValueInPreviousContext(parentCommand.codeConstruct, returnValue);
        }
    },

    _evaluateSortCallback: function(targetObject, returnValue, callbackCommand, valueExpression)
    {
        var firstItem = callbackCommand.arguments[0];
        var secondItem = callbackCommand.arguments[1];

        var firstItemIndex = targetObject.jsValue.indexOf(firstItem);
        var secondItemIndex = targetObject.jsValue.indexOf(secondItem);

        targetObject.iValue.addModification(valueExpression, firstItemIndex);
        targetObject.iValue.addModification(callbackCommand.callCallbackCommand.codeConstruct, secondItemIndex);

        //if return value = 0 -> leave a and b unchanged
        if(returnValue.jsValue == 0) { return; }
        //if return value < 0 -> sort a to lower index than b;
        if(returnValue.jsValue < 0 && firstItemIndex <= secondItemIndex) { return; }
        //if return value > 0 -> sort b to lower index than a
        if(returnValue.jsValue > 0 && secondItemIndex <= firstItemIndex) { return; }

        this._swapArrayIndexes(targetObject, firstItemIndex, secondItemIndex, valueExpression);

        if(firstItemIndex + 1 < secondItemIndex)
        {
            this._swapArrayIndexes(targetObject, firstItemIndex + 1, secondItemIndex, valueExpression);
        }
    },

    _evaluateEveryCallback: function(targetObject, returnValue, callbackCommand)
    {
        var parentCommand = callbackCommand.parentInitCallbackCommand;
        parentCommand.originatingObject.iValue.globalObject.executionContextStack.setExpressionValueInPreviousContext(parentCommand.codeConstruct, returnValue);

        if(!returnValue.jsValue)
        {
            parentCommand.originatingObject.iValue.globalObject.browser.interpreter.removeOtherCallbackCommands(parentCommand)
        }
    },

    _evaluateSomeCallback: function(targetObject, returnValue, callbackCommand)
    {
        var parentCommand = callbackCommand.parentInitCallbackCommand;
        parentCommand.originatingObject.iValue.globalObject.executionContextStack.setExpressionValueInPreviousContext(parentCommand.codeConstruct, returnValue);

        if(returnValue.jsValue)
        {
            parentCommand.originatingObject.iValue.globalObject.browser.interpreter.removeOtherCallbackCommands(parentCommand)
        }
    },

    _swapArrayIndexes: function(arrayFcObject, indexA, indexB, modificationExpression)
    {
        var temp = arrayFcObject.jsValue[indexA];
        arrayFcObject.jsValue[indexA] = arrayFcObject.jsValue[indexB];
        arrayFcObject.jsValue[indexB] = temp;

        var temp = arrayFcObject.iValue.items[indexA];
        arrayFcObject.iValue.items[indexA] = arrayFcObject.iValue.items[indexB];
        arrayFcObject.iValue.items[indexB] = temp;

        arrayFcObject.iValue.addProperty(indexA, arrayFcObject.jsValue[indexA], modificationExpression, true);
        arrayFcObject.iValue.addProperty(indexB, arrayFcObject.jsValue[indexB], modificationExpression, true);
    }
};
/*************************************************************************************/
}});/**
 * User: Jomaras
 * Date: 06.11.12.
 * Time: 11:12
 */
FBL.ns(function() { with (FBL) {
/*************************************************************************************/
var fcModel = Firecrow.Interpreter.Model;
var fcSimulator = Firecrow.Interpreter.Simulator;
var ASTHelper = Firecrow.ASTHelper;
fcModel.ArrayExecutor =
{
    executeInternalArrayMethod : function(thisObject, functionObject, args, callExpression, callCommand)
    {
        try
        {
            if(!functionObject.isInternalFunction) { fcModel.Array.notifyError("The function should be internal when executing array method!"); return; }

            var functionObjectValue = functionObject.jsValue;
            var thisObjectValue = thisObject.jsValue;
            var functionName = functionObjectValue.name;
            var fcThisValue =  thisObject.iValue;
            var globalObject = thisObject.iValue.globalObject;

            var isCalledOnArray = fcThisValue.constructor === fcModel.Array;

            if(functionName == "reduce" || functionName == "reduceRight")
            {
                if(thisObjectValue.length == 1 && args[1] == null) { return thisObjectValue[0]; }
                else if (thisObjectValue.length == 0) { return args[1] || globalObject.internalExecutor.createInternalPrimitiveObject(callExpression, undefined); }
            }

            switch(functionName)
            {
                case "toString":
                    var returnValue = isCalledOnArray ? "[object Array]" : "[object Object]";
                    return globalObject.internalExecutor.createInternalPrimitiveObject(callExpression, returnValue);
                case "pop":
                case "reverse":
                case "shift":
                case "push":
                case "slice":
                case "unshift":
                case "splice":
                    if(callExpression != null && ASTHelper.isMemberExpression(callExpression.callee) && ASTHelper.isIdentifier(callExpression.callee.object))
                    {
                        if(!fcThisValue.isDefinedInCurrentContext())
                        {
                            globalObject.browser.logModifyingExternalContextObject(fcThisValue.creationCodeConstruct != null ? fcThisValue.creationCodeConstruct.nodeId : -1, callExpression.callee.object.name)
                        }
                    }
                case "concat":
                case "indexOf":
                case "lastIndexOf":
                case "join":
                    return fcModel.Array.prototype[functionName].apply(fcThisValue, [thisObjectValue, args, callExpression, thisObject]);
                case "sort":
                    //If there is no function argument to sort, execute the internal sort method
                    if(args == null || args.length == 0)
                    {
                        return fcModel.Array.prototype[functionName].apply(fcThisValue, [thisObjectValue, args, callExpression, thisObject]);
                    }
                    //If there is drop down and handle it as a callback method
                case "forEach":
                case "filter":
                case "every":
                case "some":
                case "map":
                case "reduce":
                    var callbackParams = null;

                    if(callCommand.isCall)
                    {
                        callbackParams = callExpression.arguments != null ? callExpression.arguments[1].params : [];
                    }
                    else if (callCommand.isApply)
                    {
                        //debugger;
                    }
                    else
                    {
                        callbackParams = callExpression.arguments != null ? callExpression.arguments[0].params : [];
                    }

                    callCommand.generatesNewCommands = true;
                    callCommand.generatesCallbacks = true;
                    callCommand.setCallbackFunction(args[0]);
                    callCommand.callbackArgumentGroups = this._generateCallbackArguments(thisObject, callbackParams || [], functionName, args, callExpression);
                    callCommand.thisObject =  args[1] || globalObject;
                    callCommand.originatingObject = thisObject;
                    callCommand.callerFunction = functionObject;

                    if(callCommand.originatingObject != null && callCommand.originatingObject.iValue != null && callCommand.originatingObject.iValue.addDependenciesToAllProperties)
                    {
                        callCommand.originatingObject.iValue.addDependenciesToAllProperties(callExpression)
                        if(callCommand.originatingObject.jsValue != null && callCommand.originatingObject.jsValue.length !== null
                        && callCommand.originatingObject.jsValue.length.jsValue != null)
                        {
                            var lengthProperty = callCommand.originatingObject.iValue.getProperty("length");

                            globalObject.internalExecutor.dependencyCreator.createDataDependency
                            (
                                callExpression,
                                lengthProperty.lastModificationPosition.codeConstruct,
                                globalObject.getPreciseEvaluationPositionId()
                            )
                        }
                    }

                    if(functionName == "filter" || functionName == "map")
                    {
                        callCommand.targetObject = globalObject.internalExecutor.createArray(callExpression);
                        return callCommand.targetObject;
                    }
                    else if(functionName == "sort")
                    {
                        callCommand.targetObject = thisObject;
                        return callCommand.targetObject;
                    }
                    else
                    {
                        return new fcModel.fcValue(undefined, undefined, callExpression);
                    }
                break;
                    break;
                default:
                    fcModel.Array.notifyError("Unknown internal array method: " + functionObjectValue.name);
            }
        }
        catch(e) { fcModel.Array.notifyError("Error when executing internal array method: " + e + e.fileName + e.lineNumber); }
    },

    _generateCallbackArguments: function(thisObject, callbackParams, functionName, callArgs, callExpression)
    {
        if(functionName == "sort") { return this._generateSortCallbackArguments(thisObject, callbackParams); }
        if(functionName == "reduce") { return this._generateReduceCallbackArguments(thisObject, callbackParams, callArgs, callExpression);}
        else { return this._generateIterateOverAllItemsCallbackArguments(thisObject, callbackParams); }
    },

    _generateSortCallbackArguments: function(thisObject, callbackParams)
    {
        var thisObjectValue = thisObject.jsValue;

        var callbackArguments = [];

        var length = thisObjectValue.length;
        for(var i = 0; i < length - 1; i++)
        {
            for(var j = i + 1; j < length; j++)
            {
                callbackArguments.push([thisObject.jsValue[i], thisObject.jsValue[j]]);
            }
        }

        return callbackArguments;
    },

    _generateReduceCallbackArguments: function(thisObject, callbackParams, callArgs, callExpression)
    {
        var callbackArguments = [];
        var hasInitialValue = callArgs[1] != null;
        var thisObjectValue = thisObject.jsValue;

        var length = thisObjectValue.length;
        for(var i = hasInitialValue ? 0 : 1; i < length; i++)
        {
            callbackArguments.push
            ([
                i == 0 ? callArgs[1] : thisObject.jsValue[i - 1],
                thisObject.jsValue[i],
                thisObject.iValue.globalObject.internalExecutor.createInternalPrimitiveObject(callExpression, i),
                thisObject
            ]);
        }

        return callbackArguments;
    },

    _generateIterateOverAllItemsCallbackArguments: function(thisObject, callbackParams)
    {
        var thisObjectValue = thisObject.jsValue;
        var globalObject = thisObject.iValue.globalObject;
        var callbackArguments = [];

        var length = thisObjectValue.length !== null && thisObjectValue.length.jsValue == null
                   ? thisObjectValue.length
                   : thisObjectValue.length.jsValue;

        for(var i = 0; i < length; i++)
        {
            var item = thisObjectValue[i];
            if(item !== undefined)
            {
                callbackArguments.push([item, globalObject.internalExecutor.createInternalPrimitiveObject(callbackParams[i], i), thisObject]);
            }
        }

        return callbackArguments;
    },

    isInternalArrayMethod: function(potentialFunction)
    {
        var methods = fcModel.ArrayPrototype.CONST.INTERNAL_PROPERTIES.METHODS;

        for(var i = 0; i < methods.length; i++)
        {
            if(Array.prototype[methods[i]] === potentialFunction)
            {
                return true;
            }
        }

        return false;
    }
};
/*************************************************************************************/
}});FBL.ns(function() { with (FBL) {
/*************************************************************************************/
var fcModel = Firecrow.Interpreter.Model;

fcModel.ArrayFunction = function(globalObject)
{
    try
    {
        this.initObject(globalObject);

        this.addProperty("prototype", globalObject.fcArrayPrototype);
        this.proto = globalObject.fcFunctionPrototype;

        this.isInternalFunction = true;
        this.name = "Array";

        fcModel.ArrayPrototype.CONST.INTERNAL_PROPERTIES.METHODS.forEach(function(propertyName)
        {
            //Right instanceof reuse HACK - the problem that the second
            //application is executed within the same scope, so they target the same global objects
            //RW the reuse process, to be independent in phantomJs
            this.addProperty
            (
                propertyName,
                new fcModel.fcValue
                (
                    FBL.Firecrow.INTERNAL_PROTOTYPE_FUNCTIONS.Array[propertyName],
                    fcModel.Function.createInternalNamedFunction(globalObject, propertyName, this),
                    null
                ),
                null,
                false
            );
        }, this);
    }
    catch(e){ fcModel.Array.notifyError("Error when creating Array Function:" + e); }
};

fcModel.ArrayFunction.prototype = new fcModel.Object();
/*************************************************************************************/
}});/**
 * User: Jomaras
 * Date: 06.11.12.
 * Time: 11:05
 */
FBL.ns(function() { with (FBL) {
/*************************************************************************************/
var fcModel = Firecrow.Interpreter.Model;

fcModel.ArrayPrototype = function(globalObject)
{
    try
    {
        this.initObject(globalObject, null, Array.prototype, globalObject.fcObjectPrototype);

        this.constructor = fcModel.ArrayPrototype;
        this.name = "ArrayPrototype";
        this.addProperty("__proto__", this.globalObject.fcObjectPrototype);

        fcModel.ArrayPrototype.CONST.INTERNAL_PROPERTIES.METHODS.forEach(function(propertyName)
        {
            this.addProperty
            (
                propertyName,
                new fcModel.fcValue
                (
                    Array.prototype[propertyName],
                    fcModel.Function.createInternalNamedFunction(globalObject, propertyName, this),
                    null
                ),
                null,
                false
            );
        }, this);
    }
    catch(e) { fcModel.Array.notifyError("Error when creating array prototype:" + e); }
};

fcModel.ArrayPrototype.prototype = new fcModel.Object();

//https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array#Methods_2
fcModel.ArrayPrototype.CONST =
{
    INTERNAL_PROPERTIES :
    {
        METHODS: ["pop","push","reverse","shift","sort","splice","unshift","concat","join","slice","indexOf","lastIndexOf","filter","forEach","every","map","some","reduce","reduceRight", "toString"],
        CALLBACK_METHODS: ["filter", "forEach", "every", "map", "some", "reduce", "reduceRight"]
    }
};
/****************************************************************************************************/
}});/**
 * User: Jomaras
 * Date: 26.07.12.
 * Time: 16:21
 */
FBL.ns(function() { with (FBL) {
/*************************************************************************************/
var fcModel = Firecrow.Interpreter.Model;
var ValueTypeHelper = Firecrow.ValueTypeHelper;
var FIRECROW_AJAX_PROXY_URL = "http://localhost/Firecrow/proxy/proxy.php";

fcModel.XMLHttpRequest = function(xmlHttpRequestObject, globalObject, codeConstruct)
{
    this.initObject(globalObject, codeConstruct, xmlHttpRequestObject);
    this.constructor = fcModel.XMLHttpRequest;

    this.openConstruct = null;
    this.sendConstruct = null;
    this.setHeadersConstructs = [];

    this.addProperty("status", this.globalObject.internalExecutor.createInternalPrimitiveObject(codeConstruct, this.implementationObject.status));
    this.addProperty("readyState", this.globalObject.internalExecutor.createInternalPrimitiveObject(codeConstruct, 0), codeConstruct);
    this.addProperty("responseType", this.globalObject.internalExecutor.createInternalPrimitiveObject(codeConstruct, ""), codeConstruct);
    this.addProperty("responseText", this.globalObject.internalExecutor.createInternalPrimitiveObject(codeConstruct, ""), codeConstruct);

    fcModel.XMLHttpRequestPrototype.CONST.INTERNAL_PROPERTIES.METHODS.forEach(function(propertyName)
    {
        var internalFunction = globalObject.internalExecutor.createInternalFunction(XMLHttpRequest.prototype[propertyName], propertyName, this, true);
        this[propertyName] = internalFunction;
        this.addProperty(propertyName, internalFunction, null, false);
    }, this);

    this.name = "XMLHttpRequest";

    this.updateToOpened = function(codeConstruct)
    {
        this.addProperty("readyState", this.globalObject.internalExecutor.createInternalPrimitiveObject(codeConstruct, 1));
    };

    this.updateToSent = function(codeConstruct)
    {
        this.addProperty("readyState", this.globalObject.internalExecutor.createInternalPrimitiveObject(codeConstruct, 2));
        this.addProperty("status", this.globalObject.internalExecutor.createInternalPrimitiveObject(codeConstruct, this.status));
        this.addProperty("statusText", this.globalObject.internalExecutor.createInternalPrimitiveObject(codeConstruct, this.statusText));
    };

    this.updateToLoading = function(codeConstruct)
    {
        this.addProperty("readyState", this.globalObject.internalExecutor.createInternalPrimitiveObject(codeConstruct, 3));
        this.addProperty("responseText", this.globalObject.internalExecutor.createInternalPrimitiveObject(codeConstruct, this.responseText));
        this.addProperty("responseType", this.globalObject.internalExecutor.createInternalPrimitiveObject(codeConstruct, this.responseType));
        this.addProperty("status", this.globalObject.internalExecutor.createInternalPrimitiveObject(codeConstruct, this.status));
        this.addProperty("statusText", this.globalObject.internalExecutor.createInternalPrimitiveObject(codeConstruct, this.statusText));
    };

    this.updateToDone = function(codeConstruct)
    {
        this.addProperty("readyState", this.globalObject.internalExecutor.createInternalPrimitiveObject(codeConstruct, 4));
        this.addProperty("responseText", this.globalObject.internalExecutor.createInternalPrimitiveObject(codeConstruct, this.responseText));
        this.addProperty("responseType", this.globalObject.internalExecutor.createInternalPrimitiveObject(codeConstruct, this.responseType));
        this.addProperty("status", this.globalObject.internalExecutor.createInternalPrimitiveObject(codeConstruct, this.status));
        this.addProperty("statusText", this.globalObject.internalExecutor.createInternalPrimitiveObject(codeConstruct, this.statusText))
    };

    this.updateToNext = function()
    {
        switch(this.getPropertyValue("readyState").jsValue)
        {
            case 1: this.updateToSent(this.sendConstruct); break;
            case 2: this.updateToLoading(this.sendConstruct); break;
            case 3: this.updateToDone(this.sendConstruct); break;
            default: break;
        }
    };
};

fcModel.XMLHttpRequest.prototype = new fcModel.Object();

fcModel.XMLHttpRequestPrototype = function(globalObject)
{
    try
    {
        this.initObject(globalObject);
        this.constructor = fcModel.XMLHttpRequestPrototype;
        this.name = "XMLHttpRequestPrototype";

        fcModel.XMLHttpRequestPrototype.CONST.INTERNAL_PROPERTIES.METHODS.forEach(function(propertyName)
        {
            var internalFunction = globalObject.internalExecutor.createInternalFunction(XMLHttpRequest.prototype[propertyName], propertyName, this, true);
            this[propertyName] = internalFunction;
            this.addProperty(propertyName, internalFunction, null, false);
        }, this);
    }
    catch(e) { Firecrow.Interpreter.Model.RegEx.notifyError("Error when creating regEx prototype:" + e); }
};

fcModel.XMLHttpRequest.notifyError = function(message) { alert("XMLHttpRequest - " + message); }

fcModel.XMLHttpRequestPrototype.prototype = new fcModel.Object();

fcModel.XMLHttpRequestPrototype.CONST =
{
    INTERNAL_PROPERTIES :
    {
        METHODS: ["open","setRequestHeader","send", "abort", "getAllResponseHeaders", "getResponseHeader"],
        PROPERTIES: ["onreadystatechange", "readyState", "response", "responseText", "responseType", "responseXML", "status", "statusText", "timeout", "upload", "withCredentials"]
    }
};

fcModel.XMLHttpRequestFunction = function(globalObject)
{
    try
    {
        this.initObject(globalObject);

        this.addProperty("prototype", globalObject.fcXMLHttpRequestPrototype);

        this.isInternalFunction = true;
        this.name = "XMLHttpRequest";
    }
    catch(e){ Firecrow.Interpreter.Model.XMLHttpRequest.notifyError("Error when creating XMLHttpRequest Function:" + e); }
};

fcModel.XMLHttpRequestFunction.prototype = new fcModel.Object();

fcModel.XMLHttpRequestExecutor =
{
    executeInternalXmlHttpRequestMethod: function(thisObject, functionObject, args, callExpression)
    {
        try
        {
            if(!ValueTypeHelper.isXMLHttpRequest(thisObject.jsValue)) { this.notifyError("The called on object should be a XMLHttpRequest!"); return; }
            if(!functionObject.isInternalFunction) { this.notifyError("The function should be internal when executing XMLHttpRequest method!"); return; }

            var functionObjectValue = functionObject.jsValue;
            var thisObjectValue = thisObject.jsValue;
            var functionName = functionObjectValue.name;
            var fcThisValue =  thisObject.iValue;
            var globalObject = fcThisValue.globalObject;
            var nativeArgs = globalObject.getJsValues(args);

            //this.addModification(callExpression);
            //this.addDependencyToAllModifications(callExpression);

            switch(functionName)
            {
                case "open":
                    this._updateOpenParameters(fcThisValue, nativeArgs, globalObject, callExpression);
                    this._updateNativeOpenArguments(nativeArgs, globalObject);
                    thisObjectValue[functionName].apply(thisObjectValue, nativeArgs);
                    break;
                case "send":
                    this._updateNativeSendArguments(fcThisValue, nativeArgs);
                    thisObjectValue[functionName].apply(thisObjectValue, nativeArgs);
                    this._updateSendParameters(fcThisValue, callExpression);

                    fcThisValue.async ? this._aggregateEvents(fcThisValue, globalObject, callExpression)
                                      : fcThisValue.updateToDone(callExpression);

                    this._createSendDependencies(fcThisValue, globalObject, callExpression);
                    break;
                case "setRequestHeader":
                    thisObjectValue[functionName].apply(thisObjectValue, nativeArgs);
                    fcThisValue.setHeadersConstructs.push(callExpression);
                    break;
                case "getAllResponseHeaders":
                case "getResponseHeader":
                    return globalObject.internalExecutor.createInternalPrimitiveObject(callExpression, thisObjectValue[functionName].apply(thisObjectValue, nativeArgs));
                    this._createGetResponseHeaderDependencies(fcThisValue, globalObject, callExpression);
                default:
                    this.notifyError("Unknown method on XMLHttpRequest object: " + functionName);
            }
        }
        catch(e) { debugger; this.notifyError("Error when executing internal XMLHttpRequest method: " + e); }
    },

    _createSendDependencies: function(fcThisValue, globalObject, callExpression)
    {
        globalObject.dependencyCreator.createDataDependency(callExpression, fcThisValue.openConstruct, globalObject.getPreciseEvaluationPositionId());

        fcThisValue.setHeadersConstructs.forEach(function(construct)
        {
            globalObject.dependencyCreator.createDataDependency(callExpression, construct, globalObject.getPreciseEvaluationPositionId());
        });
    },

    _createGetResponseHeaderDependencies: function(fcThisValue, globalObject, callExpression)
    {
        globalObject.dependencyCreator.createDataDependency(callExpression, fcThisValue.openConstruct, globalObject.getPreciseEvaluationPositionId());

        if(fcThisValue.sendConstruct != null)
        {
            globalObject.dependencyCreator.createDataDependency(callExpression, fcThisValue.sendConstruct, globalObject.getPreciseEvaluationPositionId())
        }
    },

    _updateNativeOpenArguments: function(nativeArgs, globalObject)
    {
        nativeArgs[0] = nativeArgs[0] || "GET";
        var url = Firecrow.UriHelper.getAbsoluteUrl(nativeArgs[1], globalObject.browser.url);

        if(Firecrow.UriHelper.areOnSameDomain(url, Firecrow.getDocument().location.href))
        {
            nativeArgs[1] = url;
        }
        else
        {
            var requestUrl = Firecrow.UriHelper.getRequestAddress(url);
            if(nativeArgs[0] == "GET")
            {
                var extendedRequest = Firecrow.UriHelper.appendQuery(url, "csurl", requestUrl);
                nativeArgs[1] = FIRECROW_AJAX_PROXY_URL + "?" + Firecrow.UriHelper.getQuery(extendedRequest);
            }
            else
            {
                nativeArgs[1] = FIRECROW_AJAX_PROXY_URL;
            }
        }

        nativeArgs[2] = false;
        //Apply to native object, but change to sync
    },

    _updateNativeSendArguments: function(fcThisValue, nativeArgs)
    {
        if(fcThisValue.method != "POST") { return; }
        if(nativeArgs[0] == null) { nativeArgs[0] = ""; }

        if(nativeArgs[0] != "") { nativeArgs[0] += "&"; }

        nativeArgs[0] += "csurl=" + encodeURIComponent(fcThisValue.absoluteUrl);
    },

    _updateOpenParameters: function(fcThisValue, nativeArgs, globalObject, callExpression)
    {
        fcThisValue.method = nativeArgs[0] || "GET";
        fcThisValue.url = nativeArgs[1] || "";
        fcThisValue.absoluteUrl = Firecrow.UriHelper.getAbsoluteUrl(nativeArgs[1], globalObject.browser.url);
        fcThisValue.async = nativeArgs[2];
        fcThisValue.user = nativeArgs[3] || "";
        fcThisValue.password = nativeArgs[4] || "";

        fcThisValue.updateToOpened(callExpression);
        fcThisValue.openConstruct = callExpression;
    },

    _updateSendParameters: function(fcThisValue, callExpression)
    {
        fcThisValue.readyState = fcThisValue.implementationObject.readyState;
        fcThisValue.timeout = fcThisValue.implementationObject.timeout;

        fcThisValue.status = fcThisValue.implementationObject.status;
        fcThisValue.responseText = fcThisValue.implementationObject.responseText;
        fcThisValue.response = fcThisValue.implementationObject.response;
        fcThisValue.responseType = fcThisValue.implementationObject.responseType;
        fcThisValue.responseXML = fcThisValue.implementationObject.responseXML;
        fcThisValue.statusText = fcThisValue.implementationObject.statusText;

        fcThisValue.sendConstruct = callExpression;
    },

    _aggregateEvents: function(fcThisValue, globalObject, callExpression)
    {
        for(var i = 0; i < 4; i++)
        {
            globalObject.preRegisterAjaxEvent
            (
                fcThisValue,
                {
                    codeConstruct: callExpression,
                    evaluationPositionId: globalObject.getPreciseEvaluationPositionId()
                }
            );
        }
    },

    notifyError: function(message) { debugger; Firecrow.Interpreter.Model.XMLHttpRequest.notifyError(message);}
};
/*************************************************************************************/
}});/**
 * User: Jomaras
 * Date: 13.06.12.
 * Time: 10:36
 */
FBL.ns(function() { with (FBL) {
/*************************************************************************************/
var fcModel = Firecrow.Interpreter.Model;
var ValueTypeHelper = Firecrow.ValueTypeHelper;

fcModel.Math = function(globalObject)
{
    this.initObject(globalObject);

    fcModel.Math.CONST.INTERNAL_PROPERTIES.PROPERTIES.forEach(function(property)
    {
        var propertyValue = this.globalObject.internalExecutor.createInternalPrimitiveObject(null, Math[property]);
        this.addProperty(property, propertyValue, null);
        this[property] = propertyValue;
    }, this);

    fcModel.Math.CONST.INTERNAL_PROPERTIES.METHODS.forEach(function(propertyName)
    {
        var propertyValue = new fcModel.fcValue
        (
            Math[propertyName],
            fcModel.Function.createInternalNamedFunction(globalObject, propertyName, this),
            null
        );

        propertyValue.isMathFunction = true;

        this.addProperty(propertyName, propertyValue, null, false);
    }, this);
};

Firecrow.Interpreter.Model.Math.prototype = new fcModel.Object();

Firecrow.Interpreter.Model.Math.notifyError = function(message){ alert("Math - " + message); };

fcModel.Math.CONST =
{
    INTERNAL_PROPERTIES:
    {
        PROPERTIES: ["E", "LN2", "LN10", "LOG2E", "LOG10E", "PI", "SQRT1_2", "SQRT2"],
        METHODS:
        [
            "abs", "acos", "asin", "atan", "atan2", "ceil", "cos", "exp", "floor",
            "log", "max", "min", "pow", "random", "round", "sin", "sqrt", "tan"
        ]
    }
}

fcModel.Math.prototype = new fcModel.Object();
fcModel.MathExecutor =
{
    executeInternalMethod: function(thisObject, functionObject, args, callExpression)
    {
        try
        {
            if(!functionObject.isInternalFunction) { fcModel.notifyError("The function should be internal when executing Math method!"); return; }

            return new fcModel.fcValue
            (
                Math[functionObject.jsValue.name].apply(null, functionObject.iValue.globalObject.getJsValues(args)),
                null,
                callExpression
            );
        }
        catch(e) { fcModel.Math.notifyError("Error when executing internal math method: " + e);}
    },

    isInternalMathMethod: function(functionObject)
    {
        return fcModel.Math.CONST.INTERNAL_PROPERTIES.METHODS.indexOf(functionObject.name) != -1;
    }
}
/*************************************************************************************/
}});/**
 * User: Jomaras
 * Date: 03.06.12.
 * Time: 07:39
 */
FBL.ns(function() { with (FBL) {
/*************************************************************************************/
var fcModel = Firecrow.Interpreter.Model;
var ValueTypeHelper = Firecrow.ValueTypeHelper;

fcModel.RegEx = function(jsRegExp, globalObject, codeConstruct)
{
    try
    {
        this.jsRegExp = jsRegExp;
        this.constructor = fcModel.RegEx;

        this.initObject(globalObject, codeConstruct, jsRegExp, globalObject.fcRegExPrototype);

        this.addProperty("lastIndex", this.globalObject.internalExecutor.createInternalPrimitiveObject(codeConstruct, 0), codeConstruct);
        this.addProperty("ignoreCase", this.globalObject.internalExecutor.createInternalPrimitiveObject(codeConstruct, jsRegExp.ignoreCase), codeConstruct);
        this.addProperty("global", this.globalObject.internalExecutor.createInternalPrimitiveObject(codeConstruct, jsRegExp.global), codeConstruct);
        this.addProperty("multiline", this.globalObject.internalExecutor.createInternalPrimitiveObject(codeConstruct, jsRegExp.multiline), codeConstruct);
        this.addProperty("source", this.globalObject.internalExecutor.createInternalPrimitiveObject(codeConstruct, jsRegExp.source), codeConstruct);

        fcModel.RegExPrototype.CONST.INTERNAL_PROPERTIES.METHODS.forEach(function(propertyName)
        {
            this.addProperty
            (
                propertyName,
                new fcModel.fcValue
                (
                    this.jsRegExp[propertyName],
                    fcModel.Function.createInternalNamedFunction(globalObject, propertyName, this),
                    null
                ),
                null,
                false
            );
        }, this);

        this.modifications = [];

        this.registerGetPropertyCallback(function(getPropertyConstruct)
        {
            this.addDependenciesToAllModifications(getPropertyConstruct);
        }, this);

        this.getJsPropertyValue = function(propertyName, codeConstruct)
        {
            return this.getPropertyValue(propertyName, codeConstruct);
        };

        this.addDependenciesToAllModifications = function(codeConstruct)
        {
            try
            {
                if(codeConstruct == null) { return; }

                for(var i = 0, length = this.modifications.length; i < length; i++)
                {
                    var modification = this.modifications[i];

                    this.globalObject.dependencyCreator.createDataDependency
                    (
                        codeConstruct,
                        modification.codeConstruct,
                        this.globalObject.getPreciseEvaluationPositionId(),
                        modification.evaluationPositionId
                    );
                }
            }
            catch(e)
            {
                Firecrow.Interpreter.Model.RegEx.notifyError("Error when registering getPropertyCallback: " + e + " " + codeConstruct.loc.source);
            }
        }
    }
    catch(e) { Firecrow.Interpreter.Model.RegEx.notifyError("Error when creating RegExp object: " + e); }
};

fcModel.RegEx.notifyError = function(message) { alert("RegEx - " + message); }
fcModel.RegEx.prototype = new fcModel.Object();

fcModel.RegExPrototype = function(globalObject)
{
    try
    {
        this.initObject(globalObject, null, RegExp.prototype, globalObject.fcObjectPrototype);
        this.constructor = fcModel.RegExPrototype;
        this.name = "RegExPrototype";

        fcModel.RegExPrototype.CONST.INTERNAL_PROPERTIES.METHODS.forEach(function(propertyName)
        {
            var internalFunction = globalObject.internalExecutor.createInternalFunction(RegExp.prototype[propertyName], propertyName, this, true);
            this[propertyName] = internalFunction;
            this.addProperty(propertyName, internalFunction, null, false);
        }, this);
    }
    catch(e) { Firecrow.Interpreter.Model.RegEx.notifyError("Error when creating regEx prototype:" + e); }
};

fcModel.RegExPrototype.prototype = new fcModel.Object();

fcModel.RegExPrototype.CONST =
{
    INTERNAL_PROPERTIES :
    {
        METHODS: ["exec","test","toSource"],
        PROPERTIES: ["global", "ignoreCase", "lastIndex", "multiline", "source"]
    }
};

fcModel.RegExFunction = function(globalObject)
{
    try
    {
        this.initObject(globalObject, null, RegExp, globalObject.fcFunctionPrototype);

        this.addProperty("prototype", globalObject.fcRegExPrototype);

        this.isInternalFunction = true;
        this.name = "RegExp";
    }
    catch(e){ Firecrow.Interpreter.Model.RegEx.notifyError("Error when creating RegEx Function:" + e); }
};

fcModel.RegExFunction.prototype = new fcModel.Object();

fcModel.RegExExecutor =
{
    executeInternalRegExMethod: function(thisObject, functionObject, args, callExpression)
    {
        try
        {
            if(!ValueTypeHelper.isRegExp(thisObject.jsValue)) { this.notifyError("The called on object should be a regexp!"); return; }
            if(!functionObject.isInternalFunction) { this.notifyError("The function should be internal when executing regexp method!"); return; }

            var functionObjectValue = functionObject.jsValue;
            var thisObjectValue = thisObject.jsValue;
            var functionName = functionObjectValue.name;
            var fcThisValue =  thisObject.iValue;
            var globalObject = fcThisValue.globalObject;

            switch(functionName)
            {
                case "exec":
                    var result = thisObjectValue[functionName].apply(thisObjectValue, globalObject.getJsValues(args));
                    fcThisValue.addProperty("lastIndex", new fcModel.fcValue(thisObjectValue.lastIndex, thisObjectValue.lastIndex, callExpression),callExpression);

                    fcThisValue.addDependenciesToAllModifications(callExpression);
                    fcThisValue.modifications.push({codeConstruct: callExpression, evaluationPositionId: fcThisValue.globalObject.getPreciseEvaluationPositionId()});

                    if(result == null) { return new fcModel.fcValue(null, null, callExpression); }
                    else if (ValueTypeHelper.isArray(result))
                    {
                        var internalPrimitives = [];

                        for(var i = 0; i < result.length; i++)
                        {
                            internalPrimitives.push(globalObject.internalExecutor.createInternalPrimitiveObject(callExpression, result[i]));
                        }

                        return fcThisValue.globalObject.internalExecutor.createArray(callExpression, internalPrimitives);
                    }
                    else
                    {
                        this.notifyError("Unknown result when exec regexp: " + result);
                        debugger;
                        return null;
                    }
                case "test":
                    var result = thisObjectValue[functionName].apply(thisObjectValue, globalObject.getJsValues(args));
                    return globalObject.internalExecutor.createInternalPrimitiveObject(callExpression, result);
                case "toSource":
                    this.notifyError("ToSource not supported on regExp!");
                    return null;
                default:
                    this.notifyError("Unknown method on string");
            }
        }
        catch(e) {this.notifyError("Error when executing internal RegEx method: " + e); }
    },

    notifyError: function(message) { Firecrow.Interpreter.Model.RegEx.notifyError(message);}
};
}});FBL.ns(function() { with (FBL) {
/*************************************************************************************/
var fcModel = Firecrow.Interpreter.Model;

//<editor-fold desc="Function">
fcModel.Function = function(globalObject, scopeChain, codeConstruct, value)
{
    this.initObject(globalObject, codeConstruct, value);

    this.object = this;
    this.codeConstruct = codeConstruct;
    this.scopeChain = scopeChain;

    this.value = value;

    this._setDefaultProperties();
};

fcModel.Function.createInternalNamedFunction = function(globalObject, name, ownerObject)
{
    try
    {
        var functionObject = new fcModel.Function(globalObject, []);

        functionObject.name = name;
        functionObject.isInternalFunction = true;
        functionObject.ownerObject = ownerObject;

        return functionObject;
    }
    catch(e) { fcModel.Function.notifyError("Error when creating Internal Named Function: " + e); }
};

fcModel.Function.notifyError = function(message) { alert("Function - " + message); };
fcModel.Function.prototype = new fcModel.Object();

fcModel.Function.prototype.bind = function(args, callExpression)
{
    this.isBound = true;
    this.bounder = args[0];
    this.argsToPrepend = args.slice(1);
    this.bindingExpression = callExpression;
};

fcModel.Function.prototype.getJsPropertyValue = function(propertyName, codeConstruct)
{
    return this.getPropertyValue(propertyName, codeConstruct);
};
fcModel.Function.prototype._setDefaultProperties = function()
{
    this.addProperty("prototype", this.globalObject.internalExecutor.createNonConstructorObject(this.codeConstruct, this.value != null ? this.value.prototype : null));
    this.addProperty("__proto__", this.globalObject.fcFunctionPrototype);

    this._setLengthProperty();
};

fcModel.Function.prototype._setLengthProperty = function()
{
    var length = 0;

    if(this.codeConstruct != null && this.codeConstruct.params != null)
    {
        length = this.codeConstruct.params.length;
    }

    this.addProperty("length", this.globalObject.internalExecutor.createInternalPrimitiveObject(this.codeConstruct, length), this.codeConstruct, false);

};
//</editor-fold>

//<editor-fold desc="Function prototype">
fcModel.FunctionPrototype = function(globalObject)
{
    try
    {
        this.initObject(globalObject, null, Function.prototype, globalObject.fcObjectPrototype);

        this.constructor = fcModel.FunctionPrototype;
        this.proto = this.globalObject.fcObjectPrototype;
        this.name = "FunctionPrototype";

        //https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function#Methods_2
    }
    catch(e) { fcModel.Function.notifyError ("Error when creating function prototype:" + e); }
};

fcModel.FunctionPrototype.prototype = new fcModel.Object();
fcModel.FunctionPrototype.prototype.initFunctionPrototype = function()
{
    fcModel.FunctionPrototype.CONST.INTERNAL_PROPERTIES.METHODS.forEach(function(propertyName)
    {
        if(Function.prototype[propertyName])
        {
            this.addProperty
            (
                propertyName,
                new fcModel.fcValue
                (
                    Function.prototype[propertyName],
                    fcModel.Function.createInternalNamedFunction(this.globalObject, propertyName, this),
                    null
                ),
                null,
                false
            );
        }
    }, this);
}

fcModel.FunctionPrototype.CONST =
{
    INTERNAL_PROPERTIES :
    {
        METHODS: ["apply", "call", "toString", "bind"]
    }
};
//</editor-fold>
/*************************************************************************************/
}});
/**
 * Created by Jomaras.
 * Date: 10.03.12.@09:49
 */
FBL.ns(function() { with (FBL) {
/*************************************************************************************/
var ASTHelper = Firecrow.ASTHelper;
var fcModel = Firecrow.Interpreter.Model;

fcModel.Identifier = function(name, value, codeConstruct, globalObject)
{
    try
    {
        this.id = fcModel.Identifier.LAST_ID++;
        this.name = name;
        this.value = value;
        this.globalObject = globalObject;

        //this.modificationPositions = [];
        this.lastModificationPosition = null;

        if(codeConstruct != null)
        {
            this.declarationPosition = { codeConstruct: codeConstruct, evaluationPositionId: globalObject.getPreciseEvaluationPositionId()};

            if(ASTHelper.isObjectExpressionPropertyValue(codeConstruct))
            {
                this.lastModificationPosition = { codeConstruct: codeConstruct.value, evaluationPositionId: globalObject.getPreciseEvaluationPositionId()};
            }
            else
            {
                this.lastModificationPosition = this.declarationPosition;
            }

            //this.modificationPositions.push(this.declarationPosition);
        }
    }
    catch(e) { fcModel.Identifier.notifyError("Error when constructing: " + e ); }
};

fcModel.Identifier.notifyError = function(message) { alert("Identifier - " + message); };

fcModel.Identifier.prototype =
{
    setValue: function(newValue, modificationConstruct, keepOldValue)
    {
        try
        {
            if(this.writable === false) { return; }

            if(keepOldValue) { this.oldValue = this.value; }

            this.value = newValue;

            if(modificationConstruct != null)
            {
                this.lastModificationPosition = { codeConstruct: modificationConstruct, evaluationPositionId: this.globalObject.getPreciseEvaluationPositionId()};
                //this.modificationPositions.push({ codeConstruct: modificationConstruct, evaluationPositionId: this.globalObject.getPreciseEvaluationPositionId()});
            }

            if(this.declarationPosition == null) //internal property that is being overridden
            {
                this.declarationPosition = { codeConstruct: modificationConstruct, evaluationPositionId: this.globalObject.getPreciseEvaluationPositionId()};
            }
        }
        catch(e) { Firecrow.Interpreter.Model.Identifier.notifyError("Error when setting value: " + e); }
    },

    restoreOldValue: function()
    {
        if(this.oldValue)
        {
            this.value = this.oldValue;
        }
    }
};

fcModel.Identifier.LAST_ID = 0;
/****************************************************************************/
}});FBL.ns(function() { with (FBL) {
/*************************************************************************************/
var ValueTypeHelper = Firecrow.ValueTypeHelper;
var fcModel = Firecrow.Interpreter.Model;

Firecrow.Interpreter.Model.FunctionFunction = function(globalObject)
{
    this.initObject(globalObject, null, Function, globalObject.fcFunctionPrototype);

    this.addProperty("prototype", this.globalObject.fcFunctionPrototype);

    this.isInternalFunction = true;
    this.name = "Function";
};

Firecrow.Interpreter.Model.FunctionFunction.prototype = new fcModel.Object();
Firecrow.Interpreter.Model.FunctionFunction.prototype.getJsPropertyValue = function(propertyName, codeConstruct)
{
    return this.getPropertyValue(propertyName, codeConstruct);
};
/*************************************************************************************/
}});/**
 * Created by Jomaras.
 * Date: 16.03.12.@15:36
 */
FBL.ns(function() { with (FBL) {
/*************************************************************************************/
var ValueTypeHelper = Firecrow.ValueTypeHelper;
var fcModel = Firecrow.Interpreter.Model;

fcModel.Date = function(value, globalObject, codeConstruct)
{
    try
    {
        this.initObject(globalObject);
        this.constructor = fcModel.Date;

        this.value = value;

        this.addProperty("__proto__", this.globalObject.fcDatePrototype);
    }
    catch(e) { fcModel.Date.notifyError("Error when creating a Date object: " + e); }
};

fcModel.Date.notifyError = function(message) { alert("Date - " + message); };
fcModel.Date.prototype = new fcModel.Object();

fcModel.DatePrototype = function(globalObject)
{
    try
    {
        this.initObject(globalObject, null, Date.prototype, globalObject.fcObjectPrototype);
        this.constructor = fcModel.DatePrototype;
        this.name = "DatePrototype";
        //https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Date#Methods_2
        fcModel.DatePrototype.CONST.INTERNAL_PROPERTIES.METHODS.forEach(function(propertyName)
        {
            if(Date.prototype[propertyName] == null) { return; }
            this.addProperty
            (
                propertyName,
                new fcModel.fcValue
                (
                    Date.prototype[propertyName],
                    fcModel.Function.createInternalNamedFunction(globalObject, propertyName, this),
                    null
                ),
                null,
                false
            );
        }, this);
    }
    catch(e) { fcModel.Date.notifyError("DatePrototype - error when creating date prototype:" + e); }
};

fcModel.DatePrototype.CONST =
{
    INTERNAL_PROPERTIES :
    {
        METHODS:
        [
            "getDate", "getDay", "getFullYear", "getHours", "getMilliseconds", "getMinutes",
            "getMonth", "getSeconds", "getTime", "getTimezoneOffset", "getUTCDate", "getUTCDay",
            "getUTCFullYear", "getUTCHours", "getUTCMilliseconds", "getUTCMinutes", "getUTCSeconds",
            "getYear", "setDate", "setFullYear", "setHours", "setMilliseconds", "setMinutes",
            "setMonth", "setSeconds", "setTime", "setUTCDate", "setUTCFullYear", "setUTCHours",
            "setUTCMilliseconds", "setUTCMinutes", "setUTCMonth", "setUTCSeconds", "setYear",
            "toDateString", "toISOString", "toJSON", "toGMTString", "toLocaleDateString",
            "toLocaleFormat", "toLocaleString", "toLocaleTimeString", "toSource", "toString",
            "toTimeString", "toUTCString", "valueOf"
        ]
    },
    FUNCTION_PROPERTIES:
    {
        METHODS:  ["now", "parse", "UTC"]
    }
};

fcModel.DatePrototype.prototype = new fcModel.Object(null);

fcModel.DateFunction = function(globalObject)
{
    try
    {
        this.initObject(globalObject, null, Date, globalObject.fcFunctionPrototype);

        this.addProperty("prototype", globalObject.fcDatePrototype);

        this.isInternalFunction = true;
        this.name = "Date";
    }
    catch(e){ fcModel.Date.notifyError("Date - error when creating Date Function:" + e); }
};

fcModel.DateFunction.prototype = new fcModel.Object(null);

fcModel.DateExecutor =
{
    executeFunctionMethod: function(thisObject, functionObject, args, callExpression, globalObject)
    {
        try
        {
            return new fcModel.fcValue
            (
                Date[functionObject.value.name].apply(null, globalObject.getJsValues(args)),
                null,
                callExpression
            );
        }
        catch(e) { fcModel.Date.notifyError("Date - error when executing Date functions:" + e); }
    },

    executeInternalConstructor: function(callExpression, arguments, globalObject)
    {
        try
        {
            var date;

            if(arguments.length == 0)
            {
                if(globalObject.currentEventTime != null)
                {
                    date = new Date();
                }
                else
                {
                    date = new Date();
                }
            }
            else
            {
                date = new Date(arguments[0].jsValue)
            }

            return new fcModel.fcValue(date, new fcModel.Date(date, globalObject), callExpression);
        }
        catch(e) { fcModel.Date.notifyError("Date - error when creating Date object:" + e); }
    },

    executeInternalDateMethod : function(thisObject, functionObject, args, callExpression, callCommand)
    {
        try
        {
            if(!functionObject.isInternalFunction) { this.notifyError("The function should be internal when executing string method!"); return; }

            var functionObjectValue = functionObject.jsValue;
            var thisObjectValue = thisObject.jsValue;
            var functionName = functionObjectValue.name;
            var fcThisValue =  thisObject.iValue;
            var globalObject = fcThisValue != null ? fcThisValue.globalObject
                                                   : functionObjectValue.fcValue.iValue.globalObject;

            var argumentValues = globalObject.getJsValues(args);

            if(functionName.indexOf("set") == 0)
            {
                var result = thisObjectValue[functionName].apply(thisObjectValue, argumentValues);
            }
            else
            {
                var result = thisObjectValue[functionName]();
            }

            return globalObject.internalExecutor.createInternalPrimitiveObject(callExpression, result);
        }
        catch(e) {this.notifyError("Error when executing internal string method: " + e); }
    },
    notifyError: function(message) { fcModel.String.notifyError(message); }
};
/*************************************************************************************/
}});FBL.ns(function() { with (FBL) {
/*************************************************************************************/
var ValueTypeHelper = Firecrow.ValueTypeHelper;
var fcModel = Firecrow.Interpreter.Model;

fcModel.Boolean = function(value, globalObject, codeConstruct, isLiteral)
{
    this.initObject(globalObject, codeConstruct);

    this.value = value;
    this.isLiteral = !!isLiteral;

    this.addProperty("__proto__", this.globalObject.fcBooleanPrototype);
};

fcModel.Boolean.prototype = new fcModel.Object();
fcModel.Boolean.prototype.getJsPropertyValue = function(propertyName, codeConstruct)
{
    return this.getPropertyValue(propertyName, codeConstruct);
};
fcModel.Boolean.prototype.isPrimitive = function()
{
    return this.isLiteral;
};

fcModel.BooleanFunction = function(globalObject)
{
    this.initObject(globalObject);

    this.addProperty("prototype", globalObject.fcBooleanPrototype);
    this.proto = globalObject.fcFunctionPrototype;

    this.isInternalFunction = true;
    this.name = "Boolean";
};

fcModel.BooleanFunction.prototype = new fcModel.Object();

fcModel.BooleanPrototype = function(globalObject)
{
    this.initObject(globalObject);
    this.constructor = fcModel.BooleanPrototype;
    this.name = "BooleanPrototype";
};

fcModel.BooleanPrototype.prototype = new fcModel.Object();
/*************************************************************************************/
}});/**
 * Created by Jomaras.
 * Date: 23.03.12.@13:20
 */
FBL.ns(function() { with (FBL) {
/*************************************************************************************/
var ValueTypeHelper = Firecrow.ValueTypeHelper;
var fcModel = Firecrow.Interpreter.Model;

fcModel.Number = function(value, globalObject, codeConstruct, isLiteral)
{
    this.initObject(globalObject, codeConstruct);

    this.value = value;
    this.isLiteral = !!isLiteral;

    this.addProperty("__proto__", this.globalObject.fcNumberPrototype);
};

fcModel.Number.notifyError = function(message) { alert("Number - " + message); };
fcModel.Number.prototype = new fcModel.Object();
fcModel.Number.prototype.getJsPropertyValue = function(propertyName, codeConstruct)
{
    return this.getPropertyValue(propertyName, codeConstruct);
};

fcModel.NumberFunction = function(globalObject)
{
    this.initObject(globalObject, null, Number, globalObject.fcFunctionPrototype);
    this.constructor = fcModel.NumberPrototype;

    this.addProperty("prototype", globalObject.fcNumberPrototype);
    this.proto = globalObject.fcFunctionPrototype;

    this.isInternalFunction = true;
    this.name = "Number";

    this.addProperty("MIN_VALUE", this.globalObject.internalExecutor.createInternalPrimitiveObject(null, Number.MIN_VALUE), null);
    this.addProperty("MAX_VALUE", this.globalObject.internalExecutor.createInternalPrimitiveObject(null, Number.MAX_VALUE), null);

    this.addProperty("NEGATIVE_INFINITY", this.globalObject.internalExecutor.createInternalPrimitiveObject(null, Number.NEGATIVE_INFINITY), null);
    this.addProperty("POSITIVE_INFINITY", this.globalObject.internalExecutor.createInternalPrimitiveObject(null, Number.POSITIVE_INFINITY), null);

    this.addProperty("NaN", this.globalObject.internalExecutor.createInternalPrimitiveObject(null, Number.NaN), null);
};

fcModel.NumberFunction.prototype = new fcModel.Object();

fcModel.NumberPrototype = function(globalObject)
{
    this.initObject(globalObject, null, Number.prototype, globalObject.fcObjectPrototype);
    this.name = "NumberPrototype";
};

fcModel.NumberPrototype.prototype = new fcModel.Object();
/*************************************************************************************/
}});/**
 * Created by Jomaras.
 * Date: 16.03.12.@15:36
 */
FBL.ns(function() { with (FBL) {
/*************************************************************************************/
var ValueTypeHelper = Firecrow.ValueTypeHelper;
var fcModel = Firecrow.Interpreter.Model;

fcModel.String = function(value, globalObject, codeConstruct, isLiteral)
{
    this.initObject(globalObject, codeConstruct);

    this.value = value;
    this.isLiteral = !!isLiteral;

    this.addProperty("__proto__", this.globalObject.fcStringPrototype, codeConstruct, false);
    this.addProperty("length", this.globalObject.internalExecutor.createInternalPrimitiveObject(codeConstruct, value.length), codeConstruct, false);
};

fcModel.String.notifyError = function(message) { alert("String - " + message); };
fcModel.String.prototype = new fcModel.Object();
fcModel.String.prototype.getJsPropertyValue = function(propertyName, codeConstruct)
{
    return this.getPropertyValue(propertyName, codeConstruct);
};

fcModel.StringPrototype = function(globalObject)
{
    try
    {
        this.initObject(globalObject, null, String.prototype, globalObject.fcObjectPrototype);
        this.constructor = fcModel.StringPrototype;
        this.name = "StringPrototype";

        //https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array#Methods_2
        fcModel.StringPrototype.CONST.INTERNAL_PROPERTIES.METHODS.forEach(function(propertyName)
        {
            this.addProperty
            (
                propertyName,
                new fcModel.fcValue
                (
                    String.prototype[propertyName],
                    fcModel.Function.createInternalNamedFunction(globalObject, propertyName, this),
                    null
                ),
                null,
                false
            );
        }, this);
    }
    catch(e) { fcModel.String.notifyError("StringPrototype - error when creating array prototype:" + e); }
};

fcModel.StringPrototype.CONST =
{
    INTERNAL_PROPERTIES :
    {
        METHODS:
        [
            "charAt","charCodeAt", "fromCharCode" , "concat","indexOf","lastIndexOf","localeCompare",
            "match","replace","search","slice","split","substr","substring","toLocaleLowerCase",
            "toLocaleUpperCase","toLowerCase","toString","toUpperCase","trim","trimLeft","trimRight","valueOf"
        ]
    }
};

fcModel.StringPrototype.prototype = new fcModel.Object();

fcModel.StringFunction = function(globalObject)
{
    try
    {
        this.initObject(globalObject, null, String, globalObject.fcFunctionPrototype);

        this.addProperty("prototype", globalObject.fcStringPrototype);

        this.isInternalFunction = true;
        this.name = "String";

        fcModel.StringPrototype.CONST.INTERNAL_PROPERTIES.METHODS.forEach(function(propertyName)
        {
            this.addProperty
            (
                propertyName,
                new fcModel.fcValue
                (
                    FBL.Firecrow.INTERNAL_PROTOTYPE_FUNCTIONS.String[propertyName],
                    fcModel.Function.createInternalNamedFunction(globalObject, propertyName, this),
                    null
                ),
                null,
                false
            );
        }, this);
    }
    catch(e){ fcModel.String.notifyError("String - error when creating String Function:" + e); }
};

fcModel.StringFunction.prototype = new fcModel.Object();

fcModel.StringExecutor =
{
    evaluateCallbackReturn: function(callbackCommand, returnValue, returnExpression, globalObject)
    {
        try
        {
            var originatingObject = callbackCommand.originatingObject;

            if(!ValueTypeHelper.isString(originatingObject.jsValue)) { this.notifyError("When evaluating callback return the argument has to be a string!"); return; }

            var callbackFunctionValue = callbackCommand.callerFunction.jsValue;
            var targetObject = callbackCommand.targetObject;
            var targetObjectValue = targetObject.jsValue;
            var callbackArguments = callbackCommand.arguments;

            if(callbackFunctionValue.name == "replace")
            {
                callbackCommand.parentInitCallbackCommand.intermediateResults.push(returnValue);

                if(callbackCommand.isLastCallbackCommand)
                {
                    var index = 0;
                    var resultMapping = callbackCommand.parentInitCallbackCommand.intermediateResults;

                    targetObject.jsValue = targetObjectValue.replace(targetObject.replacedValue, function()
                    {
                        return resultMapping[index++].jsValue;
                    });

                    targetObject.iValue = new fcModel.String(targetObject.jsValue, globalObject, returnExpression, true);
                }

                globalObject.dependencyCreator.createDataDependency
                (
                    targetObject.codeConstruct,
                    returnExpression.argument,
                    globalObject.getPreciseEvaluationPositionId()
                );

                targetObject.codeConstruct = returnExpression;
            }
            else
            {
                this.notifyError("Unknown string callback function!");
            }
        }
        catch(e) { this.notifyError("Error when evaluating callback return " + e); }
    },

    executeInternalStringMethod : function(thisObject, functionObject, args, callExpression, callCommand)
    {
        try
        {
            if(!functionObject.isInternalFunction) { this.notifyError("The function should be internal when executing string method!"); return; }

            var functionObjectValue = functionObject.jsValue;
            var thisObjectValue = thisObject.jsValue;
            var functionName = functionObjectValue.name;
            var fcThisValue =  thisObject.iValue;
            var globalObject = fcThisValue != null ? fcThisValue.globalObject
                                                   : functionObjectValue.fcValue.iValue.globalObject;

            if(ValueTypeHelper.isNumber(thisObjectValue) || ValueTypeHelper.isBoolean(thisObjectValue))
            {
                thisObjectValue = thisObjectValue.toString();
            }

            var argumentValues = globalObject.getJsValues(args);

            if(functionName == "toString" && ValueTypeHelper.isFunction(thisObject.jsValue)) //toString called on a function
            {
                return globalObject.internalExecutor.createInternalPrimitiveObject(callExpression, Firecrow.CodeTextGenerator.generateJsCode(thisObject.codeConstruct));
            }

            switch(functionName)
            {
                case "charAt":
                case "charCodeAt":
                case "concat":
                case "indexOf":
                case "lastIndexOf":
                case "localeCompare":
                case "substr":
                case "substring":
                case "toLocaleLowerCase":
                case "toLocaleUpperCase":
                case "toLowerCase":
                case "toString":
                case "toUpperCase":
                case "trim":
                case "trimLeft":
                case "trimRight":
                case "valueOf":
                case "search":
                case "slice":
                    var returnValue = thisObjectValue[functionName].apply(thisObjectValue, argumentValues);

                    var codeConstruct = callExpression;

                    if(codeConstruct == null) { codeConstruct = args[0].codeConstruct; }

                    return globalObject.internalExecutor.createInternalPrimitiveObject(codeConstruct, returnValue);
                case "match":
                case "split":
                    var result = thisObjectValue[functionName].apply(thisObjectValue, argumentValues);
                    if(result == null)
                    {
                        return new fcModel.fcValue(null, null, callExpression);
                    }
                    else if (ValueTypeHelper.isArray(result))
                    {
                        var internalPrimitives = [];

                        for(var i = 0; i < result.length; i++)
                        {
                            internalPrimitives.push(globalObject.internalExecutor.createInternalPrimitiveObject(callExpression, result[i]));
                        }

                        var array = fcThisValue.globalObject.internalExecutor.createArray(callExpression, internalPrimitives);

                        if(functionName == "match")
                        {
                            array.iValue.addJsProperty("index", fcThisValue.globalObject.internalExecutor.createInternalPrimitiveObject(callExpression, result.index), callExpression);
                        }

                        return array;
                    }
                    else { this.notifyError("Unknown result type when executing string match or split!"); return null;}
                case "replace":
                    if(ValueTypeHelper.isString(argumentValues[1]) || ValueTypeHelper.isNumber(argumentValues[1]) || argumentValues[1] == String)
                    {
                        var returnValue = thisObjectValue[functionName].apply(thisObjectValue, argumentValues);
                        return globalObject.internalExecutor.createInternalPrimitiveObject(callExpression, returnValue);
                    }
                    else if(ValueTypeHelper.isFunction(argumentValues[1]))
                    {
                        var allCallbackArguments = [];
                        var callbackFunction = args[1];

                        var params = callbackFunction.codeConstruct.params;

                        thisObjectValue.replace(argumentValues[0], function()
                        {
                            var currentArgs = [];

                            for(var i = 0; i < arguments.length; i++)
                            {
                                currentArgs.push(globalObject.internalExecutor.createInternalPrimitiveObject(params[i], arguments[i]));
                            }

                            allCallbackArguments.push(currentArgs);
                        });

                        callCommand.generatesNewCommands = true;
                        callCommand.generatesCallbacks = true;
                        callCommand.setCallbackFunction(callbackFunction);
                        callCommand.callbackArgumentGroups = allCallbackArguments;
                        callCommand.thisObject = globalObject;
                        callCommand.originatingObject = thisObject;
                        callCommand.callerFunction = functionObject;
                        callCommand.targetObject = globalObject.internalExecutor.createInternalPrimitiveObject(callExpression, thisObjectValue);
                        callCommand.targetObject.replacedValue = argumentValues[0];

                        return callCommand.targetObject;
                    }
                    else
                    {
                        this.notifyError("Unknown replacement type in string, can be either a function or a string");
                    }
                    return null;
                default:
                    this.notifyError("Unknown method on string");
            }
        }
        catch(e) {this.notifyError("Error when executing internal string method: " + e + functionName + callExpression.loc.start.line); }
    },

    executeInternalStringFunctionMethod: function(thisObject, functionObject, args, callExpression, callCommand)
    {
        var functionObjectValue = functionObject.jsValue;
        var functionName = (functionObjectValue || functionObject.iValue).name;

        if(functionName == "fromCharCode")
        {
            var fcThisValue =  thisObject.iValue;
            var globalObject = fcThisValue != null ? fcThisValue.globalObject
                                                    : functionObjectValue.fcValue.iValue.globalObject;

            var argumentValues = globalObject.getJsValues(args);

            return globalObject.internalExecutor.createInternalPrimitiveObject(callExpression, String.fromCharCode.apply(String, argumentValues));
        }
        else
        {
            return this.executeInternalStringMethod(args[0], functionObject, args.slice(1, args.length), callExpression, callCommand);
        }
    },

    isInternalStringFunctionMethod: function(functionObject)
    {
        return fcModel.StringPrototype.CONST.INTERNAL_PROPERTIES.METHODS.indexOf(functionObject.name) != -1;
    },

    notifyError: function(message) { debugger; fcModel.String.notifyError(message); }
};
/*************************************************************************************/
}});FBL.ns(function() { with (FBL) {
/*************************************************************************************/
var fcModel = Firecrow.Interpreter.Model;
fcModel.ImageFunction = function(globalObject, codeConstruct)
{
    try
    {
        this.initObject(globalObject);
        this.addProperty("src", this.globalObject.internalExecutor.createInternalPrimitiveObject(codeConstruct, ""));

        this.isInternalFunction = true;
        this.name = "Image";
    }
    catch(e){ fcModel.GlobalObject.notifyError("Error when creating image function: " + e); }
};

fcModel.ImageFunction.prototype = new fcModel.Object();
/*************************************************************************************/
}});FBL.ns(function() { with (FBL) {
/*************************************************************************************/
var fcModel = Firecrow.Interpreter.Model;

fcModel.Element = function(globalObject)
{
    try
    {
        this.initObject(globalObject);

        this.addProperty("prototype", globalObject.fcElementPrototype);

        this.name = "Element";
    }
    catch(e){ fcModel.HTMLImageElement.notifyError("Error when creating Element Function:" + e); }
};

fcModel.Element.prototype = new fcModel.Object();
fcModel.Element.notifyError = function(message) { alert("Element - " + message);};

fcModel.ElementPrototype = function(globalObject)
{
    this.initObject(globalObject);
    this.constructor = fcModel.ElementPrototype;
    this.name = "ElementPrototype";
};

fcModel.ElementPrototype.prototype = new fcModel.Object();
/*************************************************************************************/
}});FBL.ns(function() { with (FBL) {
/*************************************************************************************/
var fcModel = Firecrow.Interpreter.Model;

fcModel.HTMLElement = function(globalObject)
{
    try
    {
        this.initObject(globalObject);

        this.addProperty("prototype", globalObject.fcHtmlElementPrototype);

        this.name = "HTMLElement";
    }
    catch(e){ fcModel.HTMLImageElement.notifyError("Error when creating Array Function:" + e); }
};

fcModel.HTMLElement.prototype = new fcModel.Object();
fcModel.HTMLElement.notifyError = function(message) { alert("HTMLElement - " + message);};

fcModel.HTMLElementPrototype = function(globalObject)
{
    this.initObject(globalObject);
    this.addProperty("__proto__", globalObject.fcElementPrototype);
    this.constructor = fcModel.HTMLElementPrototype;
    this.name = "HTMLElementPrototype";
};

fcModel.HTMLElementPrototype.prototype = new fcModel.Object();
/*************************************************************************************/
}});FBL.ns(function() { with (FBL) {
/*************************************************************************************/
var fcModel = Firecrow.Interpreter.Model;

fcModel.HTMLImageElement = function(globalObject)
{
    try
    {
        this.initObject(globalObject);

        this.addProperty("prototype", globalObject.fcHtmlImagePrototype);

        this.name = "HTMLImageElement";
    }
    catch(e){ fcModel.HTMLImageElement.notifyError("Error when creating HTMLImageElement Function:" + e); }
};

fcModel.HTMLImageElement.prototype = new fcModel.Object();
fcModel.HTMLImageElement.notifyError = function(message) { alert("HTMLImageElement - " + message);};

fcModel.HTMLImageElementPrototype = function(globalObject)
{
    this.initObject(globalObject);
    this.constructor = fcModel.HTMLImageElementPrototype;
    this.name = "HTMLImageElementPrototype";
};

fcModel.HTMLImageElementPrototype.prototype = new fcModel.Object();
/*************************************************************************************/
}});FBL.ns(function() { with (FBL) {
/*************************************************************************************/
//https://developer.mozilla.org/en-US/docs/DOM/CanvasRenderingContext2D
var fcModel = Firecrow.Interpreter.Model;

fcModel.CanvasPrototype = function(globalObject)
{
    this.initObject(globalObject);
    this.constructor = fcModel.CanvasPrototype;
    this.name = "CanvasPrototype";

    ["getContext", "toDataURL", "toBlob"].forEach(function(propertyName)
    {
        this.addProperty
        (
            propertyName,
            new fcModel.fcValue
            (
                HTMLCanvasElement.prototype[propertyName],
                fcModel.Function.createInternalNamedFunction(globalObject, propertyName, this),
                null,
                null
            ),
            null,
            false
        );
    }, this);
};

fcModel.CanvasPrototype.prototype = new fcModel.Object();

fcModel.CanvasContext = function(globalObject, canvasContext, canvas)
{
    this.initObject(globalObject);
    this.addProperty("__proto__", this.globalObject.fcCanvasContextPrototype);
    this.constructor = fcModel.CanvasContext;

    this.canvasContext = canvasContext;
    this.canvas = canvas;
};

fcModel.CanvasContext.prototype = new fcModel.Object();

fcModel.CanvasContext.prototype.addJsProperty = function(propertyName, propertyValue, assignmentExpression)
{
    this.addProperty(propertyName, propertyValue, assignmentExpression);
    this.canvasContext[propertyName] = propertyValue.jsValue;

    this.canvas.elementModificationPoints.push({ codeConstruct: assignmentExpression, evaluationPositionId: this.globalObject.getPreciseEvaluationPositionId()});
    fcModel.HtmlElementExecutor.addDependencyIfImportantElement(this.canvas, this.globalObject, assignmentExpression);
};

fcModel.CanvasContextPrototype = function(globalObject)
{
    this.initObject(globalObject);

    this.addProperty("__proto__", this.globalObject.fcObjectPrototype);
    this.name = "CanvasContextPrototype";

    fcModel.CanvasContext.CONST.METHODS.forEach(function(propertyName)
    {
        this.addProperty
        (
            propertyName,
            new fcModel.fcValue
            (
                CanvasRenderingContext2D.prototype[propertyName],
                fcModel.Function.createInternalNamedFunction(globalObject, propertyName, this),
                null
            ),
            null,
            false
        );
    }, this);
};

fcModel.CanvasContextPrototype.prototype = new fcModel.Object();

fcModel.CanvasContext.CONST =
{
    METHODS:
    [
        "arc", "arcTo", "beginPath", "bezierCurveTo", "clearRect", "clip", "closePath", "createImageDate", "createLinearGradient",
        "createPattern", "createRadialGradient", "drawImage", "drawCustomFocusRing", "fill", "fillRect", "fillText", "getImageData",
        "getLineDash", "isPointInPath", "lineTo", "measureText", "moveTo", "putImageData", "quadraticCurveTo", "rect", "restore",
        "rotate", "save", "scale", "scrollPathIntoView", "setLineDash", "setTransform", "stroke", "strokeRect", "strokeText",
        "transform", "translate"
    ]
}

fcModel.CanvasExecutor =
{
    executeCanvasMethod: function(thisObject, functionObject, args, callExpression)
    {
        var functionObjectValue = functionObject.jsValue;
        var thisObjectValue = thisObject.jsValue;
        var functionName = functionObjectValue != null ? functionObjectValue.name : functionObject.iValue.name;
        var fcThisValue =  thisObject.iValue;
        var globalObject = fcThisValue.globalObject;
        var jsArguments =  globalObject.getJsValues(args)

        if(functionName == "getContext")
        {
            var jsCanvasContext = thisObjectValue.getContext.apply(thisObjectValue, jsArguments);

            return new fcModel.fcValue(jsCanvasContext, new fcModel.CanvasContext(globalObject, jsCanvasContext, thisObjectValue), callExpression);
        }
    }
};

fcModel.CanvasContextExecutor =
{
    executeInternalMethod: function(thisObject, functionObject, args, callExpression)
    {
        var functionObjectValue = functionObject.jsValue;
        var thisObjectValue = thisObject.jsValue;
        var functionName = functionObjectValue.name;
        var fcThisValue =  thisObject.iValue;
        var globalObject = fcThisValue.globalObject;
        var jsArguments = globalObject.getJsValues(args);

        try
        {
            var result = thisObjectValue[functionName].apply(thisObjectValue, jsArguments);
        }
        catch(e)
        {
            //TODO - drawImage fails if the image is not loaded - and since where the model is executed
            //and where the image points to is not in the same location - the image can not be loaded
            //and draw image returns an exception!
            //console.log(e);
        }

        if(functionName == "createLinearGradient")
        {
            return new fcModel.fcValue(result, new fcModel.LinearGradient(globalObject, thisObjectValue, thisObject.iValue.canvas, result), callExpression, null);
        }
        else if (functionName == "createRadialGradient")
        {
            return new fcModel.fcValue(result, new fcModel.CanvasGradient(globalObject, thisObjectValue, thisObject.iValue.canvas, result), callExpression, null);
        }
        else if (functionName == "getImageData")
        {
            return new fcModel.fcValue(result, new fcModel.ImageData(globalObject, thisObjectValue, thisObject.iValue.canvas, result), callExpression, null);
        }
        else
        {
            thisObject.iValue.canvas.elementModificationPoints.push({ codeConstruct: callExpression, evaluationPositionId: globalObject.getPreciseEvaluationPositionId()});
            fcModel.HtmlElementExecutor.addDependencyIfImportantElement(thisObject.iValue.canvas, globalObject, callExpression);

            return globalObject.internalExecutor.createInternalPrimitiveObject(callExpression);
        }
    }
};

fcModel.LinearGradient = function(globalObject, canvasContext, canvas, linearGradient)
{
    this.initObject(globalObject);
    this.constructor = fcModel.LinearGradient;

    this.canvasContext = canvasContext;
    this.canvas = canvas;
    this.linearGradient = linearGradient;

    this.addProperty
    (
        "addColorStop", new fcModel.fcValue(this.linearGradient.addColorStop, fcModel.Function.createInternalNamedFunction(globalObject, "addColorStop", this), null),
        null,
        false
    );
};

fcModel.LinearGradient.prototype = new fcModel.Object();

fcModel.LinearGradient.prototype.addJsProperty = function(propertyName, propertyValue, assignmentExpression)
{
    this.addProperty(propertyName, propertyValue, assignmentExpression);
    this.linearGradient[propertyName] = propertyValue.jsValue;

    this.canvas.elementModificationPoints.push({ codeConstruct: assignmentExpression, evaluationPositionId: this.globalObject.getPreciseEvaluationPositionId()});
    fcModel.HtmlElementExecutor.addDependencyIfImportantElement(this.canvas, this.globalObject, assignmentExpression);
};

fcModel.LinearGradientExecutor =
{
    executeInternalMethod: function(thisObject, functionObject, args, callExpression)
    {
        var functionObjectValue = functionObject.jsValue;
        var thisObjectValue = thisObject.jsValue;
        var functionName = functionObjectValue.name;
        var fcThisValue =  thisObject.iValue;
        var globalObject = fcThisValue.globalObject;
        var jsArguments =  globalObject.getJsValues(args);

        thisObjectValue[functionName].apply(thisObjectValue, jsArguments);

        thisObject.iValue.canvas.elementModificationPoints.push({ codeConstruct: callExpression, evaluationPositionId: globalObject.getPreciseEvaluationPositionId()});
        fcModel.HtmlElementExecutor.addDependencyIfImportantElement(thisObject.iValue.canvas, globalObject, callExpression);

        return globalObject.internalExecutor.createInternalPrimitiveObject(callExpression);
    }
};

fcModel.CanvasGradient = function(globalObject, canvasContext, canvas, canvasGradient)
{
    this.initObject(globalObject);
    this.constructor = fcModel.CanvasGradient;

    this.canvasContext = canvasContext;
    this.canvas = canvas;
    this.canvasGradient = canvasGradient;

    this.addProperty
    (
        "addColorStop", new fcModel.fcValue(this.canvasGradient.addColorStop, fcModel.Function.createInternalNamedFunction(globalObject, "addColorStop", this), null),
        null,
        false
    );
};

fcModel.CanvasGradient.prototype = new fcModel.Object();

fcModel.CanvasGradient.prototype.addJsProperty = function(propertyName, propertyValue, assignmentExpression)
{
    this.addProperty(propertyName, propertyValue, assignmentExpression);
    this.canvasGradient[propertyName] = propertyValue.jsValue;

    this.canvas.elementModificationPoints.push({ codeConstruct: assignmentExpression, evaluationPositionId: this.globalObject.getPreciseEvaluationPositionId()});
    fcModel.HtmlElementExecutor.addDependencyIfImportantElement(this.canvas, this.globalObject, assignmentExpression);
};

fcModel.CanvasGradientExecutor =
{
    executeInternalMethod: function(thisObject, functionObject, args, callExpression)
    {
        var functionObjectValue = functionObject.jsValue;
        var thisObjectValue = thisObject.jsValue;
        var functionName = functionObjectValue.name;
        var fcThisValue =  thisObject.iValue;
        var globalObject = fcThisValue.globalObject;
        var jsArguments =  globalObject.getJsValues(args);

        thisObjectValue[functionName].apply(thisObjectValue, jsArguments);

        thisObject.iValue.canvas.elementModificationPoints.push({ codeConstruct: callExpression, evaluationPositionId: globalObject.getPreciseEvaluationPositionId()});
        fcModel.HtmlElementExecutor.addDependencyIfImportantElement(thisObject.iValue.canvas, globalObject, callExpression);

        return globalObject.internalExecutor.createInternalPrimitiveObject(callExpression);
    }
};

fcModel.ImageData = function(globalObject, canvasContext, canvas, imageData)
{
    this.initObject(globalObject);
    this.constructor = fcModel.ImageData;

    this.canvasContext = canvasContext;
    this.canvas = canvas;
    this.imageData = imageData;

    this.addProperty("data")

    this.addProperty
    (
        "addColorStop", new fcModel.fcValue(this.canvasGradient.addColorStop, fcModel.Function.createInternalNamedFunction(globalObject, "addColorStop", this), null),
        null,
        false
    );
};

fcModel.CanvasGradient.prototype = new fcModel.Object();

fcModel.CanvasGradient.prototype.addJsProperty = function(propertyName, propertyValue, assignmentExpression)
{
    this.addProperty(propertyName, propertyValue, assignmentExpression);
    this.canvasGradient[propertyName] = propertyValue.jsValue;

    this.canvas.elementModificationPoints.push({ codeConstruct: assignmentExpression, evaluationPositionId: this.globalObject.getPreciseEvaluationPositionId()});
    fcModel.HtmlElementExecutor.addDependencyIfImportantElement(this.canvas, this.globalObject, assignmentExpression);
};

/*************************************************************************************/
}});FBL.ns(function() { with (FBL) {
/*************************************************************************************/
var ValueTypeHelper = Firecrow.ValueTypeHelper;
var fcModel = Firecrow.Interpreter.Model;

fcModel.Error = function(implementationObject, globalObject, codeConstruct)
{
    try
    {
        this.initObject(globalObject, codeConstruct, implementationObject, globalObject.fcErrorPrototype);
        this.constructor = fcModel.Error;

        this.addProperty("message", this.globalObject.internalExecutor.createInternalPrimitiveObject(codeConstruct, implementationObject.message), codeConstruct, false);
        this.addProperty("name", this.globalObject.internalExecutor.createInternalPrimitiveObject(codeConstruct, implementationObject.name), codeConstruct, false);
        this.addProperty("description", this.globalObject.internalExecutor.createInternalPrimitiveObject(codeConstruct, implementationObject.description), codeConstruct, false);
        this.addProperty("number", this.globalObject.internalExecutor.createInternalPrimitiveObject(codeConstruct, implementationObject.number), codeConstruct, false);
        this.addProperty("fileName", this.globalObject.internalExecutor.createInternalPrimitiveObject(codeConstruct, implementationObject.fileName), codeConstruct, false);
        this.addProperty("lineNumber", this.globalObject.internalExecutor.createInternalPrimitiveObject(codeConstruct, implementationObject.lineNumber), codeConstruct, false);
        this.addProperty("stack", this.globalObject.internalExecutor.createInternalPrimitiveObject(codeConstruct, implementationObject.stack), codeConstruct, false);
    }
    catch(e) { fcModel.Error.notifyError("Error when creating an Error object: " + e); }
};

fcModel.Error.notifyError = function(message) { alert("Error - " + message); };
fcModel.Error.prototype = new fcModel.Object();

fcModel.ErrorPrototype = function(globalObject)
{
    try
    {
        this.initObject(globalObject);
        this.name = "ErrorPrototype";
        this.constructor = fcModel.ErrorPrototype;
    }
    catch(e) { fcModel.Error.notifyError("ErrorPrototype - error when creating error prototype:" + e); }
};

fcModel.ErrorPrototype.CONST =
{
    INTERNAL_PROPERTIES :
    {
        METHODS:[]
    },
    FUNCTION_PROPERTIES:
    {
        METHODS:  []
    }
};

fcModel.ErrorPrototype.prototype = new fcModel.Object(null);

fcModel.ErrorFunction = function(globalObject)
{
    try
    {
        this.initObject(globalObject);

        this.addProperty("prototype", globalObject.fcErrorPrototype);

        this.isInternalFunction = true;
        this.name = "Error";
    }
    catch(e){ fcModel.Error.notifyError("Error - error when creating Error Function:" + e); }
};

fcModel.ErrorFunction.prototype = new fcModel.Object(null);
/*************************************************************************************/
}});FBL.ns(function() { with (FBL) {
/*************************************************************************************/
var fcModel = Firecrow.Interpreter.Model;
var ValueTypeHelper = Firecrow.ValueTypeHelper;

fcModel.Document = function(document, globalObject)
{
    try
    {
        this.initObject(globalObject);
        ValueTypeHelper.expand(this, fcModel.EventListenerMixin);

        this.document = document;
        this.htmlElement = document;
        this.implementationObject = document;

        this.constructor = fcModel.Document;

        this.htmlElementToFcMapping = { };

        this._createDefaultProperties();
    }
    catch(e) { fcModel.Document.notifyError("Error when creating Document object: " + e); }
};
fcModel.Document.notifyError = function(message) { alert("Document: " + message);}


fcModel.Document.prototype = new fcModel.Object();

//<editor-fold desc="Access Js Properties">
fcModel.Document.prototype.addJsProperty = function(propertyName, value, codeConstruct)
{
    this.addProperty(propertyName, value, codeConstruct);

    if(fcModel.DOM_PROPERTIES.isElementEventProperty(propertyName))
    {
        this.globalObject.registerHtmlElementEventHandler
        (
            this.globalObject.document, propertyName, value,
            {
                codeConstruct: codeConstruct,
                evaluationPositionId: this.globalObject.getPreciseEvaluationPositionId()
            }
        );
    }
};

fcModel.Document.prototype.getJsPropertyValue = function(propertyName, codeConstruct)
{
    var hasBeenHandled = false;

    if (fcModel.DOM_PROPERTIES.isDocumentElement(propertyName) || fcModel.DOM_PROPERTIES.isNodeElement(propertyName))
    {
        this.addProperty(propertyName, fcModel.HtmlElementExecutor.wrapToFcElement(this.document[propertyName], this.globalObject, codeConstruct));
        hasBeenHandled = true;
    }
    else if (fcModel.DOM_PROPERTIES.isDocumentElements(propertyName) || fcModel.DOM_PROPERTIES.isNodeElements(propertyName))
    {
        var elements = this._getElements(propertyName, codeConstruct);

        var array = this.globalObject.internalExecutor.createArray(codeConstruct, elements);
        array.iValue.markAsNodeList();

        this.addProperty(propertyName, array);

        hasBeenHandled = true;
    }
    else if(fcModel.DOM_PROPERTIES.isDocumentPrimitives(propertyName) || fcModel.DOM_PROPERTIES.isNodePrimitives(propertyName))
    {
        this.addProperty(propertyName, this.getPropertyValue(propertyName, codeConstruct));
        hasBeenHandled = true;
    }
    else if(fcModel.DOM_PROPERTIES.isDocumentOther(propertyName) || fcModel.DOM_PROPERTIES.isNodeOther(propertyName))
    {
        if(propertyName == "defaultView") { return this.globalObject; }

        if (propertyName == "readyState" || propertyName == "location")
        {
            this.addProperty(propertyName, this.getPropertyValue(propertyName, codeConstruct));
            hasBeenHandled = true;
        }
        else if (propertyName == "ownerDocument" || propertyName == "attributes")
        {

        }
    }

    if(!this._isMethodName(propertyName) && !hasBeenHandled)
    {
        fcModel.DOM_PROPERTIES.DOCUMENT.UNPREDICTED[propertyName] = propertyName;
    }

    return this.getPropertyValue(propertyName, codeConstruct);
};
//</editor-fold>

//<editor-fold desc="Fetch elements">
fcModel.Document.prototype.getElementByXPath = function(xPath)
{
    if(xPath == null || xPath == "") { return new fcModel.fcValue(null, null, null);}

    var simpleXPath = (new fcModel.SimpleXPath(xPath)).removeLevel();
    var foundElement = this._getHtmlElement();

    while(!simpleXPath.isEmpty() && foundElement != null)
    {
        foundElement = this._getChild(foundElement, simpleXPath.getCurrentTag(), simpleXPath.getIndex());
        simpleXPath.removeLevel();
    }

    return fcModel.HtmlElementExecutor.wrapToFcElement(foundElement, this.globalObject, null);
};

fcModel.Document.prototype.getCookie = function()
{
    var cookieValue = this.getPropertyValue("cookie");

    return cookieValue != null ? cookieValue.jsValue : "";
};

fcModel.Document.prototype.setCookie = function(cookie)
{
    this.addProperty("cookie", this.globalObject.internalExecutor.createInternalPrimitiveObject(null, cookie));
}

fcModel.Document.prototype._getHtmlElement = function()
{
    for(var i = 0; i < this.document.childNodes.length; i++)
    {
        var child = this.document.childNodes[i];

        if(child.tagName != null && child.tagName.toLowerCase() == "html")
        {
            return child;
        }
    }

    return null;
};
//</editor-fold>

//<editor-fold desc="'Private' methods">
fcModel.Document.prototype._createDefaultProperties = function()
{
    fcModel.DOM_PROPERTIES.DOCUMENT.METHODS.forEach(function(method)
    {
        this.addProperty(method, this.globalObject.internalExecutor.createInternalFunction(this.document[method], method, this, true));
    }, this);

    fcModel.DOM_PROPERTIES.setPrimitives(this, this.document, fcModel.DOM_PROPERTIES.DOCUMENT.PRIMITIVES);
    fcModel.DOM_PROPERTIES.setPrimitives(this, this.document, fcModel.DOM_PROPERTIES.NODE.PRIMITIVES);

    this.addProperty("readyState", this.globalObject.internalExecutor.createInternalPrimitiveObject(null, "loading"));
    this.addProperty("location", this.globalObject.internalExecutor.createLocationObject());
};

fcModel.Document.prototype._getElements = function(propertyName, codeConstruct)
{
    var array = [];
    var items = this.document[propertyName];

    if(items == null) { return array; }

    for(var i = 0, length = items.length; i < length; i++)
    {
        if(items[i].nodeType == 10) { continue; } //skip doctype
        array.push(fcModel.HtmlElementExecutor.wrapToFcElement(items[i], this.globalObject, codeConstruct));
    }

    return array;
};

fcModel.Document.prototype._getChild = function(htmlElement, tagName, index)
{
    if(htmlElement == null || htmlElement.children == null) { return null;}

    var tagChildren = [];

    for(var i = 0; i < htmlElement.children.length; i++)
    {
        var child = htmlElement.children[i];

        if(child.nodeName.toUpperCase() == tagName.toUpperCase())
        {
            tagChildren.push(child);
        }
    }

    return tagChildren[index];
};

fcModel.Document.prototype._isMethodName = function(name)
{
    return fcModel.DOM_PROPERTIES.DOCUMENT.METHODS.indexOf(name) != -1;
};
//</editor-fold>

fcModel.DocumentFunction = function(globalObject)
{
    try
    {
        this.initObject(globalObject);
        this.name = "Document";

        this.addProperty("prototype", globalObject.fcDocumentPrototype);
        this.proto = globalObject.fcFunctionPrototype;
    }
    catch(e){ fcModel.Document.notifyError("Error when creating Document Function:" + e); }
};

fcModel.DocumentFunction.prototype = new fcModel.Object();

fcModel.DocumentPrototype = function(globalObject)
{
    this.initObject(globalObject);
    this.constructor = fcModel.DocumentPrototype;
};

fcModel.DocumentPrototype.prototype = new fcModel.Object();
/**************************************************************************************/
}});FBL.ns(function() { with (FBL) {
/*************************************************************************************/
var fcModel = Firecrow.Interpreter.Model;

fcModel.DocumentExecutor =
{
    executeInternalMethod: function(thisObject, functionObject, args, callExpression)
    {
        if(!functionObject.isInternalFunction) { this.notifyError("The function should be internal when executing document method!"); return; }

        var functionObjectValue = functionObject.jsValue;
        var thisObjectValue = thisObject.jsValue;
        var functionName = functionObjectValue.name;
        var fcThisValue =  thisObject.iValue;
        var globalObject = fcThisValue.globalObject;

             if (functionName == "createElement") { return globalObject.internalExecutor.createHtmlElement(callExpression, args[0].jsValue); }
        else if (functionName == "createTextNode") { return globalObject.internalExecutor.createTextNode(callExpression, args[0].jsValue);}
        else if (functionName == "addEventListener") { return globalObject.document.addEventListener(args, callExpression, globalObject); }
        else if (functionName == "removeEventListener") { return globalObject.document.removeEventListener(args, callExpression, globalObject); }
        else if (functionName == "createDocumentFragment") { return globalObject.internalExecutor.createDocumentFragment(callExpression, globalObject); }
        else if (functionName == "createComment")
        {
            var fcComment = fcModel.Object.createObjectWithInit(globalObject, callExpression, {});
            fcComment.addProperty("nodeType", globalObject.internalExecutor.createInternalPrimitiveObject(callExpression, 8));
            fcComment.isComment = true;

            return new fcModel.fcValue(globalObject.origDocument.createComment(""), fcComment, callExpression);
        }
        else if (functionName == "getElementsByTagName" || functionName == "querySelectorAll" || functionName == "getElementsByClassName" || functionName == "getElementsByName") { return this.getElements(globalObject, functionName, args[0].jsValue, callExpression, functionName);}
        else if (functionName == "getElementById" || functionName == "querySelector") { return this.getElement(globalObject, functionName, args[0].jsValue, callExpression); }
        else if (functionName == "createAttribute") { return fcModel.Attr.wrapAttribute(globalObject.origDocument.createAttribute(args[0].jsValue), globalObject, callExpression); }
        else if (functionName == "open" || functionName == "close") { return null;}
        else if (functionName == "write" || functionName == "execCommand") { return null; }

        this.notifyError("Unhandled document method: " +  functionName);

        return null;
    },

    getElements: function(globalObject, queryType, selector, callExpression)
    {
        globalObject.browser.logDomQueried(queryType, selector, callExpression);

        var elements = [];
        try
        {
            elements = globalObject.origDocument[queryType](selector);
        }
        catch(e)
        {
            globalObject.executionContextStack.callExceptionCallbacks
            ({
                exceptionGeneratingConstruct: callExpression,
                isDomStringException: true
            });
        }

        for(var i = 0, length = elements.length; i < length; i++)
        {
            fcModel.HtmlElementExecutor.addDependencies(elements[i], callExpression, globalObject);
        }

        var wrappedArray = fcModel.HtmlElementExecutor.wrapToFcElements(elements, globalObject, callExpression);
        wrappedArray.iValue.markAsNodeList();

        return wrappedArray;
    },

    getElement: function(globalObject, queryType, selector, callExpression)
    {
        globalObject.browser.logDomQueried(queryType, selector, callExpression);

        var element = null;
        try
        {
            element = globalObject.origDocument[queryType](selector);
        }
        catch(e)
        {
            globalObject.executionContextStack.callExceptionCallbacks
            ({
                exceptionGeneratingConstruct: callExpression,
                isDomStringException: true
            });
        }

        if(element == null) { return new fcModel.fcValue(null, null, callExpression); }

        fcModel.HtmlElementExecutor.addDependencies(element, callExpression, globalObject);

        return fcModel.HtmlElementExecutor.wrapToFcElement(element, globalObject, callExpression);
    },

    notifyError: function(message) { debugger; alert("DocumentExecutor - " + message);}
};
/**************************************************************************************/
}});FBL.ns(function() { with (FBL) {
/*************************************************************************************/
var fcModel = Firecrow.Interpreter.Model;
var ValueTypeHelper = Firecrow.ValueTypeHelper;
var CommandGenerator = Firecrow.Interpreter.Commands.CommandGenerator;

fcModel.HtmlElement = function fcModelHtmlElement(htmlElement, globalObject, codeConstruct)
{
    try
    {
        this.initObject(globalObject, codeConstruct, htmlElement);
        ValueTypeHelper.expand(this, fcModel.EventListenerMixin);

        this.constructor = fcModel.HtmlElement;

        this.registerGetPropertyCallback(this._getPropertyHandler, this);

        this.htmlElement = htmlElement;
        this.implementationObject = this.htmlElement;

        if(this.htmlElement != null)
        {
            this.htmlElement.fcHtmlElementId = this.id;
            this.globalObject.document.htmlElementToFcMapping[this.id] = this;

            this._expandWithDefaultProperties();

            if(this.htmlElement.modelElement == null && this.htmlElement.tagName != "BODY")
            {
                //debugger;
            }
        }
    }
    catch(e) { fcModel.HtmlElement.notifyError("Error when creating HTML node: " + e); }
};

//<editor-fold desc="'Static' Methods">
fcModel.HtmlElement.accessedProperties = {};
fcModel.HtmlElement.dynamicConstructId = 0;
fcModel.HtmlElement.notifyError = function(message) { debugger; alert("HtmlElement - " + message); }
//</editor-fold>

//<editor-fold desc="Prototype Definition">
fcModel.HtmlElement.prototype = new fcModel.Object();

//<editor-fold desc="JsProperty Accessors">
fcModel.HtmlElement.prototype.getJsPropertyValue = function(propertyName, codeConstruct)
{
    fcModel.HtmlElement.accessedProperties[propertyName] = true;

    var creationConstruct = this.htmlElement != null && this.htmlElement.modelElement != null ? this.htmlElement.modelElement : this.creationCodeConstruct;

    //TODO - it is a bad idea to create objects on each access, maybe utilize DOM level2 events
    //So that they are only created on attribute changed, or DOM modified!?

    var currentPropertyValue = this.getPropertyValue(propertyName, codeConstruct);

    if(this._isMethod(propertyName))
    {
        return currentPropertyValue;
    }

    if(fcModel.DOM_PROPERTIES.isElementOther(propertyName) || fcModel.DOM_PROPERTIES.isNodeOther(propertyName))
    {
        if(propertyName == "ownerDocument") { return currentPropertyValue; }
        else if(propertyName == "attributes") { this.addProperty(propertyName, fcModel.Attr.createAttributeList(this.htmlElement, this.globalObject, codeConstruct), creationConstruct); }
        else if(propertyName == "style") { this.addProperty(propertyName, fcModel.CSSStyleDeclaration.createStyleDeclaration(this.htmlElement, this.htmlElement.style, this.globalObject, creationConstruct), creationConstruct); }
    }

    if(fcModel.DOM_PROPERTIES.isNodeElements(propertyName) || fcModel.DOM_PROPERTIES.isElementElements(propertyName))
    {
        if(this.htmlElement[propertyName] == null)
        {
            return currentPropertyValue;
        }
        else
        {
            var elements = this._getElements(propertyName, codeConstruct);
            var array = this.globalObject.internalExecutor.createArray(codeConstruct, elements);
            array.iValue.markAsNodeList();

            this.addProperty(propertyName, array, creationConstruct);

            fcModel.HtmlElementExecutor.addDependencies(elements, codeConstruct, this.globalObject);
        }
    }

    if(fcModel.DOM_PROPERTIES.isNodeElement(propertyName) || fcModel.DOM_PROPERTIES.isElementElement(propertyName) || (ValueTypeHelper.isHtmlFormElement(this.htmlElement) && ValueTypeHelper.isHtmlElement(this.htmlElement[propertyName])))
    {
        //mooTools Firefox HACK
        var element = this.htmlElement[propertyName];
        if(element == null && this.htmlElement.innerHTML == "<select><option>s</option></select>")
        {
            var div = document.createElement("div");
            div.innerHTML = "<select><option>s</option></select>";
            element = div[propertyName];
        }

        this.addProperty(propertyName, fcModel.HtmlElementExecutor.wrapToFcElement(element, this.globalObject, creationConstruct), creationConstruct);

        fcModel.HtmlElementExecutor.addDependencies(this.htmlElement[propertyName], codeConstruct, this.globalObject);
    }

    if(fcModel.DOM_PROPERTIES.isNodePrimitives(propertyName) || fcModel.DOM_PROPERTIES.isElementPrimitives(propertyName))
    {
        var propertyValue = this.htmlElement[propertyName];

        //TODO - firefox rel HACK!
        if(propertyValue === undefined && propertyName == "rel")
        {
            propertyValue = this.htmlElement != null && this.htmlElement.getAttribute != null ? this.htmlElement.getAttribute(propertyName) : null;
        }

        if(ValueTypeHelper.isPrimitive(propertyValue))
        {
            this.addProperty(propertyName, this.globalObject.internalExecutor.createInternalPrimitiveObject(creationConstruct, propertyValue), creationConstruct);
        }
        else if (ValueTypeHelper.isHtmlElement(propertyValue))
        {
            this.addProperty(propertyName, fcModel.HtmlElementExecutor.wrapToFcElement(propertyValue, this.globalObject, creationConstruct), creationConstruct);
        }

        fcModel.HtmlElementExecutor.addDependencies(this.htmlElement, codeConstruct, this.globalObject);
    }

    if(propertyName == "textContent" || propertyName == "innerHTML")
    {
        fcModel.HtmlElementExecutor.addDependenciesToAllDescendantElements(this.htmlElement, codeConstruct, this.globalObject);
    }

    var propertyValue = this.getPropertyValue(propertyName, codeConstruct);

    if(this._isInputElement() && propertyName == "value") { return this._expandWithSymbolic(propertyName, propertyValue); }
    if(ValueTypeHelper.isHtmlSelectElement(this.htmlElement) && propertyName == "selectedIndex")
    {
        fcModel.HtmlElementExecutor.addDependencies(ValueTypeHelper.convertToArray(this.htmlElement.children), codeConstruct, this.globalObject);
    }

    return propertyValue;
};

fcModel.HtmlElement.prototype.addJsProperty = function(propertyName, propertyValue, codeConstruct, isEnumerable)
{
    try
    {
        if(propertyName == "src" && (ValueTypeHelper.isScriptElement(this.htmlElement) || ValueTypeHelper.isIFrameElement(this.htmlElement))
        && Firecrow.isIgnoredScript(propertyValue.jsValue))
        {
            //Do not write to a src property of script elements that should be skipped
        }
        else
        {
            var propertyJsValue = propertyValue.jsValue;

            if(ValueTypeHelper.isImageElement(this.htmlElement) && propertyName == "src")
            {
                propertyJsValue = Firecrow.UriHelper.getAbsoluteUrl(propertyJsValue, this.globalObject.browser.url)
            }

            this.htmlElement[propertyName] = propertyJsValue;
        }

        this._createDependencies(propertyName, codeConstruct);
        this._logDynamicPropertyModification(propertyName, propertyValue, codeConstruct);

        if(propertyName == "innerHTML")
        {
            this._createModelsForDynamicChildNodes(this.htmlElement, codeConstruct);
            this._registerEventsForDynamicChildNodes(this.htmlElement, codeConstruct);
        }
        else if(fcModel.DOM_PROPERTIES.isElementEventProperty(propertyName)) { this._registerEventHandler(propertyName, propertyValue, codeConstruct); }

        this.addProperty(propertyName, propertyValue, codeConstruct, isEnumerable);

        if(this.htmlElement != null && this.htmlElement.modelElement != null )
        {
            this.globalObject.browser.logModifyingExternalContextObject(this.htmlElement.modelElement.nodeId, propertyName);
        }
    }
    catch(e) { fcModel.HtmlElement.notifyError("Error when adding property: " + e);}
};
//</editor-fold>

//<editor-fold desc="Handlers">
fcModel.HtmlElement.prototype.notifyElementInsertedIntoDom = function(callExpression)
{
    try
    {
        this.htmlElement.domInsertionPoint =
        {
            codeConstruct: callExpression,
            evaluationPositionId: this.globalObject.getPreciseEvaluationPositionId()
        };

        this.globalObject.dependencyCreator.createDataDependency
        (
            this.htmlElement.modelElement,
            callExpression,
            this.globalObject.getPreciseEvaluationPositionId()
        );
    }
    catch(e) { fcModel.HtmlElement.notifyError("Error when handling element inserted into dom!"); }
};
//</editor-fold>

//<editor-fold desc="'Private' Methods">
fcModel.HtmlElement.prototype._registerEventHandler = function (propertyName, propertyValue, codeConstruct)
{
    this.globalObject.registerHtmlElementEventHandler
    (
        this,
        propertyName,
        propertyValue,
        {
            codeConstruct: codeConstruct,
            evaluationPositionId: this.globalObject.getPreciseEvaluationPositionId()
        }
    );
}

fcModel.HtmlElement.prototype._getPropertyHandler = function(getPropertyConstruct, propertyName)
{
    var evaluationPositionId = this.globalObject.getPreciseEvaluationPositionId();
    this.addDependencyToAllModifications(getPropertyConstruct, this.htmlElement.elementModificationPoints);

    this.globalObject.dependencyCreator.createDataDependency(getPropertyConstruct, this.htmlElement.modelElement, evaluationPositionId);

    if(fcModel.DOM_PROPERTIES.isElementElements(propertyName) || fcModel.DOM_PROPERTIES.isNodeElements(propertyName))
    {
        var descendents = this.htmlElement[propertyName];

        if(descendents != null)
        {
            for(var i = 0; i < descendents.length; i++)
            {
                var descendant = descendents[i];

                if(descendant == null) { continue; }

                this.globalObject.dependencyCreator.createDataDependency(getPropertyConstruct, descendant.modelElement, evaluationPositionId);
            }
        }
    }
    else if (fcModel.DOM_PROPERTIES.isElementElement(propertyName) || fcModel.DOM_PROPERTIES.isNodeElement(propertyName))
    {
        var element = this.htmlElement[propertyName];

        if(element == null) { return; }

        this.globalObject.dependencyCreator.createDataDependency(getPropertyConstruct, element.modelElement, evaluationPositionId);
    }
};

fcModel.HtmlElement.prototype._expandWithDefaultProperties = function()
{
    //fcModel.DOM_PROPERTIES.setPrimitives(this, this.htmlElement, fcModel.DOM_PROPERTIES.NODE.PRIMITIVES);
    //fcModel.DOM_PROPERTIES.setPrimitives(this, this.htmlElement, fcModel.DOM_PROPERTIES.ELEMENT.PRIMITIVES);

    var creationConstruct = this.htmlElement != null && this.htmlElement.modelElement != null ? this.htmlElement.modelElement : this.creationCodeConstruct;

    this.addProperty("ownerDocument", this.globalObject.jsFcDocument, creationConstruct);
    if(this.htmlElement != null && this.htmlElement.nodeName != null && this.htmlElement.nodeName == "IFRAME")
    {
        this.addProperty("contentWindow", this.globalObject, creationConstruct);
    }

    this.addProperty("__proto__", this.globalObject.fcHtmlElementPrototype, null, false);
    this._addMethods(creationConstruct);

    this.htmlElement.elementModificationPoints = [];
};

fcModel.HtmlElement.prototype._getElements = function(propertyName, codeConstruct)
{
    var array = [];
    var items = this.htmlElement[propertyName];

    if(items == null) { return array; }
    //TODO HACK for Firefox MooTools - for some reason setting the innerHTML does nothing
    if(items.length == 0 && codeConstruct.loc.start.line == 3573 && this.htmlElement.innerHTML == "<nav></nav>")
    {
        var a = document.createElement("div");
        a.innerHTML = "<nav></nav>";
        items = a[propertyName];
    }

    for(var i = 0, length = items.length; i < length; i++)
    {
        array.push(fcModel.HtmlElementExecutor.wrapToFcElement(items[i], this.globalObject, codeConstruct));
    }

    return array;
};

fcModel.HtmlElement.prototype._createModelsForDynamicChildNodes = function(htmlElement, codeConstruct)
{
    var evaluationPosition = this.globalObject.getPreciseEvaluationPositionId();

    for(var i = 0; i < htmlElement.childNodes.length; i++)
    {
        var childNode = htmlElement.childNodes[i];

        childNode.creationPoint =
        {
            codeConstruct: codeConstruct,
            evaluationPositionId: evaluationPosition
        };

        childNode.modelElement = { type: childNode.nodeName.toLowerCase(), domElement: childNode , isDummyElement: true, nodeId: "D" + this.globalObject.DYNAMIC_NODE_COUNTER++};
        this.globalObject.browser.callNodeCreatedCallbacks(childNode.modelElement, "html", true);

        this.globalObject.dependencyCreator.createDataDependency(htmlElement.modelElement, childNode.modelElement, evaluationPosition);
        this.globalObject.dependencyCreator.createDataDependency(childNode.modelElement, codeConstruct, evaluationPosition);

        if(childNode.id != null && childNode.id != "")
        {
            childNode.modelElement.dynamicIds = {};
            var codeConstructId = codeConstruct != null ? codeConstruct.nodeId : 0;
            childNode.modelElement.dynamicIds[childNode.id + codeConstructId] = {name:'id', value: childNode.id, setConstruct: codeConstruct};
            this.globalObject.browser.logDynamicId(childNode.id, codeConstructId, childNode.modelElement.nodeId);
        }

        if(childNode.className != null && childNode.className != "")
        {
            childNode.modelElement.dynamicClasses = {};
            var codeConstructId = codeConstruct != null ? codeConstruct.nodeId : 0;
            childNode.modelElement.dynamicClasses[childNode.className + codeConstructId] = {name:'class', value: childNode.className, setConstruct: codeConstruct};
            this.globalObject.browser.logDynamicClass(childNode.className, codeConstructId, childNode.modelElement.nodeId);
        }

        this.globalObject.browser.createDependenciesBetweenHtmlNodeAndCssNodes(childNode.modelElement);
        this._createModelsForDynamicChildNodes(childNode, codeConstruct);
    }
};

fcModel.HtmlElement.prototype._registerEventsForDynamicChildNodes = function(htmlElement, codeConstruct)
{
    var evaluationPosition = this.globalObject.getPreciseEvaluationPositionId();

    for(var i = 0; i < htmlElement.childNodes.length; i++)
    {
        var childNode = htmlElement.childNodes[i];

        if(childNode.attributes == null) { continue; }

        for(var j = 0; j < childNode.attributes.length; j++)
        {
            var attribute = childNode.attributes[j];

            if(fcModel.DOM_PROPERTIES.isElementEventProperty(attribute.name))
            {
                this._registerEventForDynamicNode(childNode, attribute.name, attribute.value, codeConstruct, evaluationPosition);
            }
        }

        this._registerEventsForDynamicChildNodes(childNode, codeConstruct);
    }
};

fcModel.HtmlElement.prototype._registerEventForDynamicNode = function(htmlElement, event, sourceCode, codeConstruct, evaluationPosition)
{
    try
    {
        var ast = esprima.parse("(function (event) {"  + sourceCode + "})");

        ASTHelper.setParentsChildRelationships(ast);
        ASTHelper.traverseAst(ast, function(node)
        {
             node.nodeId = "D" + fcModel.HtmlElement.dynamicConstructId++;
        });

        var commands = CommandGenerator.generateCommands(ast);

        for(var i = 0; i < commands.length; i++)
        {
            this.globalObject.executionContextStack.executeCommand(commands[i]);
        }

        this.globalObject.registerHtmlElementEventHandler
        (
            new fcModel.HtmlElement(htmlElement, this.globalObject, codeConstruct),
            event,
            this.globalObject.executionContextStack.getExpressionValue(ast.children[0].children[0]),//to reach the function expression, program -> expression statement -> function expression
            {
                codeConstruct: codeConstruct,
                evaluationPositionId: evaluationPosition
            }
        );
    }
    catch(e)
    {
        debugger;
        alert("Error when registering event in dynamically created node:" + e);
    }

};

fcModel.HtmlElement.prototype._addMethods = function(codeConstruct)
{
    try
    {
        var methods = ValueTypeHelper.isDocumentFragment(this.htmlElement) ? fcModel.HtmlElement.CONST.INTERNAL_PROPERTIES.DOCUMENT_FRAGMENT_METHODS
                                                                           : fcModel.HtmlElement.CONST.INTERNAL_PROPERTIES.METHODS;

        for(var i = 0, length = methods.length; i < length; i++)
        {
            var methodName = methods[i];
            var htmlElementMethod = this.htmlElement[methodName];

            if(methodName == "getContext" && ValueTypeHelper.isCanvasElement(this.htmlElement) && htmlElementMethod == null)
            {
                htmlElementMethod = HTMLCanvasElement.prototype.getContext;
                this.htmlElement[methodName] = htmlElementMethod;
            }
            else if (methodName == "click" && ValueTypeHelper.isHtmlInputElement(this.htmlElement) && htmlElementMethod == null)
            {
                htmlElementMethod = HTMLInputElement.prototype.click;
                this.htmlElement[methodName] = htmlElementMethod;
            }

            this.addProperty(methodName, this.globalObject.internalExecutor.createInternalFunction(htmlElementMethod, methodName, this), codeConstruct);
        }
    }
    catch(e) { fcModel.HtmlElement.notifyError("Error when adding methods: " + e);}
};

fcModel.HtmlElement.prototype._isMethod = function(propertyName)
{
    return fcModel.HtmlElement.CONST.INTERNAL_PROPERTIES.METHODS.indexOf(propertyName) != -1;
};

fcModel.HtmlElement.prototype._createDependencies = function(propertyName, codeConstruct)
{
    this.globalObject.dependencyCreator.createDataDependency(this.htmlElement.modelElement, codeConstruct, this.globalObject.getPreciseEvaluationPositionId());
    fcModel.HtmlElementExecutor.addDependencyIfImportantElement(this.htmlElement, this.globalObject, codeConstruct);

    if(propertyName == "className" || propertyName == "id")
    {
        this.globalObject.browser.createDependenciesBetweenHtmlNodeAndCssNodes(this.htmlElement.modelElement);
    }
};

fcModel.HtmlElement.prototype._logDynamicPropertyModification = function(propertyName, propertyValue, codeConstruct)
{
    fcModel.HtmlElement.accessedProperties[propertyName] = true;
    this.htmlElement.elementModificationPoints.push({ codeConstruct: codeConstruct, evaluationPositionId: this.globalObject.getPreciseEvaluationPositionId()});

    if(propertyName == "id")
    {
        if(this.htmlElement.modelElement.dynamicIds == null) { this.htmlElement.modelElement.dynamicIds = {}; }

        var codeConstructId = codeConstruct != null ? codeConstruct.nodeId : 0;
        this.htmlElement.modelElement.dynamicIds[propertyValue.jsValue + codeConstructId] = {name:'id', value: propertyValue.jsValue, setConstruct: codeConstruct};

        this.globalObject.browser.logDynamicId(propertyValue.jsValue, codeConstructId, this.htmlElement.modelElement.nodeId);
    }
    else if(propertyName == "className")
    {
        if(this.htmlElement.modelElement.dynamicClasses == null) { this.htmlElement.modelElement.dynamicClasses = {}; }

        var codeConstructId = codeConstruct != null ? codeConstruct.nodeId : 0;
        this.htmlElement.modelElement.dynamicClasses[propertyValue.jsValue + codeConstructId] = {name:'class', value: propertyValue.jsValue, setConstruct: codeConstruct};
        this.globalObject.browser.logDynamicClass(propertyValue.jsValue, codeConstructId, this.htmlElement.modelElement.nodeId);
    }
    else if(propertyName == "src")
    {
        this.globalObject.logResourceSetting(codeConstruct, propertyValue.jsValue);
    }
};

fcModel.HtmlElement.prototype._isInputElement = function()
{
    return ValueTypeHelper.isHtmlSelectElement(this.htmlElement)
        || ValueTypeHelper.isHtmlInputElement(this.htmlElement)
        || ValueTypeHelper.isHtmlTextAreaElement(this.htmlElement);
};

fcModel.HtmlElement.prototype._expandWithSymbolic = function(propertyName, propertyValue)
{
    if(propertyValue == null || propertyValue.iValue == null) { return; }

    propertyValue.symbolicValue = new FBL.Firecrow.ScenarioGenerator.Symbolic.Identifier(this._expandPropertyName(propertyName));

    return propertyValue;
};

fcModel.HtmlElement.prototype._expandPropertyName = function(propertyName)
{
    var eventIndex = this.globalObject.browser.eventIndex || 0;

    propertyName = "DOM_" + propertyName + "_FC_" + eventIndex;

    //format: DOM_PROPERTY_NAME_FC_EVENT_INDEX_ID_XX_CLASS_
    if(this.htmlElement.id) { propertyName += "_ID_" + this.htmlElement.id.replace(/\s+/g, ""); }
    if(this.htmlElement.className) { propertyName += "_CLASS_" + this.htmlElement.className.replace(/\s+/g, ""); }

    return propertyName;
};
//</editor-fold>
//</editor-fold>

//https://developer.mozilla.org/en/DOM/element
fcModel.HtmlElement.CONST =
{
    INTERNAL_PROPERTIES :
    {
        METHODS:
        [
            "addEventListener", "appendChild","blur", "click", "cloneNode", "compareDocumentPosition",
            "dispatchEvent", "focus", "getAttribute", "getAttributeNS", "getAttributeNode", "getAttributeNodeNS",
            "getBoundingRect", "getClientRects", "getBoundingClientRect", "getElementsByClassName", "getElementsByTagName", "getElementsByTagNameNS",
            "getFeature", "getUserData", "hasAttribute", "hasAttributeNS", "hasAttributes", "hasChildNodes", "insertBefore",
            "isDefaultNamespace", "isEqualNode", "isSameNode", "isSupported", "lookupNamespaceURI", "lookupPrefix",
            "mozRequestFullScreen", "normalize", "querySelector", "querySelectorAll", "removeAttribute", "removeAttributeNS", "removeAttributeNode",
            "removeChild", "removeEventListener", "replaceChild", "scrollIntoView", "setAttribute", "setAttributeNS", "setAttributeNode",
            "setAttributeNodeNS", "setCapture", "setIdAttribute", "setIdAttributeNS", "setIdAttributeNode", "setUserData", "insertAdjacentHTML",
            "mozMatchesSelector", "webkitMatchesSelector", "contains",
            "getContext", "reset"
        ],
        DOCUMENT_FRAGMENT_METHODS:
        [
            "addEventListener", "appendChild", "cloneNode", "compareDocumentPosition",
            "dispatchEvent", "hasChildNodes", "insertBefore",
            "isDefaultNamespace", "isEqualNode", "isSameNode", "isSupported", "lookupNamespaceURI", "lookupPrefix",
            "normalize", "querySelector", "querySelectorAll",
            "removeChild", "removeEventListener", "replaceChild", "setUserData", "contains",
        ]
    }
};
}});FBL.ns(function() { with (FBL) {
/*************************************************************************************/
var fcModel = Firecrow.Interpreter.Model;
var ValueTypeHelper = Firecrow.ValueTypeHelper;

fcModel.HtmlElementExecutor =
{
    addDependencyIfImportantElement: function(htmlElement, globalObject, codeConstruct)
    {
        if(globalObject.satisfiesDomSlicingCriteria(htmlElement))
        {
            globalObject.browser.callImportantConstructReachedCallbacks(codeConstruct);
        }
    },

    addDependenciesToAllDescendantsModifications: function(htmlElement, codeConstruct, globalObject)
    {
        fcModel.Object.prototype.addDependencyToAllModifications.call
        (
            {
                htmlElement:htmlElement,
                globalObject:globalObject,
                dependencyCreator: globalObject.dependencyCreator
            },
            codeConstruct,
            htmlElement.elementModificationPoints
        );

        var childNodes = htmlElement.childNodes;

        for(var i = 0, length = childNodes.length; i < length; i++)
        {
            this.addDependenciesToAllDescendantsModifications(childNodes[i], codeConstruct, globalObject);
        }
    },

    addDependenciesToAllDescendantElements: function(htmlElement, codeConstruct, globalObject)
    {
        if(htmlElement == null || globalObject == null) { return; }

        var childNodes = htmlElement.childNodes;
        var evaluationPositionId = globalObject.getPreciseEvaluationPositionId();

        for(var i = 0, length = childNodes.length; i < length; i++)
        {
            var childNode = childNodes[i];
            globalObject.dependencyCreator.createDataDependency(htmlElement.modelElement, childNode.modelElement, evaluationPositionId);
            this.addDependenciesToAllDescendantElements(childNode, codeConstruct, globalObject);
        }
    },

    executeInternalMethod: function(thisObject, functionObject, args, callExpression)
    {
        if(!functionObject.isInternalFunction) { fcModel.HtmlElement.notifyError("The function should be internal when executing html method!"); return; }

        var functionObjectValue = functionObject.jsValue;
        var thisObjectValue = thisObject.jsValue;
        var functionName = functionObjectValue != null ? functionObjectValue.name : functionObject.iValue.name;
        var fcThisValue =  thisObject.iValue;
        var globalObject = fcThisValue.globalObject;
        var jsArguments =  globalObject.getJsValues(args)

        switch(functionName)
        {
            case "getElementsByTagName":
            case "getElementsByClassName":
            case "querySelectorAll":
                return this._getElements(functionName, globalObject, args[0].jsValue, thisObjectValue, jsArguments, callExpression);
            case "querySelector":
                return this._getElement(functionName, globalObject, args[0].jsValue, thisObjectValue, jsArguments, callExpression);
            case "getAttribute":
                return this._getAttribute(functionName, thisObjectValue, jsArguments, globalObject, callExpression);
            case "getAttributeNode":
                return this._getAttributeNode(functionName, thisObjectValue, jsArguments, globalObject, callExpression);
            case "setAttribute":
            case "removeAttribute":
                return this._modifyAttribute(functionName, thisObjectValue, jsArguments, globalObject, callExpression);
            case "appendChild":
            case "removeChild":
            case "insertBefore":
            case "replaceChild":
                return this._modifyDOM(functionName, thisObjectValue, args, jsArguments, globalObject, callExpression);
            case "cloneNode":
                return this._cloneNode(functionName, thisObjectValue, jsArguments, globalObject, callExpression);
            case "addEventListener":
                this._registerEventHandler(fcThisValue, jsArguments, args[1], globalObject, callExpression);
            case "removeEventListener":
                this._removeEventHandler(thisObjectValue, globalObject, callExpression);
                return globalObject.internalExecutor.createInternalPrimitiveObject(callExpression, undefined);
            case "matchesSelector":
            case "mozMatchesSelector":
            case "webkitMatchesSelector":
                globalObject.browser.logDomQueried(functionName, args[0].jsValue, callExpression);
            case "compareDocumentPosition":
            case "contains":
                return this._queryDocument(functionName, thisObjectValue, jsArguments, globalObject, callExpression);
            case "getBoundingClientRect":
                return this._getBoundingClientRectangle(functionName, thisObjectValue, jsArguments, globalObject, callExpression);
            case "getContext":
                if(ValueTypeHelper.isCanvasElement(thisObjectValue))
                {
                    return fcModel.CanvasExecutor.executeCanvasMethod(thisObject, functionObject, args, callExpression);
                }
            case "click":
            case "reset":
            case "blur":
            case "focus":
                //TODO - problem with reset, my html nodes are created by document.createElement() and then
                //setting properties, and reset resets to the values in the HTML code, and not to the dynamically set ones
                if(thisObjectValue[functionName] != null)
                {
                    try{thisObjectValue[functionName]();}catch(e){}
                    thisObjectValue.elementModificationPoints.push({ codeConstruct: callExpression, evaluationPositionId: globalObject.getPreciseEvaluationPositionId()});
                    fcModel.HtmlElementExecutor.addDependencyIfImportantElement(thisObjectValue, globalObject, callExpression);
                }
                break;
            default:
                fcModel.HtmlElement.notifyError("Unhandled internal method:" + functionName); return;
        }
    },

    wrapToFcElements: function(items, globalObject, codeConstruct)
    {
        try
        {
            var fcItems = [];

            for(var i = 0, length = items.length; i < length; i++)
            {
                var item = items[i];
                fcItems.push(this.wrapToFcElement(item, globalObject, codeConstruct));
            }

            return globalObject.internalExecutor.createArray(codeConstruct, fcItems);
        }
        catch(e)
        {
            fcModel.HtmlElement.notifyError("HtmlElementExecutor - error when wrapping: " + e);
        }
    },

    wrapToFcElement: function(item, globalObject, codeConstruct)
    {
        try
        {
            if(item == null) { return new fcModel.fcValue(item, item, codeConstruct); }

            if(ValueTypeHelper.isHtmlElement(item) || ValueTypeHelper.isDocumentFragment(item) || ValueTypeHelper.isImageElement(item))
            {
                var fcHtmlElement = globalObject.document.htmlElementToFcMapping[item.fcHtmlElementId];

                if(fcHtmlElement == null) { fcHtmlElement = new fcModel.HtmlElement(item, globalObject, codeConstruct); }

                if(ValueTypeHelper.isImageElement(item))
                {
                    fcHtmlElement.addProperty("__proto__", globalObject.fcHtmlImagePrototype);
                }
                else if (ValueTypeHelper.isCanvasElement(item))
                {
                    fcHtmlElement.addProperty("__proto__", globalObject.fcCanvasPrototype);
                }

                return new fcModel.fcValue(item, fcHtmlElement, codeConstruct);
            }
            else if (ValueTypeHelper.isTextNode(item))
            {
                return new fcModel.fcValue(item, new fcModel.TextNode(item, globalObject, codeConstruct), codeConstruct);
            }
            else if (ValueTypeHelper.isDocument(item))
            {
                return globalObject.jsFcDocument;
            }
            else
            {
                debugger;
                fcModel.HtmlElement.notifyError("HtmlElementExecutor - when wrapping should not be here: " + item);
            }
        }
        catch(e)
        {
            debugger;
            fcModel.HtmlElement.notifyError("HtmlElementExecutor - error when wrapping: " + e);
        }
    },

    addDependencies: function(element, codeConstruct, globalObject)
    {
        try
        {
            if(element == null) { return; }

            if(ValueTypeHelper.isArray(element))
            {
                for(var i = 0; i < element.length; i++)
                {
                    this.addDependencies(element[i], codeConstruct, globalObject);
                }

                return;
            }

            var evaluationPositionId = globalObject.getPreciseEvaluationPositionId();

            if(element.modelElement != null)
            {
                globalObject.dependencyCreator.createDataDependency(codeConstruct, element.modelElement, evaluationPositionId);
            }

            if (element.creationPoint != null)
            {
                globalObject.dependencyCreator.createDataDependency
                (
                    codeConstruct,
                    element.creationPoint.codeConstruct,
                    evaluationPositionId,
                    element.creationPoint.evaluationPositionId
                );
            }

            if(element.domInsertionPoint != null)
            {
                globalObject.dependencyCreator.createDataDependency
                (
                    codeConstruct,
                    element.domInsertionPoint.codeConstruct,
                    evaluationPositionId,
                    element.domInsertionPoint.evaluationPositionId
                );
            }

            if(element.elementModificationPoints != null)
            {
                var elementModificationPoints = element.elementModificationPoints;

                for(var i = 0, length = elementModificationPoints.length; i < length; i++)
                {
                    var elementModificationPoint = elementModificationPoints[i];

                    globalObject.dependencyCreator.createDataDependency
                    (
                        codeConstruct,
                        elementModificationPoint.codeConstruct,
                        evaluationPositionId,
                        elementModificationPoint.evaluationPositionId
                    );
                }
            }
        }
        catch(e) { fcModel.HtmlElement.notifyError("Error when adding dependencies: " + e); }
    },

    _getElements: function(functionName, globalObject, argument, thisObjectValue, jsArguments, callExpression)
    {
        var elements = [];

        try
        {
            globalObject.browser.logDomQueried(functionName, argument, callExpression);
            elements = thisObjectValue[functionName].apply(thisObjectValue, jsArguments);
        }
        catch(e)
        {
            //TODO - IF statement (the else should always be, but the if should not)
            // is a jQuery hack, for some reason - should not throw an exception if thisObjectValue is documentFragment
            //and jsArguments is a simple selector
            if(ValueTypeHelper.isDocumentFragment(thisObjectValue) && jsArguments.length == 1
           && (jsArguments[0] == "*" || jsArguments[0] == "script"))
            {
                elements = this._getElementsFromDocumentFragment(thisObjectValue, jsArguments[0], functionName);
            }
            else
            {
                globalObject.executionContextStack.callExceptionCallbacks
                ({
                    exceptionGeneratingConstruct: callExpression,
                    isDomStringException: true
                });
            }
        }

        for(var i = 0, length = elements.length; i < length; i++)
        {
            this.addDependencies(elements[i], callExpression, globalObject);
        }

        var wrappedArray = this.wrapToFcElements(elements, globalObject, callExpression);

        wrappedArray.iValue.markAsNodeList();

        return wrappedArray;
    },

    _getElement: function(functionName, globalObject, argument, thisObjectValue, jsArguments, callExpression)
    {
        var element = null;

        try
        {
            globalObject.browser.logDomQueried(functionName, argument, callExpression);
            element = thisObjectValue[functionName].apply(thisObjectValue, jsArguments);
        }
        catch(e)
        {
            globalObject.executionContextStack.callExceptionCallbacks
            ({
                exceptionGeneratingConstruct: callExpression,
                isDomStringException: true
            });
        }

        this.addDependencies(element, callExpression, globalObject);

        return this.wrapToFcElement(element, globalObject, callExpression);
    },

    _getElementsFromDocumentFragment: function(documentFragment, selector, functionName)
    {
        var elements = [];

        for(var i = 0; i < documentFragment.childNodes.length; i++)
        {
            var childNode = documentFragment.childNodes[i];
            var matchesSelector = false;

            if(childNode.webkitMatchesSelector) { matchesSelector = childNode.webkitMatchesSelector(selector); }
            else if(childNode.mozMatchesSelector) { matchesSelector = childNode.mozMatchesSelector(selector); }
            else if(childNode.oMatchesSelector) { matchesSelector = childNode.oMatchesSelector(selector); }
            else if(childNode.msMatchesSelector) { matchesSelector = childNode.msMatchesSelector(selector); }

            if(matchesSelector)
            {
                elements.push(childNode);
            }

            if(childNode[functionName])
            {
                var descendents = childNode[functionName].apply(childNode, [selector]);

                for(var j = 0; j < descendents.length; j++)
                {
                    elements.push(descendents[j]);
                }
            }
        }

        return elements;
    },

    _getAttribute: function(functionName, thisObjectValue, jsArguments, globalObject, callExpression)
    {
        var result = thisObjectValue[functionName].apply(thisObjectValue, jsArguments);
        this.addDependencies(thisObjectValue, callExpression, globalObject);

        return globalObject.internalExecutor.createInternalPrimitiveObject(callExpression, result);
    },

    _getAttributeNode: function(functionName, thisObjectValue, jsArguments, globalObject, callExpression)
    {
        try
        {
           var attribute = thisObjectValue[functionName].apply(thisObjectValue, jsArguments);
        }
        catch(e) { console.log("Exception when getAttributeNode - probably irrelevant"); }

        if(attribute == null) { return globalObject.internalExecutor.createInternalPrimitiveObject(callExpression, null); }

        this.addDependencies(thisObjectValue, callExpression, globalObject);

        return fcModel.Attr.wrapAttribute(attribute, globalObject, callExpression);

    },

    _modifyAttribute: function(functionName, thisObjectValue, jsArguments, globalObject, callExpression)
    {
        thisObjectValue[functionName].apply(thisObjectValue, jsArguments);
        thisObjectValue.elementModificationPoints.push({ codeConstruct: callExpression, evaluationPositionId: globalObject.getPreciseEvaluationPositionId()});
        fcModel.HtmlElementExecutor.addDependencyIfImportantElement(thisObjectValue, globalObject, callExpression);

        return globalObject.internalExecutor.createInternalPrimitiveObject(callExpression, undefined);
    },

    _modifyDOM: function(functionName, thisObjectValue, args, jsArguments, globalObject, callExpression)
    {
        thisObjectValue[functionName].apply(thisObjectValue, jsArguments);
        thisObjectValue.elementModificationPoints.push({ codeConstruct: callExpression, evaluationPositionId: globalObject.getPreciseEvaluationPositionId()});
        fcModel.HtmlElementExecutor.addDependencyIfImportantElement(thisObjectValue, globalObject, callExpression);

        if(functionName == "appendChild" || functionName == "insertBefore")
        {
            this._createCssDependencies(thisObjectValue, globalObject);
        }

        for(var i = 0; i < args.length; i++)
        {
            var manipulatedElement = args[i].iValue;

            if(manipulatedElement != null && !manipulatedElement.isComment) //Because of comments
            {
                try
                {
                    manipulatedElement.notifyElementInsertedIntoDom(callExpression);
                }
                catch(e) { debugger;}
            }
        }

        if(functionName == "replaceChild") { return args[args.length - 1]; }

        return args[0];
    },

    _createCssDependencies: function(htmlElement, globalObject)
    {
        if(htmlElement == null) { return; }

        if(htmlElement.modelElement)
        {
            htmlElement.modelElement.domElement = htmlElement;
        }

        globalObject.browser.createDependenciesBetweenHtmlNodeAndCssNodes(htmlElement.modelElement);

        var children = htmlElement.childNodes;
        if(children == null || children.length == 0) { return; }

        for(var i = 0; i < children.length; i++)
        {
            this._createCssDependencies(children[i], globalObject)
        }
    },

    _cloneNode: function(functionName, thisObjectValue, jsArguments, globalObject, callExpression)
    {
        this.addDependenciesToAllDescendantsModifications(thisObjectValue, callExpression, globalObject);

        var clonedNode = thisObjectValue[functionName].apply(thisObjectValue, jsArguments,
        {
            codeConstruct: callExpression,
            evaluationPositionId: globalObject.getPreciseEvaluationPositionId()
        });

        this._copyModelElements(thisObjectValue, clonedNode);

        return this.wrapToFcElement(clonedNode, globalObject, callExpression);
    },

    _copyModelElements: function(originalElement, clonedElement, creationPoint)
    {
        clonedElement.modelElement = originalElement.modelElement;
        clonedElement.creationPoint = creationPoint;

        for(var i = 0; i < originalElement.childNodes.length; i++)
        {
            this._copyModelElements(originalElement.childNodes[i], clonedElement.childNodes[i], creationPoint);
        }
    },

    _registerEventHandler: function(fcThisValue, jsArguments, handler, globalObject, callExpression)
    {
        if(fcThisValue && fcThisValue.implementationObject && fcThisValue.implementationObject.modelElement)
        {
            globalObject.dependencyCreator.createDataDependency
            (
                fcThisValue.implementationObject.modelElement,
                callExpression,
                globalObject.getPreciseEvaluationPositionId()
            );
        }

        globalObject.registerHtmlElementEventHandler
        (
            fcThisValue,
            jsArguments[0],
            handler,
            {
                codeConstruct: callExpression,
                evaluationPositionId: globalObject.getPreciseEvaluationPositionId()
            }
        );
    },

    _removeEventHandler: function(thisObjectValue, globalObject, callExpression)
    {
        fcModel.HtmlElementExecutor.addDependencyIfImportantElement(thisObjectValue, globalObject, callExpression);
        thisObjectValue.elementModificationPoints.push({ codeConstruct: callExpression, evaluationPositionId: globalObject.getPreciseEvaluationPositionId()});
    },

    _queryDocument: function(functionName, thisObjectValue, jsArguments, globalObject, callExpression)
    {
        var result = false;
        try
        {
            result = thisObjectValue[functionName].apply(thisObjectValue, jsArguments);
        }
        catch(e)
        {
            globalObject.executionContextStack.callExceptionCallbacks
            ({
                exceptionGeneratingConstruct: callExpression,
                isDomStringException: true
            });
        }

        return globalObject.internalExecutor.createInternalPrimitiveObject(callExpression, result);
    },

    _getBoundingClientRectangle: function(functionName, thisObjectValue, jsArguments, globalObject, callExpression)
    {
        try
        {
            var result = thisObjectValue[functionName].apply(thisObjectValue, jsArguments);

            var nativeObj =
            {
                bottom: globalObject.internalExecutor.createInternalPrimitiveObject(callExpression, result.bottom),
                top: globalObject.internalExecutor.createInternalPrimitiveObject(callExpression, result.top),
                left: globalObject.internalExecutor.createInternalPrimitiveObject(callExpression, result.left),
                right: globalObject.internalExecutor.createInternalPrimitiveObject(callExpression, result.right),
                height: globalObject.internalExecutor.createInternalPrimitiveObject(callExpression, result.height),
                width: globalObject.internalExecutor.createInternalPrimitiveObject(callExpression, result.width)
            };

            var fcObj = fcModel.Object.createObjectWithInit(globalObject, callExpression, nativeObj);

            fcObj.addProperty("bottom", nativeObj.bottom, callExpression);
            fcObj.addProperty("top", nativeObj.top, callExpression);
            fcObj.addProperty("left", nativeObj.left, callExpression);
            fcObj.addProperty("right", nativeObj.right, callExpression);
            fcObj.addProperty("height", nativeObj.height, callExpression);
            fcObj.addProperty("width", nativeObj.width, callExpression);

            return new fcModel.fcValue(nativeObj, fcObj, callExpression);
        }
        catch(e) { fcModel.HtmlElement.notifyError("Error when adding dependencies: " + e); }

        return new fcModel.fcValue(undefined, null, callExpression);
    },

    notifyError: function(message) { alert("HtmlElementExecutor - " + message); }
}
/*************************************************************************************/
}});FBL.ns(function() { with (FBL) {
/*************************************************************************************/
var fcModel = Firecrow.Interpreter.Model;
var ValueTypeHelper = Firecrow.ValueTypeHelper;

fcModel.TextNode = function(textNode, globalObject, codeConstruct)
{
    try
    {
        if(!ValueTypeHelper.isTextNode(textNode) && !ValueTypeHelper.isComment(textNode)) { fcModel.TextNode.notifyError("When creating TextNode the textNode must be of type TextNode"); return; }

        this.initObject(globalObject, codeConstruct);

        this.textNode = textNode;
        this.textNode.elementModificationPoints = [];

        this._setDefaultProperties(codeConstruct);

        this.registerGetPropertyCallback(this._getPropertyCallback, this);
    }
    catch(e) { fcModel.TextNode.notifyError("Error when creating TextNode object: " + e); }
};

//<editor-fold desc="'Static' Methods">
fcModel.TextNode.accessedProperties = {};
fcModel.TextNode.notifyError = function(message) { debugger; alert("TextNode - " + message); };
//</editor-fold>

//<editor-fold desc="Prototype Definition">
fcModel.TextNode.prototype = new fcModel.Object();

//<editor-fold desc="Property Accessor">
fcModel.TextNode.prototype.getJsPropertyValue = function(propertyName, codeConstruct)
{
    fcModel.TextNode.accessedProperties[propertyName] = true;

    if (fcModel.DOM_PROPERTIES.isNodeElement(propertyName)) { return fcModel.HtmlElementExecutor.wrapToFcElement(this.textNode[propertyName], this.globalObject, codeConstruct) }

    return this.getPropertyValue(propertyName, codeConstruct);
};

fcModel.TextNode.prototype.addJsProperty = function(propertyName, propertyFcValue, codeConstruct)
{
    fcModel.TextNode.accessedProperties[propertyName] = true;

    //if(propertyName != "textContent") { fcModel.TextNode.notifyError("Add property to text node not yet implemented"); return; }

    this.textNode[propertyName] = propertyFcValue.jsValue;
    this.addProperty(propertyName, propertyFcValue, codeConstruct);
};
    //</editor-fold>

//<editor-fold desc="'Private' methods">
fcModel.TextNode.prototype._setDefaultProperties = function(creationConstruct)
{
    fcModel.DOM_PROPERTIES.setPrimitives(this, this.textNode, fcModel.DOM_PROPERTIES.NODE.PRIMITIVES);

    this._addMethods(creationConstruct);

    this.addProperty("ownerDocument", this.globalObject.jsFcDocument, this.creationCodeConstruct);
    this.addProperty("childNodes", this._getChildNodes(this.creationCodeConstruct), this.creationCodeConstruct);
};

fcModel.TextNode.prototype._addMethods = function(codeConstruct)
{
    var methods = fcModel.TextNode.CONST.INTERNAL_PROPERTIES.METHODS;

    for(var i = 0, length = methods.length; i < length; i++)
    {
        var methodName = methods[i];
        var textNodeMethod = this.textNode[methodName];

        this.addProperty(methodName, this.globalObject.internalExecutor.createInternalFunction(textNodeMethod, methodName, this), codeConstruct);
    }
};

fcModel.TextNode.prototype._getPropertyCallback = function(getPropertyConstruct)
{
    var evaluationPositionId = this.globalObject.getPreciseEvaluationPositionId();

    this.addDependencyToAllModifications(getPropertyConstruct, this.textNode.elementModificationPoints);

    this.globalObject.dependencyCreator.createDataDependency
    (
        getPropertyConstruct,
        this.textNode.modelElement,
        evaluationPositionId
    );
};

fcModel.TextNode.prototype._getChildNodes = function(codeConstruct)
{
    try
    {
        var childNodeList = [];
        for(var i = 0, childNodes = this.textNode.childNodes, length = childNodes.length; i < length; i++)
        {
            var childNode = childNodes[i];
            childNodeList.push
            (
                new fcModel.fcValue
                (
                    childNode,
                    new fcModel.TextNode(childNode, this.globalObject, codeConstruct),
                    codeConstruct
                )
            )
        }

        return this.globalObject.internalExecutor.createArray(codeConstruct, childNodeList);
    }
    catch(e) { this.notifyError("Error when getting child nodes:" + e);}
};

fcModel.TextNode.prototype.notifyElementInsertedIntoDom = function(callExpression){ };
    //</editor-fold>
//</editor-fold>

//https://developer.mozilla.org/en/DOM/element
fcModel.TextNode.CONST =
{
    INTERNAL_PROPERTIES :
    {
        METHODS:
        [
            "addEventListener", "removeEventListener", "dispatchEvent", "splitText",
            "insertBefore","replaceChild","removeChild","appendChild","hasChildNodes",
            "cloneNode","normalize","isSupported","hasAttributes",
            "compareDocumentPosition","lookupPrefix","isDefaultNamespace","lookupNamespaceURI",
            "isEqualNode","setUserData","getUserData","contains","substringData",
            "appendData","insertData","deleteData","replaceData"
        ]
    }
};
/*************************************************************************************/
}});FBL.ns(function() { with (FBL) {
/*************************************************************************************/
var fcModel = Firecrow.Interpreter.Model;
var ValueTypeHelper = Firecrow.ValueTypeHelper;

fcModel.Attr = function(attr, htmlElement, globalObject, codeConstruct)
{
    try
    {
        this.initObject(globalObject, codeConstruct, attr);

        this.htmlElement = htmlElement;
        this.attr = attr;

        this.constructor = fcModel.Attr;

        this.addProperty("isId", this.globalObject.internalExecutor.createInternalPrimitiveObject(codeConstruct, this.attr.isId), null);
        this.addProperty("localName", this.globalObject.internalExecutor.createInternalPrimitiveObject(codeConstruct, this.attr.localName), null);
        this.addProperty("name", this.globalObject.internalExecutor.createInternalPrimitiveObject(codeConstruct, this.attr.name), null);
        this.addProperty("namespaceURI", this.globalObject.internalExecutor.createInternalPrimitiveObject(codeConstruct, this.attr.namespaceURI), null);
        this.addProperty("nodeName", this.globalObject.internalExecutor.createInternalPrimitiveObject(codeConstruct, this.attr.nodeName), null);
        this.addProperty("nodeType", this.globalObject.internalExecutor.createInternalPrimitiveObject(codeConstruct, this.attr.nodeType), null);
        this.addProperty("nodeValue", this.globalObject.internalExecutor.createInternalPrimitiveObject(codeConstruct, this.attr.nodeValue), null);
        this.addProperty("specified", this.globalObject.internalExecutor.createInternalPrimitiveObject(codeConstruct, this.attr.specified), null);
        this.addProperty("textContent", this.globalObject.internalExecutor.createInternalPrimitiveObject(codeConstruct, this.attr.textContent), null);
        this.addProperty("value", this.globalObject.internalExecutor.createInternalPrimitiveObject(codeConstruct, this.attr.value), null);

        this.registerAddPropertyCallback(function(propertyName, propertyValue, codeConstruct)
        {
            fcModel.HtmlElementExecutor.addDependencyIfImportantElement(this.htmlElement, this.globalObject, codeConstruct);
        }, this);

        this.getJsPropertyValue = function(propertyName, codeConstruct)
        {
            return this.getPropertyValue(propertyName, codeConstruct);
        };
        this.addJsProperty = function(propertyName, propertyFcValue, codeConstruct)
        {
            this.attr[propertyName] = propertyFcValue.jsValue;
            this.addProperty(propertyName, propertyFcValue, codeConstruct);
        };
    }
    catch(e) { fcModel.Attr.notifyError("Error when creating Html Attr object: " + e); }
};
fcModel.Attr.notifyError = function(message) { debugger; alert("Attr - " + message); };

fcModel.Attr.prototype = new fcModel.Object();

fcModel.Attr.wrapAttribute = function(attribute, globalObject, codeConstruct)
{
    return new fcModel.fcValue
    (
        attribute,
        new fcModel.Attr(attribute, null, globalObject, codeConstruct),
        codeConstruct
    );
};

fcModel.Attr.createAttributeList = function(htmlElement, globalObject, codeConstruct)
{
    try
    {
        if(!ValueTypeHelper.isHtmlElement(htmlElement) && !ValueTypeHelper.isDocumentFragment(htmlElement))  {  fcModel.Attr.notifyError("Attr - when creating attribute list, the argument has to be an HTMLElement!"); }

        var attributeList = [];
        var attributes = htmlElement.attributes;
        var attributeNameFcValueMap = {};

        if(attributes != null)
        {
            for(var i = 0, length = attributes.length; i < length; i++)
            {
                var attribute = attributes[i];
                var fcAttribute = new fcModel.fcValue
                (
                    attribute,
                    new fcModel.Attr(attribute, htmlElement, globalObject, codeConstruct),
                    codeConstruct
                );

                attributeList.push(fcAttribute);

                attributeNameFcValueMap[attribute.name] = fcAttribute;
            }
        }

        var array = globalObject.internalExecutor.createArray(codeConstruct, attributeList);

        array.iValue.removePrototypeMethods();

        for(var attributeName in attributeNameFcValueMap)
        {
            array.iValue.addProperty(attributeName, attributeNameFcValueMap[attributeName]);
        }

        return array;
    }
    catch(e) { fcModel.Attr.notifyError("Attr - error when creating attribute list:" + e); }
};

//https://developer.mozilla.org/en/DOM/element
fcModel.Attr.CONST =
{
    INTERNAL_PROPERTIES :
    {
        METHODS:[],
        PROPERTIES:
        [
            "childNodes", "firstChild", "isId", "lastChild", "localName", "name", "namespaceURI",
            "nextSibling", "nodeName", "nodeType", "nodeValue", "ownerDocument", "ownerElement", "parentElement",
            "parentNode", "prefix", "previousSibling", "specified", "textContent", "value"
        ]
    }
};
}});FBL.ns(function() { with (FBL) {
/*************************************************************************************/
var fcModel = Firecrow.Interpreter.Model;
var ValueTypeHelper = Firecrow.ValueTypeHelper;

fcModel.ClassList = function(htmlElement, globalObject, codeConstruct)
{
    try
    {
        if(!ValueTypeHelper.isHtmlElement(htmlElement) && !ValueTypeHelper.isDocumentFragment(htmlElement)) { fcModel.ClassList.notifyError("Constructor argument has to be a HTMLElement");}

        this.initObject(this.globalObject, codeConstruct);

        this.htmlElement = htmlElement;

        var classList = htmlElement.classList;

        if(classList != null)
        {
            for(var i = 0, length = classList.length; i < length; i++)
            {
                this.addProperty(i, this.globalObject.internalExecutor.createInternalPrimitiveObject(codeConstruct, i), codeConstruct);
            }

            this.globalObject.internalExecutor.expandWithInternalFunction(classList.add, "add");
            this.globalObject.internalExecutor.expandWithInternalFunction(classList.remove, "remove");
            this.globalObject.internalExecutor.expandWithInternalFunction(classList.toggle, "toggle");
        }

        this.getJsPropertyValue = function(propertyName, codeConstruct) { fcModel.ClassList.notifyError("get property Class not yet implemented"); };
        this.addJsProperty = function(propertyName, value, codeConstruct) { fcModel.ClassList.notifyError("add property Class not yet implemented"); };
    }
    catch(e) { fcModel.ClassList.notifyError("Error when creating ClassList: " + e); }
};

fcModel.ClassList.notifyError = function(message) { alert("ClassList - " + message); };

fcModel.ClassList.prototype = new fcModel.Object();

fcModel.ClassList.createClassList = function(htmlElement, globalObject, codeConstruct)
{
    var jClassList = new fcModel.ClassList(htmlElement, globalObject, codeConstruct);
    return new fcModel.fcValue(jClassList, jClassList, codeConstruct);
};

//https://developer.mozilla.org/en/DOM/element
fcModel.ClassList.CONST =
{
    INTERNAL_PROPERTIES :
    {
        METHODS: [ "add", "remove", "toggle"]
    }
};
}});FBL.ns(function() { with (FBL) {
/*************************************************************************************/
var fcModel = Firecrow.Interpreter.Model;
var ValueTypeHelper = Firecrow.ValueTypeHelper;

fcModel.CSSStyleDeclaration = function(htmlElement, cssStyleDeclaration, globalObject, codeConstruct)
{
    try
    {
        this.initObject(globalObject, codeConstruct);

        this.htmlElement = htmlElement;
        this.cssStyleDeclaration = cssStyleDeclaration || this.htmlElement.style;

        this.constructor = fcModel.CSSStyleDeclaration;

        var methodObject = this.cssStyleDeclaration || CSSStyleDeclaration.prototype;

        var methods = fcModel.CSSStyleDeclaration.CONST.INTERNAL_PROPERTIES.METHODS;

        for(var i = 0, length = methods.length; i < length; i++)
        {
            var method = methods[i];

            this.addProperty
            (
                method,
                new fcModel.fcValue
                (
                    methodObject[method],
                    fcModel.Function.createInternalNamedFunction(globalObject, method, this),
                    codeConstruct
                ),
                codeConstruct,
                false
            );
        }

        this.getJsPropertyValue = function(propertyName, codeConstruct)
        {
            if(ValueTypeHelper.isPrimitive(this.cssStyleDeclaration[propertyName]))
            {
                return this.globalObject.internalExecutor.createInternalPrimitiveObject(codeConstruct, this.cssStyleDeclaration[propertyName])
            }

            if(propertyName =="top" || propertyName == "left")
            {
                console.log(codeConstruct.loc.start.line + " - " + propertyName + this.getPropertyValue(propertyName, codeConstruct).jsValue)
            }

            return this.getPropertyValue(propertyName, codeConstruct);
        };

        this.addJsProperty = function(propertyName, value, codeConstruct)
        {
            this.cssStyleDeclaration[propertyName] = value.jsValue;
            this.addProperty(propertyName, value, codeConstruct);

            this.globalObject.dependencyCreator.createDataDependency(this.htmlElement.modelElement, codeConstruct, this.globalObject.getPreciseEvaluationPositionId());
            fcModel.HtmlElementExecutor.addDependencyIfImportantElement(this.htmlElement, this.globalObject, codeConstruct);
        };
    }
    catch(e)
    {
        fcModel.CSSStyleDeclaration.notifyError("Error when creating CSSStyleDeclaration " + e);
    }
};

fcModel.CSSStyleDeclaration.prototype = new fcModel.Object();

fcModel.CSSStyleDeclaration.createStyleDeclaration = function(htmlElement, cssStyleDeclaration, globalObject, codeConstruct)
{
    return new fcModel.fcValue
    (
        cssStyleDeclaration,
        new fcModel.CSSStyleDeclaration(htmlElement, cssStyleDeclaration, globalObject, codeConstruct),
        codeConstruct
    );
};

fcModel.CSSStyleDeclaration.notifyError =  function (message){debugger; alert("CSSStyleDeclaration - " + message); }

fcModel.CSSStyleDeclarationExecutor =
{
    executeInternalMethod: function(thisObject, functionObject, args, callExpression)
    {
        if(!functionObject.isInternalFunction) { fcModel.CSSStyleDeclaration.notifyError("The function should be internal when css declaration method!"); return; }

        var functionObjectValue = functionObject.jsValue;
        var thisObjectValue = thisObject.jsValue;
        var functionName = functionObjectValue.name;
        var fcThisValue =  thisObject.iValue;
        var globalObject = fcThisValue.globalObject;
        var jsArguments =  globalObject.getJsValues(args);

        switch(functionName)
        {
            case "getPropertyPriority":
            case "getPropertyValue":
            case "item":
                var result = thisObjectValue[functionName].apply(thisObjectValue, jsArguments);
                return globalObject.internalExecutor.createInternalPrimitiveObject(callExpression, result);
            case "removeProperty":
            case "setProperty":
            default:
                fcModel.CSSStyleDeclaration.notifyError("Unhandled internal method in cssStyleDeclaration:" + functionName);
                return;
        }
    }
};

fcModel.CSSStyleDeclaration.CONST =
{
    INTERNAL_PROPERTIES :
    {
        METHODS:
        [
            "getPropertyPriority", "getPropertyValue", "item", "removeProperty",
            "setProperty"
        ],
        PROPERTIES:
        [
            "cssText", "length", "parentRule",
            "background", "backgroundAttachment", "backgroundColor", "backgroundImage", "backgroundPosition","backgroundRepeat",
            "border","borderCollapse","borderColor","borderSpacing","borderStyle","borderTop","borderRight","borderBottom",
            "borderLeft","borderTopColor","borderRightColor","borderBottomColor","borderLeftColor","borderTopStyle","borderRightStyle",
            "borderBottomStyle","borderLeftStyle","borderTopWidth","borderRightWidth","borderBottomWidth","borderLeftWidth","borderWidth",
            "borderRadius","borderTopLeftRadius","borderTopRightRadius","borderBottomLeftRadius","borderBottomRightRadius","bottom",
            "boxShadow","captionSide","clear","clip","color","content","counterIncrement","counterReset","cursor",
            "direction","display","emptyCells","cssFloat","font","fontFamily","fontSize","fontSizeAdjust","fontStretch",
            "fontStyle","fontVariant","fontWeight","height","left","letterSpacing","lineHeight","listStyle","listStyleImage",
            "listStylePosition","listStyleType","margin","marginTop","marginRight","marginBottom","marginLeft","markerOffset",
            "marks","maxHeight","maxWidth","minHeight","minWidth","orphans","outline","outlineColor","outlineStyle","outlineWidth",
            "overflow","padding","paddingTop","paddingRight","paddingBottom","paddingLeft","page","pageBreakAfter","pageBreakBefore",
            "pageBreakInside","position","quotes","right","size","tableLayout","textAlign","textDecoration","textIndent","textOverflow",
            "textShadow","textTransform","top","unicodeBidi","verticalAlign","visibility","whiteSpace","widows","width","wordSpacing",
            "zIndex","clipPath","clipRule","colorInterpolation","colorInterpolationFilters","dominantBaseline","fill","fillOpacity",
            "fillRule","filter","floodColor","floodOpacity","imageRendering","lightingColor","marker","markerEnd","markerMid",
            "markerStart","mask","shapeRendering","stopColor","stopOpacity","stroke","strokeDasharray",
            "strokeDashoffset","strokeLinecap","strokeLinejoin","strokeMiterlimit","strokeOpacity","strokeWidth",
            "textAnchor","textRendering", "backgroundOrigin"
        ]
    }
};
}});FBL.ns(function() { with (FBL) {
/*************************************************************************************/
var fcModel = Firecrow.Interpreter.Model;
var ValueTypeHelper = Firecrow.ValueTypeHelper;

fcModel.DOM_PROPERTIES =
{
    DOCUMENT:
    {
        ELEMENT: ["activeElement", "body", "documentElement", "head", "mozFullScreenElement"],
        ELEMENTS: ["anchors", "embeds", "forms", "images", "links", "scripts"],
        PRIMITIVES:
        [
            "async", "characterSet", "compatMode", "contentType",
            "cookie", "designMode", "dir", "documentURI", "domain",
            "lastModified", "lastStyleSheetSet",
            "mozSyntheticDocument", "mozFullScreen", "mozFullScreenEnabled",
            "preferredStyleSheetSet", "readyState", "referrer", "selectedStyleSheetSet",
            "title", "URL", "vlinkColor"
        ],
        OTHER:
        [
            "defaultView", "location", "ownerDocument", "plugins", "readyState",
            "doctype", "implementation", "styleSheetSets", "styleSheets"
        ],
        METHODS:
        [
            "addEventListener", "adoptNode", "appendChild", "appendChild", "captureEvents",
            "cloneNode", "close", "compareDocumentPosition", "createAttribute", "createAttributeNS",
            "createCDATASection", "createComment", "createDocumentFragment", "createElement", "createElementNS",
            "createEvent", "createExpression", "createNSResolver", "createTextNode", "elementFromPoint",
            "getElementById", "getElementsByClassName", "getElementsByName", "getElementsByTagName",
            "hasAttributes", "hasChildNodes", "hasFocus", "importNode", "insertBefore", "isEqualNode", "isSameNode",
            "isSupported", "querySelector", "querySelectorAll", "removeChild", "releaseEvents", "removeEventListener",
            "replaceChild", "routeEvent", "write", "writeln", "open", "close", "execCommand"
        ],
        UNPREDICTED: {}
    },

    NODE:
    {
        ELEMENT: ["firstChild", "lastChild", "nextSibling", "previousSibling", "parentNode", "parentElement"],
        ELEMENTS:  ["childNodes"],
        PRIMITIVES:
        [
            "baseURI", "localName", "textContent", "namespaceURI", "nodeName",
            "nodeName", "nodeType", "nodeValue", "prefix", "childElementCount"
        ],
        OTHER: ["attributes", "ownerDocument"]
    },

    ELEMENT:
    {
        ELEMENT: ["firstElementChild", "lastElementChild", "nextElementSibling", "previousElementSibling", "form", "tHead", "tFoot", "offsetParent"],
        ELEMENTS: ["children", "elements", "options", "labels", "list", "rows", "tBodies", "cells"],
        PRIMITIVES:
        [
            "className", "clientHeight", "clientLeft", "clientTop",
            "clientWidth", "contentEditable", "id", "innerHTML",
            "isContentEditable", "lang", "name", "text",
            "offsetHeight", "offsetLeft", "offsetTop", "offsetWidth",
            "outerHTML", "scrollHeight", "scrollLeft", "scrollTop", "scrollWidth",
            "spellcheck", "tabIndex", "tagName", "textContent", "title",
            "charset", "disabled", "href", "hreflang", "media", "rel", "rev", "target", "type",
            "content", "httpEquiv", "scheme", "autocomplete", "action", "acceptCharset",
            "encoding", "enctype", "length", "method", "noValidate", "autofocus", "disabled",
            "multiple", "required", "selectedIndex", "size", "validationMessage", "willValidate",
            "accept", "alt", "checked", "defaultChecked", "defaultValue", "formAction", "formEncType",
            "formMethod", "formNoValidate", "formTarget", "height", "indeterminate", "max", "maxLength",
            "min", "multiple", "pattern", "placeholder", "readOnly", "src", "useMap", "validationMessage",
            "validity", "valueAsNumber", "width", "cols", "rows", "wrap", "value",
            "htmlFor", "hash", "coords", "host", "hreflang", "pathname", "port", "protocol", "rev", "search",
            "shape", "caption", "align", "bgColor", "border", "cellPadding", "cellSpacing", "frame", "rules",
            "summary", "ch", "chOff", "rowIndex", "sectionRowIndex", "vAlign", "rowSpan", "rowspan", "colspan", "colSpan"
        ],
        EVENT_PROPERTIES:
        [
            "oncopy", "oncut", "onpaste", "onbeforeunload", "onblur", "onchange", "onclick",
            "oncontextmenu", "ondblclick", "onfocus", "onkeydown", "onkeypress", "onkeyup",
            "onmousedown", "onmousemove", "onmouseout", "onmouseover", "onmouseup", "onresize",
            "onscroll", "onwheel", "click", "keydown", "keyup", "keypress", "touchstart", "touchend",
            "touchcancel", "touchleave", "touchmove", "ontouchstart", "ontouchend",
            "ontouchcancel", "ontouchleave", "ontouchmove", "selectstart", "onselectstart", "onmousewheel", "mousewheel"
        ],
        OTHER: ["dataset", "style", "classList", "files", "valueAsDate"]
    },

    isDocumentElement: function(propertyName) { return this._isPropertyOf(this.DOCUMENT.ELEMENT, propertyName); },
    isDocumentElements: function(propertyName) { return this._isPropertyOf(this.DOCUMENT.ELEMENTS, propertyName); },
    isDocumentPrimitives: function(propertyName) { return this._isPropertyOf(this.DOCUMENT.PRIMITIVES, propertyName); },
    isDocumentOther: function(propertyName) { return this._isPropertyOf(this.DOCUMENT.OTHER, propertyName); },
    isDocumentMethod: function(propertyName) { return this._isPropertyOf(this.DOCUMENT.METHODS, propertyName); },

    isNodeElement: function(propertyName) { return this._isPropertyOf(this.NODE.ELEMENT, propertyName); },
    isNodeElements: function(propertyName) { return this._isPropertyOf(this.NODE.ELEMENTS, propertyName); },
    isNodePrimitives: function(propertyName) { return this._isPropertyOf(this.NODE.PRIMITIVES, propertyName); },
    isNodeOther: function(propertyName) { return this._isPropertyOf(this.NODE.OTHER, propertyName); },

    isElementElement: function(propertyName) { return this._isPropertyOf(this.ELEMENT.ELEMENT, propertyName); },
    isElementElements: function(propertyName) { return this._isPropertyOf(this.ELEMENT.ELEMENTS, propertyName); },
    isElementPrimitives: function(propertyName) { return this._isPropertyOf(this.ELEMENT.PRIMITIVES, propertyName); },
    isElementOther: function(propertyName) { return this._isPropertyOf(this.ELEMENT.OTHER, propertyName); },
    isElementEventProperty: function(propertyName) { return this._isPropertyOf(this.ELEMENT.EVENT_PROPERTIES, propertyName);},


    _isPropertyOf: function(array, propertyName) { return array.indexOf(propertyName) != -1; },

    setPrimitives: function(fcObject, object, names)
    {
        for(var i = 0, length = names.length; i < length; i++)
        {
            var name = names[i];
            fcObject.addProperty(name, fcObject.globalObject.internalExecutor.createInternalPrimitiveObject(null, object[name]));
        }
    }
};
/*************************************************************************************/
}});FBL.ns(function() { with (FBL) {
/*************************************************************************************/
var fcModel = Firecrow.Interpreter.Model;

fcModel.SimpleXPath = function(xPathExpression)
{
    this.xPathExpression = xPathExpression;
};

fcModel.SimpleXPath.prototype =
{
    getCurrentTag: function()
    {
        var elementRegEx = new RegExp("^/([^/[])*");

        var match = this.xPathExpression.match(elementRegEx);

        if(match != null)
        {
            var matchedString = match[0];

            if(matchedString == null) { return ""; }

            if(matchedString.indexOf("/") == 0) { return matchedString.substring(1);}
        }

        return "";
    },

    getIndex: function()
    {
        var indexRegEx = new RegExp("\\[[^\\]]\\]");

        var currentTag = this.xPathExpression.substring((this.xPathExpression[0] === "/" ? 1 : 0));
        currentTag = currentTag.substring(0, currentTag.indexOf("/"));

        var match = currentTag.match(indexRegEx);

        if(match != null)
        {
            var matchedString = match[0];

            if(matchedString != null)
            {
                var result =  matchedString.replace(/\]$/, "").replace(/^\[/,"");

                if(result != "") { return result - 1; }
            }
        }

        return 0;
    },

    removeLevel: function()
    {
        var startsWithSlash = this.xPathExpression[0] === "/";
        var currentTag = this.xPathExpression.substring(startsWithSlash ? 1 : 0);
        var indexOfSlash = currentTag.indexOf("/");
        currentTag = currentTag.substring(0, indexOfSlash != -1 ? indexOfSlash : currentTag.length);

        this.xPathExpression = this.xPathExpression.substring(currentTag.length + (startsWithSlash ? 1 : 0));

        return this;
    },

    isEmpty: function() { return this.xPathExpression == ""; }
};
/*************************************************************************************/
}});FBL.ns(function() { with (FBL) {
/*************************************************************************************/
var fcModel = Firecrow.Interpreter.Model;
var ValueTypeHelper = Firecrow.ValueTypeHelper;
fcModel.EventListenerMixin =
{
    addEventListener: function(args, callExpression, globalObject)
    {
        try
        {
            if(args.length < 2) { fcModel.Object.notifyError("Too few arguments when executing addEventListener"); return; }
            if(this.eventListenerInfo == null) { this.eventListenerInfo = {}; }

            var eventTypeName = args[0].jsValue;
            var handler = args[1];

            if(this.eventListenerInfo[eventTypeName] == null) { this.eventListenerInfo[eventTypeName] = []; }

            this.eventListenerInfo[eventTypeName].push
            ({
                handler: handler,
                thisObject: this,
                registrationPoint:
                {
                    codeConstruct: callExpression,
                    evaluationPositionId: globalObject.getPreciseEvaluationPositionId()
                },
                eventType: eventTypeName
            });

            globalObject.registerHtmlElementEventHandler(this, eventTypeName, handler,
            {
                codeConstruct: callExpression,
                evaluationPositionId: globalObject.getPreciseEvaluationPositionId()
            });
        }
        catch(e) { fcModel.Object.notifyError("Error when adding event listener: " + e); }
    },

    removeEventListener: function(args, callExpression, globalObject)
    {
        try
        {
            if(args.length < 2) { fcModel.Object.notifyError("Too few arguments when executing addEventListener"); return;}
            if(this.eventListenerInfo == null) { this.eventListenerInfo = {}; }

            var eventTypeName = args[0].jsValue;
            var handler = args[1].jsValue;

            var eventHandlers = this.eventListenerInfo[eventTypeName];

            if(eventHandlers == null) { return; }

            for(var i = 0; i < eventHandlers.length; i++)
            {
                if(eventHandlers[i].handler === handler)
                {
                    ValueTypeHelper.removeFromArrayByIndex(eventHandlers, i);
                    i--;
                }
            }
        }
        catch(e) { fcModel.Object.notifyError ("Error when removing event listener: " + e); }
    },

    getEventListeners: function(eventName)
    {
        if(this.eventListenerInfo == null) { return []; }

        return this.eventListenerInfo[eventName] || [];
    }
};
/*************************************************************************************/
}});FBL.ns(function() { with (FBL) {
/*************************************************************************************/
var fcModel = Firecrow.Interpreter.Model;

fcModel.Event = function(implementationObject, globalObject, eventThisObject)
{
    try
    {
        this.initObject(globalObject, null, implementationObject);

        this.constructor = fcModel.Event;
        this.eventThisObject = eventThisObject;

        fcModel.Event.CONST.INTERNAL_PROPERTIES.METHODS.forEach(function(method)
        {
            this.addProperty(method, this.globalObject.internalExecutor.createInternalFunction
            (
                eval("(function " + method + "(){})"),
                method,
                this
            ));
        }, this);
    }
    catch(e) { fcModel.Event.notifyError("Error when creating Event: " + e); }
};

fcModel.Event.prototype = new fcModel.Object();

fcModel.Event.prototype.getJsPropertyValue = function (propertyName, codeConstruct)
{
    return this.getPropertyValue(propertyName, codeConstruct);
};

fcModel.Event.prototype.addJsProperty = function(propertyName, propertyValue, codeConstruct, isEnumerable)
{
    this.addProperty(propertyName, propertyValue, codeConstruct, isEnumerable);
};

fcModel.Event.notifyError = function(message) { alert("Event - " + message); }

fcModel.Event.CONST =
{
    INTERNAL_PROPERTIES:
    {
        METHODS: ["preventDefault", "stopPropagation", "stopImmediatePropagation"]
    }
};

fcModel.EventPrototype = function(globalObject)
{
    try
    {
        this.initObject(globalObject);
        this.constructor = fcModel.EventPrototype;
        this.name = "EventPrototype";
        fcModel.EventPrototype.CONST.INTERNAL_PROPERTIES.METHODS.forEach(function(propertyName)
        {
            if(Event.prototype[propertyName] == null) { return; }
            this.addProperty
            (
                propertyName,
                new fcModel.fcValue
                (
                    Event.prototype[propertyName],
                    fcModel.Function.createInternalNamedFunction(globalObject, propertyName, this),
                    null
                ),
                null,
                false
            );
        }, this);
    }
    catch(e) { fcModel.Event.notifyError("EventPrototype - error when creating date prototype:" + e); }
};

fcModel.EventPrototype.CONST =
{
    INTERNAL_PROPERTIES :
    {
        METHODS:
        [
            "initEvent", "preventDefault", "stopImmediatePropagation", "stopPropagation"
        ],
        PROPERTIES:
        [
            "bubbles", "cancelable", "currentTarget", "defaultPrevented", "eventPhase", "explicitOriginalTarget",
            "originalTarget", "target", "timeStamp", "type", "isTrusted"
        ]
    },
    FUNCTION_PROPERTIES:
    {
        METHODS:  ["now", "parse", "UTC"]
    }
};

fcModel.EventPrototype.prototype = new fcModel.Object(null);

fcModel.EventFunction = function(globalObject)
{
    try
    {
        this.initObject(globalObject);

        this.addProperty("prototype", globalObject.fcEventPrototype);

        this.isInternalFunction = true;
        this.name = "Event";
    }
    catch(e){ fcModel.Event.notifyError("Event - error when creating Event Function:" + e); }
};

fcModel.EventFunction.prototype = new fcModel.Object(null);

fcModel.EventExecutor =
{
    executeInternalMethod: function(thisObject, functionObject, args, callExpression)
    {
        if(!functionObject.isInternalFunction) { fcModel.Event.notifyError("The function should be internal when executing html method!"); return; }

        var functionObjectValue = functionObject.jsValue;
        var thisObjectValue = thisObject.jsValue;
        var functionName = functionObjectValue.name;
        var fcThisValue =  thisObject.iValue;
        var globalObject = fcThisValue.globalObject;
        var jsArguments =  globalObject.getJsValues(args);

        if(fcModel.Event.CONST.INTERNAL_PROPERTIES.METHODS.indexOf(functionName) == -1) { fcModel.Event.notifyError("Unhandled event method!"); return; }

        if(fcThisValue.eventThisObject != null && fcThisValue.eventThisObject.jsValue instanceof Element)
        {
            fcModel.HtmlElementExecutor.addDependencyIfImportantElement(fcThisValue.eventThisObject.jsValue, globalObject, callExpression);
        }
    }
}
}});/**
 * Created by Jomaras.
 * Date: 10.03.12.@09:04
 */
FBL.ns(function() { with (FBL) {
    /*************************************************************************************/
    var ValueTypeHelper = Firecrow.ValueTypeHelper;
    var ASTHelper = Firecrow.ASTHelper;
    var fcSimulator = Firecrow.Interpreter.Simulator;
    var fcModel = Firecrow.Interpreter.Model;

//<editor-fold desc="Variable Object">
    fcSimulator.VariableObject = function(executionContext)
    {
        this.executionContext = executionContext;
        this.identifiers = [];
    };

    fcSimulator.VariableObject.notifyError = function(message) { alert("VariableObject - " + message); };

    fcSimulator.VariableObject.prototype =
    {
        registerIdentifier: function(identifier)
        {
            if(!ValueTypeHelper.isOfType(identifier, fcModel.Identifier)) { fcSimulator.VariableObject.notifyError("When registering an identifier has to be passed"); return; }

            var existingIdentifier = this.getIdentifier(identifier.name);

            if(existingIdentifier == null)
            {
                this.identifiers.push(identifier);
            }
            else if(existingIdentifier.value != null && ASTHelper.isFunctionDeclaration(existingIdentifier.value.codeConstruct)
                &&  identifier.value != null && !ASTHelper.isFunction(identifier.value.codeConstruct))
            {
                //a variable declaration can not override a function declaration
            }
            else if(ASTHelper.isFunctionParameter(existingIdentifier.declarationPosition.codeConstruct)
                && ASTHelper.getFunctionParent(existingIdentifier.declarationPosition.codeConstruct) == ASTHelper.getFunctionParent(identifier.declarationPosition.codeConstruct))
            {
                //don't shadow if the existing identifier is a parameter from the function parent
            }
            else
            {
                existingIdentifier.setValue(identifier.value, identifier.lastModificationPosition.codeConstruct);
            }
        },

        getIdentifierValue: function(identifierName)
        {
            var identifier = this.getIdentifier(identifierName);

            return identifier != null ? identifier.value : null;
        },

        getIdentifier: function(identifierName)
        {
            return ValueTypeHelper.findInArray
            (
                this.identifiers,
                identifierName,
                function(currentIdentifier, identifierName)
                {
                    return currentIdentifier.name === identifierName;
                }
            );
        },

        deleteIdentifier: function(identifierName, codeConstruct)
        {
            var identifier = this.getIdentifier(identifierName);

            if(identifier != null)
            {
                ValueTypeHelper.removeFromArrayByElement(this.identifiers, identifier);
            }
        }
    };
//</editor-fold>

//<editor-fold desc="Variable Object Mixin">
    fcSimulator.VariableObjectMixin =
    {
        getIdentifier: function(identifierName) { return this.iValue.getProperty(identifierName); },

        getIdentifierValue: function(identifierName, readConstruct, currentContext)
        {
            return this.iValue.getPropertyValue(identifierName, readConstruct, currentContext);
        },

        registerIdentifier: function(identifier)
        {
            var existingProperty = this.iValue.getOwnProperty(identifier.name);

            //TODO - problem with overriding global properties - they are only overriden when an assignement
            //is performed, not when a variable is declared - this mixin is only used for the globalObject
            //so if a property already exists, don't override it
            if(existingProperty == null)
            {
                this.iValue.addProperty
                    (
                        identifier.name,
                        identifier.value,
                        identifier.declarationPosition != null ? identifier.declarationPosition.codeConstruct : null
                    );
            }
        },

        deleteIdentifier: function(identifierName, deleteConstruct)
        {
            this.iValue.deleteProperty(identifierName, deleteConstruct);
        }
    };
//</editor-fold>

//<editor-fold desc="'Static' methods">
    fcSimulator.VariableObject.createFunctionVariableObject = function(functionIdentifier, formalParameters, calleeFunction, sentArguments, callCommand, globalObject)
    {
        try
        {
            var functionVariableObject = new fcSimulator.VariableObject(null);

            functionVariableObject.functionIdentifier = functionIdentifier;
            functionVariableObject.formalParameters = formalParameters;
            functionVariableObject.calleeFunction = calleeFunction;
            functionVariableObject.sentArguments = sentArguments;

            var callConstruct = callCommand != null ? callCommand.codeConstruct : null;

            this._registerArgumentsVariable(functionVariableObject, callConstruct, sentArguments, globalObject);

            if(functionIdentifier != null) { functionVariableObject.registerIdentifier(functionIdentifier); }
            if(formalParameters != null) { this._registerFormalParameters(formalParameters, functionVariableObject, sentArguments, this._getArgumentsConstructs(callCommand, callConstruct, sentArguments));}

            return functionVariableObject;
        }
        catch(e) { fcSimulator.VariableObject.notifyError("Error while creating function variable object: " + e + " " + e.fileName + " " + e.lineNumber); }
    };

    fcSimulator.VariableObject._registerArgumentsVariable = function(functionVariableObject, callConstruct, sentArguments, globalObject)
    {
        var argumentsValue = globalObject.internalExecutor.createNonConstructorObject(callConstruct);

        for(var i = 0; i < sentArguments.length;i++)
        {
            argumentsValue.iValue.addProperty(i +"", sentArguments[i], callConstruct);
            argumentsValue.jsValue[i] = sentArguments[i];
        }

        var length = globalObject.internalExecutor.createInternalPrimitiveObject(callConstruct, sentArguments.length);

        argumentsValue.iValue.addProperty("length", length, callConstruct);
        Object.defineProperty(argumentsValue.jsValue, "length", { enumerable: false, value: sentArguments.length, writable:true, configurable:true});

        argumentsValue.iValue.addProperty("callee", functionVariableObject.calleeFunction, callConstruct, false);
        Object.defineProperty(argumentsValue.jsValue, "callee", { enumerable: false, value: functionVariableObject.calleeFunction});
        /*var argumentsValue = globalObject.internalExecutor.createArray(callConstruct, sentArguments);

        argumentsValue.jsValue.callee = functionVariableObject.calleeFunction;
        argumentsValue.iValue.addProperty("callee", functionVariableObject.calleeFunction, callConstruct, false);
        argumentsValue.iValue.removePrototypeMethods(); */

        functionVariableObject.registerIdentifier
        (
            new fcModel.Identifier
            (
                "arguments",
                argumentsValue,
                callConstruct != null ? callConstruct.arguments : null,
                globalObject
            )
        );
    };

    fcSimulator.VariableObject._getArgumentsConstructs = function(callCommand, callConstruct, sentArguments)
    {
        var argumentsConstruct = callConstruct != null ? callConstruct.arguments : [];

        if(callCommand != null)
        {
            if(callCommand.isCall)
            {
                argumentsConstruct = callConstruct.arguments.slice(1);
            }
            else if (callCommand.isApply)
            {
                var argumentsArray = callConstruct.arguments[1];

                argumentsConstruct = [];

                for(var i = 0; i < sentArguments.length; i++)
                {
                    argumentsConstruct.push(argumentsArray);
                }
            }
        }

        return argumentsConstruct || [];
    };

    fcSimulator.VariableObject._registerFormalParameters = function(formalParameters, functionVariableObject, sentArguments, argumentConstructs)
    {
        if(sentArguments == null) { debugger; }

        for(var i = 0; i < formalParameters.length; i++)
        {
            var formalParameter = formalParameters[i];

            functionVariableObject.registerIdentifier(formalParameter);

            formalParameter.setValue
                (
                    sentArguments[i] || new fcModel.fcValue(undefined, undefined, formalParameter.declarationPosition != null ? formalParameter.declarationPosition.codeConstruct : null),
                    argumentConstructs[i]
                );
        }
    }

    fcSimulator.VariableObject.liftToVariableObject = function(object)
    {
        if(object == null || object.iValue == null) { fcSimulator.VariableObject.notifyError("Can not lift object to variable object:"); };

        ValueTypeHelper.expand(object, fcSimulator.VariableObjectMixin);

        return object;
    };
//</editor-fold>
    /***************************************************************************************/
}});FBL.ns(function() { with (FBL) {
/*************************************************************************************/
var ValueTypeHelper = Firecrow.ValueTypeHelper;
var fcModel = Firecrow.Interpreter.Model;
var fcSimulator = Firecrow.Interpreter.Simulator;
var ASTHelper = Firecrow.ASTHelper;

fcSimulator.InternalExecutor = function(globalObject)
{
    this.globalObject = globalObject;
    this.dependencyCreator = new fcSimulator.DependencyCreator(this.globalObject);
};

fcSimulator.InternalExecutor.notifyError = function(message) { debugger; alert("InternalExecutor - " + message);}

fcSimulator.InternalExecutor.prototype =
{
    createObject: function(constructorFunction, creationCodeConstruct, argumentValues)
    {
        if(this._isNonConstructorObjectCreation(constructorFunction, creationCodeConstruct)) { return this.createNonConstructorObject(creationCodeConstruct); }
        else if(this._isUserConstructorObjectCreation(constructorFunction)) { return this._createObjectFromUserFunction(constructorFunction, creationCodeConstruct, argumentValues); }
        else if (this.isInternalConstructor(constructorFunction)) { return this.executeInternalConstructor(creationCodeConstruct, constructorFunction, argumentValues); }
        else { console.log(Firecrow.CodeTextGenerator.generateJsCode(creationCodeConstruct)); this.notifyError("Unknown state when creating object"); return null; }
    },

    createInternalPrimitiveObject: function(codeConstruct, value, symbolicValue)
    {
        var result = null;

        if(typeof value == "string") { result = new fcModel.String(value, this.globalObject, codeConstruct, true); }
        else if(typeof value == "number") { result = new fcModel.Number(value, this.globalObject, codeConstruct, true); }
        else if(typeof value == "boolean") { result = new fcModel.Boolean(value, this.globalObject, codeConstruct, true); }
        else if(value == null) { }
        else { this.notifyError("Unknown primitive object: " + value); }

        return new fcModel.fcValue(value, result, codeConstruct, symbolicValue);
    },

    createNonConstructorObject: function(creationCodeConstruct, baseObject)
    {
        baseObject = baseObject || {};

        return new fcModel.fcValue
        (
            baseObject,
            fcModel.Object.createObjectWithInit(this.globalObject, creationCodeConstruct, baseObject, this.globalObject.fcObjectPrototype),
            creationCodeConstruct
        );
    },

    createFunction: function(scopeChain, functionConstruct)
    {
        var newFunction = functionConstruct.id != null ? eval("(function " + functionConstruct.id.name + "(){})")
                                                          : function(){};

        var fcFunction = new fcModel.Function(this.globalObject, scopeChain, functionConstruct, newFunction);
        var fcValue = new fcModel.fcValue(newFunction, fcFunction,functionConstruct);

        fcFunction.getPropertyValue("prototype").iValue.addProperty("constructor", fcValue, functionConstruct, false);

        if(functionConstruct.id != null)
        {
            fcFunction.addProperty("name", this.globalObject.internalExecutor.createInternalPrimitiveObject(functionConstruct, functionConstruct.id.name));
        }

        return fcValue;
    },

    createInternalFunction: function(functionObject, functionName, parentObject, dontExpandCallApply)
    {
        return new fcModel.fcValue
        (
            functionObject,
            fcModel.Function.createInternalNamedFunction(this.globalObject, functionName, parentObject),
            null
        );
    },

    createArray: function(creationConstruct, existingArray)
    {
        var array = existingArray || [];

        return new fcModel.fcValue(array, new fcModel.Array(array, this.globalObject, creationConstruct), creationConstruct);
    },

    createRegEx: function(creationConstruct, regEx)
    {
        return new fcModel.fcValue(regEx, new fcModel.RegEx(regEx, this.globalObject, creationConstruct), creationConstruct);
    },


    createString: function(creationConstruct, string)
    {
        return new fcModel.fcValue(string, new fcModel.String(string, this.globalObject, creationConstruct, false), creationConstruct);
    },

    createHtmlElement: function(creationConstruct, tagName)
    {
        try
        {
            var jsElement = this.globalObject.origDocument.createElement(tagName);
        }
        catch(e)
        {
            this.globalObject.executionContextStack.callExceptionCallbacks
            ({
                exceptionGeneratingConstruct: creationConstruct,
                isDomStringException: true
            });

            return;
        }

        jsElement.modelElement = { type: "DummyCodeElement", domElement: jsElement, nodeId: "D" + this.globalObject.DYNAMIC_NODE_COUNTER++ };
        this.globalObject.browser.callNodeCreatedCallbacks(jsElement.modelElement, "html", true);

        jsElement.creationPoint =
        {
            codeConstruct: creationConstruct,
            evaluationPositionId: this.globalObject.getPreciseEvaluationPositionId()
        };

        var fcHtmlElement = new fcModel.HtmlElement(jsElement, this.globalObject, creationConstruct);

        if(ValueTypeHelper.isImageElement(jsElement))
        {
            fcHtmlElement.addProperty("__proto__", this.globalObject.fcHtmlImagePrototype);
        }

        this.globalObject.dependencyCreator.createDataDependency(creationConstruct, jsElement.modelElement, this.globalObject.getPreciseEvaluationPositionId());

        return new fcModel.fcValue(jsElement, fcHtmlElement, creationConstruct);
    },

    createTextNode: function(creationConstruct, textContent)
    {
        var jsTextNode = this.globalObject.origDocument.createTextNode(textContent);

        return new fcModel.fcValue(jsTextNode, new fcModel.TextNode(jsTextNode, this.globalObject, creationConstruct), creationConstruct);
    },

    createDocumentFragment: function(creationConstruct, tagName)
    {
        var jsElement = this.globalObject.origDocument.createDocumentFragment();

        jsElement.creationPoint =
        {
            codeConstruct: creationConstruct,
            evaluationPositionId: this.globalObject.getPreciseEvaluationPositionId()
        };

        jsElement.modelElement = { type: "DummyCodeElement", domElement: jsElement, nodeId: "D" + this.globalObject.DYNAMIC_NODE_COUNTER++ };

        this.globalObject.browser.callNodeCreatedCallbacks(jsElement.modelElement, "html", false);

        return new fcModel.fcValue(jsElement, new fcModel.HtmlElement(jsElement, this.globalObject, creationConstruct), creationConstruct);
    },

    createLocationObject: function()
    {
        var fcLocation = fcModel.Object.createObjectWithInit(this.globalObject, null, location);

        this._createProperty(fcLocation, "hash", this.globalObject.origWindow.location.hash);
        this._createProperty(fcLocation, "host", this.globalObject.origWindow.location.host);
        this._createProperty(fcLocation, "hostname", this.globalObject.origWindow.location.hostname);
        this._createProperty(fcLocation, "href", this.globalObject.origWindow.location.href);
        this._createProperty(fcLocation, "pathname", this.globalObject.origWindow.location.pathname);
        this._createProperty(fcLocation, "port", this.globalObject.origWindow.location.port);
        this._createProperty(fcLocation, "protocol", this.globalObject.origWindow.location.protocol);
        this._createProperty(fcLocation, "search", this.globalObject.origWindow.location.search);

        return new fcModel.fcValue(location, fcLocation, null);
    },

    createScreenObject: function()
    {
        var fcScreen = fcModel.Object.createObjectWithInit(this.globalObject, null, this.globalObject.origWindow.screen);

        this._createProperty(fcScreen, "availTop", this.globalObject.origWindow.screen.availTop);
        this._createProperty(fcScreen, "availLeft", this.globalObject.origWindow.screen.availLeft);
        this._createProperty(fcScreen, "availHeight", this.globalObject.origWindow.screen.availHeight);
        this._createProperty(fcScreen, "availWidth", this.globalObject.origWindow.screen.availWidth);
        this._createProperty(fcScreen, "colorDepth", this.globalObject.origWindow.screen.colorDepth);
        this._createProperty(fcScreen, "height", this.globalObject.origWindow.screen.height);
        this._createProperty(fcScreen, "left", this.globalObject.origWindow.screen.left);
        this._createProperty(fcScreen, "pixelDepth", this.globalObject.origWindow.screen.pixelDepth);
        this._createProperty(fcScreen, "top", this.globalObject.origWindow.screen.top);
        this._createProperty(fcScreen, "width", this.globalObject.origWindow.screen.width);

        return new fcModel.fcValue(this.globalObject.origWindow.screen, fcScreen, null);
    },

    createNavigatorObject: function()
    {
        var fcNavigator = fcModel.Object.createObjectWithInit(this.globalObject, null, navigator);

        this._createProperty(fcNavigator, "appCodeName", this.globalObject.origWindow.navigator.appCodeName);
        this._createProperty(fcNavigator, "appName", this.globalObject.origWindow.navigator.appName);
        this._createProperty(fcNavigator, "appVersion", this.globalObject.origWindow.navigator.appVersion);
        this._createProperty(fcNavigator, "buildID", this.globalObject.origWindow.navigator.buildID);
        this._createProperty(fcNavigator, "cookieEnabled", this.globalObject.origWindow.navigator.cookieEnabled);
        this._createProperty(fcNavigator, "doNotTrack", this.globalObject.origWindow.navigator.doNotTrack);
        this._createProperty(fcNavigator, "language", this.globalObject.origWindow.navigator.language);
        this._createProperty(fcNavigator, "oscpu", this.globalObject.origWindow.navigator.oscpu);
        this._createProperty(fcNavigator, "platform", this.globalObject.origWindow.navigator.platform);
        this._createProperty(fcNavigator, "product", this.globalObject.origWindow.navigator.product);
        this._createProperty(fcNavigator, "productSub", this.globalObject.origWindow.navigator.productSub);
        this._createProperty(fcNavigator, "userAgent", this.globalObject.origWindow.navigator.userAgent);
        this._createProperty(fcNavigator, "taintEnabled", true);//TODO HACK
        this._createProperty(fcNavigator, "plugins", this._createPluginsArray(), this.globalObject.origWindow.navigator.plugins);

        return new fcModel.fcValue(navigator, fcNavigator);
    },

    _createPluginsArray: function()
    {
        var pluginsArrayObject = fcModel.Object.createObjectWithInit(this.globalObject, null, this.globalObject.origWindow.navigator.plugins);

        for(var propName in navigator.plugins)
        {
            if(navigator.plugins[propName] instanceof Plugin)
            {
                this._createProperty(pluginsArrayObject, propName, this._createPluginInfo(navigator.plugins[propName]));
            }
        }

        var flashPlugin = navigator.plugins["Shockwave Flash"];
        if(flashPlugin == null)
        {
            flashPlugin = { description: "0 r0", filename: "Flash", name:"Flash", version: 0};
        }

        this._createProperty(pluginsArrayObject, 'Shockwave Flash', this._createPluginInfo(flashPlugin), flashPlugin);
        this._createProperty(pluginsArrayObject, "length", navigator.plugins.length);

        return pluginsArrayObject;
    },

    _createPluginInfo: function(plugin)
    {
        plugin = plugin || {};
        var pluginValue = fcModel.Object.createObjectWithInit(this.globalObject, null, plugin);

        this._createProperty(pluginValue, "description", plugin.description);
        this._createProperty(pluginValue, "filename", plugin.filename);
        this._createProperty(pluginValue, "name", plugin.name);
        this._createProperty(pluginValue, "version", plugin.version);
        return pluginValue;
    },

    _createProperty: function(baseObject, propertyName, propertyValue, jsValue)
    {
        if(ValueTypeHelper.isPrimitive(propertyValue))
        {
            baseObject.addProperty(propertyName, this.globalObject.internalExecutor.createInternalPrimitiveObject(null, propertyValue));
        }
        else
        {
            baseObject.addProperty(propertyName, new fcModel.fcValue(jsValue, propertyValue));
        }
    },

    executeFunction: function(thisObject, functionObject, args, callExpression, callCommand)
    {
        try
        {
            if(thisObject == null) { this.notifyError("This object can not be null when executing function!"); return; }

                 if (callCommand.isCall || callCommand.isApply) { return this._executeCallApplyFunction(thisObject, functionObject, args, callExpression, callCommand); }
            else if (thisObject == this.globalObject.fcMath || functionObject.isMathFunction) { return fcModel.MathExecutor.executeInternalMethod(thisObject, functionObject, args, callExpression); }
            else if (thisObject.iValue != null && thisObject.iValue.constructor == fcModel.Array) { return fcModel.ArrayExecutor.executeInternalArrayMethod(thisObject, functionObject, args, callExpression, callCommand); }
            else if (thisObject == this.globalObject.fcObjectFunction) { return fcModel.ObjectExecutor.executeInternalObjectFunctionMethod(thisObject, functionObject, args, callExpression, callCommand); }
            else if (ValueTypeHelper.isString(thisObject.jsValue)) { return fcModel.StringExecutor.executeInternalStringMethod(thisObject, functionObject, args, callExpression, callCommand); }
            else if (thisObject.iValue != null && thisObject.iValue.constructor == fcModel.RegEx) { return fcModel.RegExExecutor.executeInternalRegExMethod(thisObject, functionObject, args, callExpression); }
            else if (thisObject.iValue != null && thisObject.iValue.constructor == fcModel.XMLHttpRequest) { return fcModel.XMLHttpRequestExecutor.executeInternalXmlHttpRequestMethod(thisObject, functionObject, args, callExpression); }
            else if (thisObject == this.globalObject.jsFcDocument){ return fcModel.DocumentExecutor.executeInternalMethod(thisObject, functionObject, args, callExpression);}
            else if (ValueTypeHelper.isHtmlElement(thisObject.jsValue) || ValueTypeHelper.isDocumentFragment(thisObject.jsValue) || ValueTypeHelper.isTextNode(thisObject.jsValue)) { return fcModel.HtmlElementExecutor.executeInternalMethod(thisObject, functionObject, args, callExpression); }
            else if (thisObject.iValue.constructor == fcModel.CSSStyleDeclaration) { return fcModel.CSSStyleDeclarationExecutor.executeInternalMethod(thisObject, functionObject, args, callExpression); }
            else if (thisObject.iValue != null && thisObject.iValue.constructor == fcModel.Date) { return fcModel.DateExecutor.executeInternalDateMethod(thisObject, functionObject, args, callExpression); }
            else if (thisObject.jsValue == this.globalObject.dateFunction) { return fcModel.DateExecutor.executeFunctionMethod(thisObject, functionObject, args, callExpression, this.globalObject); }
            else if (thisObject.iValue != null && thisObject.iValue.constructor == fcModel.Event){ return fcModel.EventExecutor.executeInternalMethod(thisObject, functionObject, args, callExpression); }
            else if (thisObject.iValue != null && thisObject.iValue.constructor == fcModel.CanvasContext){ return fcModel.CanvasContextExecutor.executeInternalMethod(thisObject, functionObject, args, callExpression); }
            else if (thisObject.iValue != null && thisObject.iValue.constructor == fcModel.LinearGradient){ return fcModel.LinearGradientExecutor.executeInternalMethod(thisObject, functionObject, args, callExpression); }
            else if (thisObject.iValue != null && thisObject.iValue.constructor == fcModel.CanvasGradient){ return fcModel.CanvasGradientExecutor.executeInternalMethod(thisObject, functionObject, args, callExpression); }
            else if (thisObject == this.globalObject.fcArrayFunction) { return fcModel.ArrayExecutor.executeInternalArrayMethod(args[0], functionObject, args.slice(1, args.length), callExpression, callCommand); }
            else if (thisObject == this.globalObject.fcStringFunction) { return fcModel.StringExecutor.executeInternalStringFunctionMethod(thisObject, functionObject, args, callExpression, callCommand); }
            else if (functionObject.isInternalFunction) { return this._executeInternalFunction(thisObject, functionObject, args, callExpression, callCommand); }
            else
            {
                this.notifyError("Unsupported internal function!");
            }
        }
        catch(e)
        {
            this.notifyError("Error when executing internal function: " + e + " " + e.fileName + " " + e.lineNumber + " " + this.globalObject.browser.url
                            + " on code expression @ " + (callExpression != null && callExpression.loc != null ? callExpression.loc.start.line : "?")
                            + " code:" + Firecrow.gen(callExpression)
                            + e.stack);
        }
    },

    _isNonConstructorObjectCreation: function(constructorFunction, creationCodeConstruct)
    {
        return constructorFunction == null && (ASTHelper.isObjectExpression(creationCodeConstruct) || creationCodeConstruct == null);
    },

    _isUserConstructorObjectCreation: function(constructorFunction)
    {
        try
        {
            return ValueTypeHelper.isFunction(constructorFunction.jsValue) && !constructorFunction.isInternalFunction;
        }
        catch(e) { debugger;}
    },

    isInternalConstructor: function(constructorFunction)
    {
        return constructorFunction != null && constructorFunction.isInternalFunction;
    },

    _createObjectFromUserFunction: function(constructorFunction, creationCodeConstruct, argumentValues)
    {
        var newObject = new constructorFunction.jsValue();

        this.dependencyCreator.createDependencyToConstructorPrototype(creationCodeConstruct, constructorFunction);

        return new fcModel.fcValue
        (
            newObject,
            fcModel.Object.createObjectWithInit
            (
                this.globalObject,
                creationCodeConstruct,
                newObject,
                constructorFunction.iValue.getPropertyValue("prototype")
            ),
            creationCodeConstruct
        );
    },

    executeInternalConstructor: function(constructorConstruct, internalConstructor, args)
    {
        if(internalConstructor == null) { this.notifyError("InternalConstructor can not be null!"); return; }

        var jsArgs = this.globalObject.getJsValues(args);

        if(internalConstructor.iValue == this.globalObject.arrayFunction) { return this.createArray(constructorConstruct, Array.apply(null, args.length <= 1 ? jsArgs : args));}
        else if (internalConstructor.iValue == this.globalObject.regExFunction) { return this.createRegEx(constructorConstruct, RegExp.apply(null, jsArgs));}
        else if (internalConstructor.iValue == this.globalObject.stringFunction) { return this.createString(constructorConstruct, String.apply(null, jsArgs));}
        else if (internalConstructor.iValue == this.globalObject.booleanFunction) { return new fcModel.fcValue(Boolean.apply(null, jsArgs), Boolean.apply(null, jsArgs), constructorConstruct); }
        else if (internalConstructor.iValue == this.globalObject.numberFunction) { return new fcModel.fcValue(Number.apply(null, jsArgs), Number.apply(null, jsArgs), constructorConstruct); }
        else if (internalConstructor.iValue == this.globalObject.objectFunction) { return fcModel.ObjectExecutor.executeInternalConstructor(constructorConstruct, args, this.globalObject);}
        else if (internalConstructor.iValue == this.globalObject.dateFunction) { return fcModel.DateExecutor.executeInternalConstructor(constructorConstruct, args, this.globalObject); }
        else if (internalConstructor.iValue == this.globalObject.imageFunction) { return this._createImageObject(constructorConstruct); }
        else if (internalConstructor.iValue == this.globalObject.xmlHttpRequestFunction) { return this._createXMLHttpRequestObject(constructorConstruct, new XMLHttpRequest()); }
        else if (internalConstructor.iValue == this.globalObject.errorFunction) { return this._createErrorObject(constructorConstruct, Error.apply(null, jsArgs), this.globalObject); }
        else
        {
            this.notifyError("Unhandled internal constructor" + constructorConstruct.loc.start.line);
            return;
        }
    },

    _createImageObject: function(constructorConstruct)
    {
        return this.createHtmlElement(constructorConstruct, "IMG");
    },

    _createErrorObject: function(constructorConstruct, errorObject, globalObject)
    {
        return new fcModel.fcValue(errorObject, new fcModel.Error(errorObject, globalObject, constructorConstruct), constructorConstruct, null);
    },

    _createXMLHttpRequestObject: function(creationConstruct, xmlHttpRequest)
    {
        return new fcModel.fcValue(xmlHttpRequest, new fcModel.XMLHttpRequest(xmlHttpRequest, this.globalObject, creationConstruct), creationConstruct);
    },

    createEmptyObject: function(constructorConstruct)
    {
        var obj = {};
        return new fcModel.fcValue(obj, fcModel.Object.createObjectWithInit(this.globalObject, constructorConstruct, obj), constructorConstruct);
    },

    _executeCallApplyFunction: function(thisObject, functionObject, args, callExpression, callCommand)
    {
        var ownerObject = functionObject.iValue.ownerObject;

             if (ownerObject == this.globalObject.arrayPrototype) { return fcModel.ArrayExecutor.executeInternalArrayMethod(thisObject, functionObject, args, callExpression, callCommand); }
        else if (ownerObject == this.globalObject.regExPrototype) { return fcModel.RegExExecutor.executeInternalRegExMethod(thisObject, functionObject, args, callExpression); }
        else if (ownerObject == this.globalObject.math) { return fcModel.MathExecutor.executeInternalMethod(thisObject, functionObject, args, callExpression); }
        else if (ownerObject == this.globalObject.objectPrototype) { return fcModel.ObjectExecutor.executeInternalMethod(thisObject, functionObject, args, callExpression, callCommand); }
        else if (ownerObject == this.globalObject.stringPrototype) { return fcModel.StringExecutor.executeInternalStringMethod(thisObject, functionObject, args, callExpression, callCommand); }
        else if (ownerObject == this.globalObject.functionPrototype && functionObject.iValue.name == "bind") { return this._executeBindFunction(thisObject, args[0], args, callExpression); }
        else if (ownerObject.constructor == fcModel.HtmlElement) { return fcModel.HtmlElementExecutor.executeInternalMethod(thisObject, functionObject, args, callExpression); }
        else if (ownerObject.name == "CanvasContextPrototype")
        {
            return fcModel.CanvasExecutor.executeCanvasMethod(thisObject, functionObject, args, callExpression)
        }
        else
        {
            this.notifyError("Unhandled call applied internal method: " + callExpression.loc.source);
        }
    },

    _executeInternalFunction: function(thisObject, functionObject, args, callExpression, callCommand)
    {
             if (functionObject.jsValue == this.globalObject.arrayFunction) { return this.createArray(callExpression, Array.apply(null, args)); }
        else if (functionObject.jsValue == this.globalObject.regExFunction) { return this.createRegEx(callExpression, Array.apply(null, this.globalObject.getJsValues(args))); }
        else if (functionObject.jsValue == toString) { return fcModel.ObjectExecutor.executeInternalMethod(thisObject, functionObject, args, callExpression, callCommand); }
        else if (functionObject.jsValue != null && functionObject.jsValue.name == "hasOwnProperty") { return fcModel.ObjectExecutor.executeInternalMethod(thisObject, functionObject, args, callExpression); }
        else if (fcModel.ArrayExecutor.isInternalArrayMethod(functionObject.jsValue))  { return fcModel.ArrayExecutor.executeInternalArrayMethod(thisObject, functionObject, args, callExpression, callCommand); }
        else if (fcModel.StringExecutor.isInternalStringFunctionMethod(functionObject.jsValue))  { return this._executeInternalStringFunctionMethod(thisObject, functionObject, args, callExpression, callCommand); }
        else if (fcModel.ObjectExecutor.isInternalObjectMethod(functionObject.jsValue)) { return this._executeInternalObjectFunctionMethod(thisObject, functionObject, args, callExpression, callCommand); }
        else if (fcModel.MathExecutor.isInternalMathMethod(functionObject.jsValue)) { return this._executeInternalMathMethod(thisObject, functionObject, args, callExpression, callCommand); }
        else if (fcModel.GlobalObjectExecutor.executesFunction(this.globalObject, functionObject.jsValue.name)) { return fcModel.GlobalObjectExecutor.executeInternalFunction(functionObject, args, callExpression, this.globalObject); }
        else if (functionObject.jsValue.name == "bind") { return this._executeBindFunction(thisObject, functionObject, args, callExpression); }
        else
        {
            debugger;
            this.notifyError("Unknown internal function!");
        }
    },

    _executeInternalStringFunctionMethod: function(thisObject, functionObject, args, callExpression, callCommand)
    {
        //This is a hack when an internal callback function gets another internal function as an argument
        if(args.length == 0 && callCommand.parentCallExpressionCommand != null && callCommand.parentCallExpressionCommand.arguments != null)
        {
            args = callCommand.parentCallExpressionCommand.arguments || [];
            var returnValue = fcModel.StringExecutor.executeInternalStringMethod(args[0], functionObject, args, callExpression, callCommand);
            fcModel.ArrayCallbackEvaluator.evaluateCallbackReturn(callCommand.parentCallExpressionCommand, returnValue, null);
            return returnValue;
        }

        return fcModel.StringExecutor.executeInternalStringMethod(thisObject, functionObject, args, callExpression, callCommand);
    },

    _executeInternalMathMethod: function(thisObject, functionObject, args, callExpression, callCommand)
    {
        return fcModel.MathExecutor.executeInternalMethod(thisObject, functionObject, args, callExpression);
    },

    _executeInternalObjectFunctionMethod: function(thisObject, functionObject, args, callExpression, callCommand)
    {
        return fcModel.ObjectExecutor.executeInternalObjectFunctionMethod(thisObject, functionObject, args, callExpression, callCommand);
    },

    _executeBindFunction: function(thisObject, functionObject, args, callExpression)
    {
        var functionCopy = this.createFunction(thisObject.iValue.scopeChain, thisObject.codeConstruct);

        functionCopy.iValue.bind(args, callExpression);

        return functionCopy;
    },

    notifyError: function(message) { debugger; Firecrow.Interpreter.Simulator.InternalExecutor.notifyError(message);}
}
}});/**
 * Created by Jomaras.
 * Date: 08.03.12.@19:13
 */
FBL.ns(function() { with (FBL) {
    /*************************************************************************************/
    var ValueTypeHelper = Firecrow.ValueTypeHelper;
    var ASTHelper = Firecrow.ASTHelper;
    var fcSimulator = Firecrow.Interpreter.Simulator;
    var fcCommands = Firecrow.Interpreter.Commands;
    var fcModel = Firecrow.Interpreter.Model;

//<editor-fold desc="Execution Context">
    fcSimulator.ExecutionContext = function(variableObject, scopeChain, thisObject, globalObject, contextCreationCommand)
    {
        try
        {
            this.id = fcSimulator.ExecutionContext.LAST_ID++;

            this.variableObject = variableObject || globalObject.globalVariableObject;
            this.thisObject = thisObject || globalObject;

            if(this.thisObject != globalObject && !(this.thisObject instanceof fcModel.fcValue))
            {
                this.thisObject = new fcModel.fcValue(this.thisObject.implementationObject, thisObject);
            }

            this.globalObject = globalObject;

            this.scopeChain = ValueTypeHelper.createArrayCopy(scopeChain);
            this.scopeChain.push(this.variableObject);

            this.codeConstructValuesMapping = {};
            this.labelsMapping = {};
            this.commands = [];

            this.contextCreationCommand = contextCreationCommand;
        }
        catch(e) { fcSimulator.ExecutionContext.notifyError("Error when constructing execution context: " + e); }
    };

    fcSimulator.ExecutionContext.createGlobalExecutionContext = function(globalObject)
    {
        return new fcSimulator.ExecutionContext(globalObject, [], globalObject, globalObject);
    };

    fcSimulator.ExecutionContext.LAST_ID = 0;
    fcSimulator.ExecutionContext.notifyError = function(message) { alert("ExecutionContextStack - " + message);}

    fcSimulator.ExecutionContext.prototype =
    {
        getCodeConstructValue: function(codeConstruct)
        {
            if(codeConstruct == null) { return null;}

            return this.codeConstructValuesMapping[codeConstruct.nodeId];
        },

        setCodeConstructValue: function(codeConstruct, value)
        {
            if(codeConstruct == null) { return null; }

            this.codeConstructValuesMapping[codeConstruct.nodeId] = value
        },

        registerIdentifier: function(identifier)
        {
            this.variableObject.registerIdentifier(identifier);
        },

        pushToScopeChain: function(variableObject)
        {
            this.scopeChain.push(variableObject);
        },

        popFromScopeChain: function()
        {
            return this.scopeChain.pop();
        },

        destruct: function()
        {
            delete this.variableObject;
            delete this.thisObject;

            delete this.globalObject;

            delete this.scopeChain;

            delete this.codeConstructValuesMapping;
            delete this.commands;
        },

        logLabel: function(labelConstruct)
        {
            if(labelConstruct == null) { return; }

            this.labelsMapping[labelConstruct.nodeId] = labelConstruct;
        }
    };
//</editor-fold>

    fcSimulator.ExecutionContextStack = function(globalObject, handlerInfo)
    {
        try
        {
            if(globalObject == null) { this.notifyError("GlobalObject can not be null when constructing execution context stack!"); return; }

            this.globalObject = globalObject;
            this.globalObject.executionContextStack = this;

            this.activeContext = null;
            this.stack = [];

            this.exceptionCallbacks = [];
            this.blockCommandStack = [];
            this.functionContextCommandsStack = [{functionContextBlockCommandsEvalPositions:[]}];

            this.dependencyCreator = new fcSimulator.DependencyCreator(globalObject, this);

            this.evaluator = new fcSimulator.Evaluator(this);
            this.evaluator.registerExceptionCallback(this._exceptionCallback, this);

            this._enterInitialContext(handlerInfo);
        }
        catch(e) { debugger; this.notifyError("Error when constructing executionContextStack: " + e); }
    };

    fcSimulator.ExecutionContextStack.prototype =
    {
        getStackLines: function()
        {
            var lines = "";

            for(var i = 0; i < this.stack.length; i++)
            {
                if(i != 0) { lines += "-"; }
                lines += this.stack[i].lastCommand.codeConstruct.loc.start.line;
            }

            return lines;
        },

        destruct: function()
        {
            delete this.globalObject;

            delete this.activeContext;
            delete this.stack;

            delete this.exceptionCallbacks;
            delete this.blockCommandStack;
            delete this.functionContextCommandsStack;

            delete this.dependencyCreator;

            delete this.evaluator;
        },

        executeCommand: function(command)
        {
            try
            {
                //console.log("Executing command " + command.type + " @" + (command.codeConstruct != null && command.codeConstruct.loc != null ? command.codeConstruct.loc.start.line : -1));
                if(!command.isEnterFunctionContextCommand()) { this.activeContext.lastCommand = command; }
                this.globalObject.browser.logConstructExecuted(command.codeConstruct);

                if (command.isEnterFunctionContextCommand())
                {
                    this.functionContextCommandsStack.push(command);
                    command.functionContextBlockCommandsEvalPositions = [];
                    this._addToBlockCommandStack(command);
                    this._enterFunctionContext(command);
                }
                else if (command.isExitFunctionContextCommand())
                {
                    this._exitFunctionContext(command);
                    this._popTillLastFunctionContextCommand(command);
                    this.functionContextCommandsStack.pop();
                }
                else if (command.isStartWithStatementCommand())
                {
                    this.dependencyCreator.addDependenciesToTopBlockConstructs(command.codeConstruct.object);
                    this._addToBlockCommandStack(command);
                    this._evalStartWithCommand(command);
                }
                else if(command.isStartDoWhileCommand())
                {
                    this._addToBlockCommandStack(command);
                }
                else if (command.isEndWithStatementCommand()) { this._tryPopCommand(command); this._evalEndWithCommand(command); }
                else if (command.isForStatementCommand() || command.isWhileStatementCommand() ||  command.isDoWhileStatementCommand())
                {
                    this.dependencyCreator.addDependenciesToTopBlockConstructs(command.codeConstruct.test);
                    this._addToBlockCommandStack(command);
                }
                else if (command.isForUpdateStatementCommand()){}
                else if (command.isIfStatementCommand())
                {
                    this.dependencyCreator.addDependenciesToTopBlockConstructs(command.codeConstruct.test);
                    //this.globalObject.browser.callControlFlowProblematicReachedCallbacks(command.codeConstruct.test);
                    this._addToBlockCommandStack(command);
                }
                else if (command.isEndIfCommand()) { this._tryPopCommand(command);}
                else if (command.isEndLoopStatementCommand()) { this._popLoop(command);}
                else if (command.isEvalConditionalExpressionBodyCommand()) { }
                else if (command.isEvalConditionalExpressionCommand()) { this._addToBlockCommandStack(command); }
                else if (command.isEvalBreakCommand() || command.isEvalContinueCommand())
                {
                    if(this.activeContext.id == 4582) {debugger; }
                    this.evaluator.evalBreakContinueCommand(command );
                    //if(command.id == 293413) debugger;
                    this._popTillBreakContinue(command.codeConstruct);
                }
                else if (command.isStartSwitchStatementCommand()) { this._addToBlockCommandStack(command); }
                else if (command.isEndSwitchStatementCommand()) { this._tryPopCommand(command);}
                else if (command.isCaseCommand()) {}
                else if (command.isStartTryStatementCommand() || command.isEndTryStatementCommand()) { }
                else if (command.isEvalNewExpressionCommand()){ this.dependencyCreator.addNewExpressionDependencies(command.codeConstruct);}
                else if (command.isStartLogicalExpressionCommand()) { }
                else if (command.isCallInternalConstructorCommand()) { this.dependencyCreator.addDependenciesToTopBlockConstructs(command.codeConstruct); }
                else if (command.isCallCallbackMethodCommand()) {}
                else if (command.isEvalCallExpressionCommand())
                {
                    this.dependencyCreator.addCallExpressionDependencies(command.codeConstruct);
                    this.globalObject.browser.callExpressionEvaluatedCallbacks(command.codeConstruct.callee);
                }
                else if (command.isExecuteCallbackCommand()) { this.dependencyCreator.addCallbackDependencies(command.codeConstruct, command.callCallbackCommand.codeConstruct); }
                else if (command.isLabelCommand()) { this._logLabelCommand(command) ;}
                else if (command.isConvertToPrimitiveCommand()) {}
                else
                {
                    if (command.isEndEvalConditionalExpressionCommand()) { this._tryPopCommand(command); }
                    else if (command.isStartCatchStatementCommand()) { this._addToBlockCommandStack(command); }
                    else if (command.isEndCatchStatementCommand()) { this._tryPopCommand(command);}
                    else if(command.isEvalForInWhereCommand())
                    {
                        this.dependencyCreator.addDependenciesToTopBlockConstructs(command.codeConstruct.right);
                        this._addToBlockCommandStack(command);
                    }
                    else if (command.isEndLogicalExpressionCommand())
                    {
                        if(ASTHelper.isAssignmentExpression(command.codeConstruct.parent))
                        {
                            this._addToFunctionContextBlockCommands(command);
                        }
                    }

                    this.evaluator.evaluateCommand(command);
                }
            }
            catch(e)
            {
                debugger;
                this.notifyError("Error when executing command: " + e);
            }
        },

        registerIdentifier: function(variableDeclarator)
        {
            if(!ASTHelper.isVariableDeclarator(variableDeclarator)) { this.notifyError("ExecutionContextStack: When registering an identifier, the argument has to be variable declarator"); }

            this.globalObject.browser.logConstructExecuted(variableDeclarator);
            this.globalObject.browser.logConstructExecuted(variableDeclarator.id)

            this.activeContext.registerIdentifier
            (
                new fcModel.Identifier
                (
                    variableDeclarator.id.name,
                    new fcModel.fcValue(undefined, undefined, variableDeclarator),
                    variableDeclarator,
                    this.globalObject
                )
            );
        },

        registerFunctionDeclaration: function(functionDeclaration)
        {
            try
            {
                if(!ASTHelper.isFunctionDeclaration(functionDeclaration)) { this.notifyError("When registering a function, the argument has to be a function declaration"); return; }

                this.globalObject.browser.logConstructExecuted(functionDeclaration);
                this.activeContext.registerIdentifier(new fcModel.Identifier(functionDeclaration.id.name, this.createFunctionInCurrentContext(functionDeclaration), functionDeclaration, this.globalObject));
            }
            catch(e)
            {
                this.notifyError("ExecutionContextStack - error when registering function declaration: " + e);
            }
        },

        getIdentifier: function(identifierName, codeConstruct)
        {
            for(var i = this.stack.length - 1; i >= 0; i--)
            {
                var scopeChain = this.stack[i].scopeChain;

                for(var j = scopeChain.length - 1; j >= 0; j--)
                {
                    var variableObject = scopeChain[j];

                    var identifier = variableObject.getIdentifier(identifierName);

                    if(identifier != null)
                    {
                        if(i != this.stack.length - 1 || j != scopeChain.length - 1)
                        {
                            this.globalObject.browser.logReadingIdentifierOutsideCurrentScope(identifier, codeConstruct);
                        }

                        return identifier;
                    }
                }
            }
        },

        getIdentifierValue: function(identifierName)
        {
            for(var i = this.stack.length - 1; i >= 0; i--)
            {
                var scopeChain = this.stack[i].scopeChain;

                for(var j = scopeChain.length - 1; j >= 0; j--)
                {
                    var variableObject = scopeChain[j];

                    var identifier = variableObject.getIdentifier(identifierName);

                    if(identifier != null) { return identifier.value; }
                }
            }
        },

        setIdentifierValue: function(identifierName, value, setCodeConstruct, keepOldValue)
        {
            for(var i = this.stack.length - 1; i >= 0; i--)
            {
                var scopeChain = this.stack[i].scopeChain;

                for(var j = scopeChain.length - 1; j >= 0; j--)
                {
                    var variableObject = scopeChain[j];

                    var identifier = variableObject.getIdentifier(identifierName);

                    if(identifier != null)
                    {
                        identifier.setValue(value, setCodeConstruct, keepOldValue);

                        if(variableObject != this.globalObject && !ValueTypeHelper.isOfType(variableObject, fcSimulator.VariableObject))
                        {
                            variableObject[identifierName] = value;
                        }

                        if(i != this.stack.length - 1 || j != scopeChain.length - 1)
                        {
                            this.globalObject.browser.logModifyingExternalContextIdentifier(identifier);
                        }

                        return;
                    }
                }
            }

            this.stack[0].registerIdentifier(new fcModel.Identifier(identifierName, value, setCodeConstruct, this.globalObject));
        },

        restoreIdentifier: function(identifierName)
        {
            for(var i = this.stack.length - 1; i >= 0; i--)
            {
                var scopeChain = this.stack[i].scopeChain;

                for(var j = scopeChain.length - 1; j >= 0; j--)
                {
                    var variableObject = scopeChain[j];

                    var identifier = variableObject.getIdentifier(identifierName);

                    if(identifier != null)
                    {
                        identifier.restoreOldValue();
                        return;
                    }
                }
            }
        },

        deleteIdentifier: function(identifierName)
        {
            for(var i = this.stack.length - 1; i >= 0; i--)
            {
                var scopeChain = this.stack[i].scopeChain;

                for(var j = scopeChain.length - 1; j >= 0; j--)
                {
                    var variableObject = scopeChain[j];

                    var identifier = variableObject.getIdentifier(identifierName);

                    if(identifier != null)
                    {
                        return variableObject.deleteIdentifier(identifier.name);
                    }
                }
            }
        },

        setExpressionValue: function(codeConstruct, value)
        {
            this.activeContext.setCodeConstructValue(codeConstruct, value);
        },

        setExpressionValueInPreviousContext: function(codeConstruct, value)
        {
            var previousExecutionContext = this.stack[this.stack.length - 2];

            if(previousExecutionContext == null) { this.notifyError("There is no previous context!"); return; }

            previousExecutionContext.setCodeConstructValue(codeConstruct, value);
        },

        getExpressionValue: function(codeConstruct)
        {
            var returnValue = this.activeContext.getCodeConstructValue(codeConstruct);

            if(returnValue == null && ASTHelper.isCallExpression(codeConstruct))
            {
                return new fcModel.fcValue(undefined, undefined, codeConstruct);
            }

            return returnValue;
        },

        getExpressionsValues: function(expressions)
        {
            var values = [];

            for(var i = 0; i < expressions.length; i++)
            {
                values.push(this.getExpressionValue(expressions[i]));
            }

            return values;
        },

        getBaseObject: function(codeConstruct)
        {
            if(ASTHelper.isIdentifier(codeConstruct) || ASTHelper.isFunctionExpression(codeConstruct)
            || ASTHelper.isLogicalExpression(codeConstruct) || ASTHelper.isConditionalExpression(codeConstruct)
            || ASTHelper.isThisExpression(codeConstruct))
            {
                return this.globalObject;
            }
            else if (ASTHelper.isMemberExpression(codeConstruct)) { return this.getExpressionValue(codeConstruct.object); }
            else if (ASTHelper.isCallExpression(codeConstruct)) { return this.getExpressionValue(codeConstruct.callee); }
            else
            {
                this.notifyError("Not handling getting base object on other expressions");
                return this.globalObject;
            }
        },

        createFunctionInCurrentContext: function(functionCodeConstruct)
        {
            return this.globalObject.internalExecutor.createFunction(this.activeContext.scopeChain, functionCodeConstruct)
        },

        registerExceptionCallback: function(callback, thisObject)
        {
            if(!ValueTypeHelper.isFunction(callback)) { this.notifyError("Exception callback has to be a function!"); return; }

            this.exceptionCallbacks.push({callback: callback, thisObject: thisObject || this});
        },

        push: function(executionContext)
        {
            if(!ValueTypeHelper.isOfType(executionContext, fcSimulator.ExecutionContext)) { this.notifyError("Argument is not ExecutionContext!"); return; }

            this.stack.push(executionContext);

            this.activeContext = executionContext;
        },

        pop: function()
        {
            if(this.stack.length == 0) { this.notifyError("Can not pop an empty stack"); return; }

            this.stack.pop();

            this.activeContext = this.stack[this.stack.length - 1];
        },

        callExceptionCallbacks: function(exceptionInfo)
        {
            this.exceptionCallbacks.forEach(function(callbackObject)
            {
                callbackObject.callback.call(callbackObject.thisObject, exceptionInfo);
            });
        },

        getTopBlockCommandConstructs: function()
        {
            //Loop, With, and If constructs are repeating and constant - makes more sense to link the blockStackConstructs with them, then on commands (which get created for each execution)
            //on the other hand EnterFunctionContextCommand is linked to the call expression making the call, which differ makes more sense to link to a command
            if(this.blockCommandStack.length == 0) { return []; }

            var topCommand = this.blockCommandStack[this.blockCommandStack.length - 1];
            var topConstruct = topCommand.codeConstruct;

            if((topCommand.isEnterFunctionContextCommand() || topCommand.isStartSwitchStatementCommand() || topCommand.isStartCatchStatementCommand())
                && topCommand.blockStackConstructs != null)
            {
                return topCommand.blockStackConstructs;
            }

            if(topConstruct.blockStackConstructs != null) { return topConstruct.blockStackConstructs; }

            if(ASTHelper.isLoopStatement(topConstruct) || ASTHelper.isIfStatement(topConstruct)  || ASTHelper.isConditionalExpression(topConstruct))
            {
                return topConstruct.blockStackConstructs = ASTHelper.isForInStatement(topConstruct) ? [topConstruct.right]
                                                                                                    : [topConstruct.test];
            }
            else if(ASTHelper.isWithStatement(topConstruct))
            {
                return topConstruct.blockStackConstructs = [topConstruct.object];
            }

            if(topCommand.isEnterFunctionContextCommand())
            {
                return topCommand.blockStackConstructs = [topCommand.codeConstruct, topCommand.parentFunctionCommand.codeConstruct];
            }
            else if (topCommand.isStartSwitchStatementCommand())
            {
                topCommand.blockStackConstructs = [topConstruct.discriminant];

                if(topCommand.matchedCaseCommand != null)
                {
                    topCommand.blockStackConstructs.push(topCommand.matchedCaseCommand.codeConstruct);

                    if(topCommand.matchedCaseCommand.codeConstruct.test != null)
                    {
                        topCommand.blockStackConstructs.push(topCommand.matchedCaseCommand.codeConstruct.test);
                    }
                }

                return topCommand.blockStackConstructs;
            }
            else if (topCommand.isStartCatchStatementCommand())
            {
                if(topCommand.exceptionArgument.exceptionGeneratingConstruct != null)
                {
                    return topCommand.blockStackConstructs = [topCommand.exceptionArgument.exceptionGeneratingConstruct];
                }
                else if(topCommand.exceptionArgument.codeConstruct != null)
                {
                    return topCommand.blockStackConstructs = [topCommand.exceptionArgument.codeConstruct];
                }
                else
                {
                    return topCommand.blockStackConstructs = [topCommand.codeConstruct.param];
                }
            }

            this.notifyError("Should not be here when getting top block command @ " + topCommand.codeConstruct.loc.source);
        },

        getPreviouslyExecutedBlockConstructs: function()
        {
            var constructsEvalPositions = [];
            var topFunctionContextCommand = this.functionContextCommandsStack[this.functionContextCommandsStack.length - 1];

            if(topFunctionContextCommand == null || topFunctionContextCommand.functionContextBlockCommandsEvalPositions == null) { return constructsEvalPositions; }

            var blockCommandsEvalPositionMapping = topFunctionContextCommand.functionContextBlockCommandsEvalPositions;

            for(var i = 0, length = blockCommandsEvalPositionMapping.length; i < length; i++)
            {
                var mapping = blockCommandsEvalPositionMapping[i];

                var codeConstruct = mapping.command.codeConstruct;

                if(ASTHelper.isForStatement(codeConstruct) || ASTHelper.isWhileStatement(codeConstruct) || ASTHelper.isDoWhileStatement(codeConstruct)
                    || ASTHelper.isIfStatement(codeConstruct))
                {
                    codeConstruct = codeConstruct.test;
                }
                else if(ASTHelper.isWithStatement(codeConstruct))
                {
                    codeConstruct = codeConstruct.object;
                }
                else if (ASTHelper.isSwitchStatement(codeConstruct))
                {
                    codeConstruct = codeConstruct.discriminant;
                }
                else if (ASTHelper.isLogicalExpression(codeConstruct))
                {

                }
                else
                {
                    codeConstruct = null;
                }

                constructsEvalPositions.push({codeConstruct: codeConstruct, evaluationPositionId: mapping.evaluationPositionId});
            }

            return constructsEvalPositions;
        },


        _exceptionCallback: function(exceptionInfo)
        {
            this.callExceptionCallbacks(exceptionInfo);
        },

        _enterInitialContext: function(handlerInfo)
        {
            this.handlerInfo = handlerInfo;

            if(this.handlerInfo == null)
            {
                this._enterGlobalContext();
            }
            else
            {
                this.enterEventHandlerContextCommand = fcCommands.Command.createEnterEventHandlerContextCommand(this.handlerInfo);
                this._enterFunctionContext(this.enterEventHandlerContextCommand);
            }
        },

        _popTillLastFunctionContextCommand: function(exitFunctionContextCommand)
        {
            if(this.blockCommandStack.length == 0) { this.notifyError("Error when popping function context commands from block stack - empty stack!"); return; }

            var blockCommandStack = this.blockCommandStack;

            for(var i = blockCommandStack.length - 1; i >= 0; i = blockCommandStack.length - 1)
            {
                var command = blockCommandStack[i];

                blockCommandStack.pop();

                if(command.codeConstruct == exitFunctionContextCommand.codeConstruct) { break; }
            }

            this._reevaluateEvaluationPositionId();
        },

        _popTillBreakContinue: function(codeConstruct)
        {
            if(this.blockCommandStack.length == 0) { this.notifyError("Error when popping break/continue commands from block stack - empty stack @" + codeConstruct.loc.source); return; }

            if(ASTHelper.isBreakStatement(codeConstruct)) { this._popTillBreak(codeConstruct); }
            else if (ASTHelper.isContinueStatement(codeConstruct)) { this._popTillContinue(codeConstruct); }
            else { this.notifyError("When popping break continue, codeConstruct should be break or continue!"); }

            this._reevaluateEvaluationPositionId();
        },

        _popTillBreak: function(codeConstruct)
        {
            var blockCommandStack = this.blockCommandStack;
            var parentLoopOrSwitch = ASTHelper.getLoopOrSwitchParent(codeConstruct);

            for(var i = blockCommandStack.length - 1; i >= 0; i = blockCommandStack.length - 1)
            {
                var command = blockCommandStack[i];

                if((command.isLoopStatementCommand() || command.isStartSwitchStatementCommand())
                 && command.codeConstruct == parentLoopOrSwitch)
                {
                    if(command.isStartDoWhileCommand()) { blockCommandStack.pop(); }
                    break;
                }

                blockCommandStack.pop();
            }
        },

        _popTillContinue: function(codeConstruct)
        {
            var blockCommandStack = this.blockCommandStack;
            var loopParent = ASTHelper.getLoopParent(codeConstruct)

            for(var i = blockCommandStack.length - 1; i >= 0; i = blockCommandStack.length - 1)
            {
                var command = blockCommandStack[i];

                if(command.isLoopStatementCommand() && command.codeConstruct == loopParent)
                {
                    if(command.isStartDoWhileCommand()) { blockCommandStack.pop(); }

                    break;
                }

                blockCommandStack.pop();
            }
        },

        _popLoop: function(loopCommand)
        {
            this._tryPopCommand(loopCommand);
            this._reevaluateEvaluationPositionId();
        },

        _tryPopCommand: function(baseCommand)
        {
            if(this.blockCommandStack.length == 0) { this.notifyError("Error when trying to a command from block stack - empty stack!"); return false; }

            var lastCommand = this.blockCommandStack[this.blockCommandStack.length-1];

            if(lastCommand != baseCommand.startCommand)
            {
                this.notifyError
                (
                    "When popping commands the top command has to be the same as the base command - TopCommand@"
                        + lastCommand
                        + " Base command@" + baseCommand
                );

                return false;
            }

            this.blockCommandStack.pop();
        },

        _logLabelCommand: function(command)
        {
            this.activeContext.logLabel(command.codeConstruct);
        },

        _addToBlockCommandStack: function(command)
        {
            if(command.isLoopStatementCommand() || command.isIfStatementCommand()) { this._addToFunctionContextBlockCommands(command); }

            this.blockCommandStack.push(command);

            if(command.isLoopStatementCommand() || command.isEnterFunctionContextCommand()) { this._reevaluateEvaluationPositionId(); }
        },

        _addToFunctionContextBlockCommands: function(command)
        {
            var topFunctionContextCommand = this.functionContextCommandsStack[this.functionContextCommandsStack.length - 1];

            if(topFunctionContextCommand == null) { return; }

            topFunctionContextCommand.functionContextBlockCommandsEvalPositions.push(
            {
                command: command,
                evaluationPositionId: this.globalObject.getPreciseEvaluationPositionId()
            });
        },

        _reevaluateEvaluationPositionId: function()
        {
            this.globalObject.evaluationPositionId = "root";

            var blockCommandStack = this.blockCommandStack;

            for(var i = 0, length = blockCommandStack.length; i < length; i++)
            {
                var command = blockCommandStack[i];
                if(command.isLoopStatementCommand() || command.isEnterFunctionContextCommand())
                {
                    this.globalObject.evaluationPositionId += "-" + command.executionId + (command.isEnterFunctionContextCommand() ? "f" : "");
                }
            }
        },

        _enterGlobalContext: function()
        {
            this.push(fcSimulator.ExecutionContext.createGlobalExecutionContext(this.globalObject));
        },

        _enterFunctionContext: function(enterFunctionCommand)
        {
            if(!ValueTypeHelper.isOfType(enterFunctionCommand, fcCommands.Command) || !enterFunctionCommand.isEnterFunctionContextCommand()) { this.notifyError("Argument must be a enterFunctionContext command"); return; }
            if(enterFunctionCommand.callee == null) { this.notifyError("When processing enter function context the callee can not be null!"); return; }

            var callee = enterFunctionCommand.callee.iValue;
            this.dependencyCreator.markEnterFunctionPoints(enterFunctionCommand);

            var functionConstruct = enterFunctionCommand.callee.codeConstruct;
            var formalParameters = this._getFormalParameters(functionConstruct);

            var sentArgumentsValues = null;
            var arguments = [];

            this.globalObject.browser.logEnteringFunction
                (
                    enterFunctionCommand.parentFunctionCommand != null ? enterFunctionCommand.parentFunctionCommand.codeConstruct : null,
                    functionConstruct,
                    fcSimulator.ExecutionContext.LAST_ID
                );

            if(enterFunctionCommand.isEnterEventHandler) { sentArgumentsValues = enterFunctionCommand.argumentValues; }
            else
            {
                sentArgumentsValues = this._getSentArgumentValues(enterFunctionCommand.parentFunctionCommand);

                if(!enterFunctionCommand.parentFunctionCommand.isExecuteCallbackCommand())
                {
                    arguments = enterFunctionCommand.parentFunctionCommand.codeConstruct.arguments;
                }
            }

            if(callee.isBound && callee.argsToPrepend != null)
            {
                for(var i = 0; i < callee.argsToPrepend.length; i++)
                {
                    ValueTypeHelper.insertIntoArrayAtIndex(sentArgumentsValues, callee.argsToPrepend[i], 0);
                }
            }

            this.dependencyCreator.createFunctionParametersDependencies(enterFunctionCommand.parentFunctionCommand, formalParameters, arguments);

            this.push
                (
                    new fcSimulator.ExecutionContext
                        (
                            fcSimulator.VariableObject.createFunctionVariableObject
                                (
                                    functionConstruct.id != null ? new fcModel.Identifier(functionConstruct.id.name, enterFunctionCommand.callee, functionConstruct, this.globalObject)
                                        : null,
                                    formalParameters,
                                    enterFunctionCommand.callee,
                                    sentArgumentsValues,
                                    enterFunctionCommand.parentFunctionCommand,
                                    this.globalObject
                                ),
                            enterFunctionCommand.callee.iValue.scopeChain,
                            enterFunctionCommand.thisObject,
                            this.globalObject,
                            enterFunctionCommand
                        )
                );
        },

        _exitFunctionContext: function(exitFunctionContextCommand)
        {
            this.pop();

            this.dependencyCreator.createExitFunctionDependencies(exitFunctionContextCommand.parentFunctionCommand);

            this.globalObject.browser.logExitingFunction();
        },

        _getFormalParameters: function(functionConstruct)
        {
            try
            {
                if(functionConstruct == null)
                {
                    debugger;
                    this.notifyError("Error when getting formal parameters");
                    return;
                }

                var identifiers = [];

                if(functionConstruct.params == null) { return identifiers; }

                for(var i = 0; i < functionConstruct.params.length; i++)
                {
                    var param = functionConstruct.params[i];
                    var identifier = new fcModel.Identifier(param.name, new fcModel.fcValue(undefined, undefined, param), param, this.globalObject);
                    identifier.isFunctionFormalParameter = true;
                    identifiers.push(identifier);
                }

                return identifiers;
            }
            catch(e) { debugger; }
        },

        _getSentArgumentValues: function(callCommand)
        {
            if(callCommand.isApply) { return this._getArgumentValuesFromApply(callCommand); }
            else if (callCommand.isCall) { return this._getArgumentValuesFromCall(callCommand); }
            else if (callCommand.isExecuteCallbackCommand()) { return callCommand.arguments;}
            else { return this._getArgumentValuesFromStandard(callCommand); }
        },

        _getArgumentValuesFromApply: function(callCommand)
        {
            var args = callCommand.codeConstruct.arguments;

            if(args == null) { return []; }

            var secondArgument = args[1];

            if(secondArgument == null) { return []; }

            var secondArgValue = this.getExpressionValue(secondArgument);

            return secondArgValue.jsValue || [];
        },

        _getArgumentValuesFromCall: function(callCommand)
        {
            var values = [];
            var args = callCommand.codeConstruct.arguments;

            if(args == null) { return values; }

            for(var i = 1; i < args.length; i++) { values.push(this.getExpressionValue(args[i]));}

            return values;
        },

        _getArgumentValuesFromStandard: function(callCommand)
        {
            var args = callCommand.codeConstruct.arguments;

            if(args == null) { return []; }

            return this.getExpressionsValues(args);
        },

        _evalStartWithCommand: function(startWithCommand)
        {
            this.activeContext.pushToScopeChain(fcSimulator.VariableObject.liftToVariableObject(this.getExpressionValue(startWithCommand.codeConstruct.object)));
        },

        _evalEndWithCommand: function(endWithCommand)
        {
            this.activeContext.popFromScopeChain();
        },


        notifyError: function(message) { debugger; fcSimulator.ExecutionContext.notifyError(message); }
    };
    /*************************************************************************************/
}});FBL.ns(function() { with (FBL) {
/*************************************************************************************/
var fcSimulator = Firecrow.Interpreter.Simulator;
var fcModel = Firecrow.Interpreter.Model;
var ASTHelper = Firecrow.ASTHelper;
var ValueTypeHelper = Firecrow.ValueTypeHelper;

fcSimulator.DependencyCreator = function(globalObject, executionContextStack)
{
    this.globalObject = globalObject;
    this.executionContextStack = executionContextStack;
};

fcSimulator.DependencyCreator.shouldCreateDependencies = false;
fcSimulator.DependencyCreator.shouldCreateSimpleDependencies = true;

fcSimulator.DependencyCreator.notifyError = function(message) { debugger; alert("DependencyCreator - " + message);};

fcSimulator.DependencyCreator.prototype =
{
    createDependencyToConstructorPrototype: function(creationCodeConstruct, constructorFunction)
    {
        if(!fcSimulator.DependencyCreator.shouldCreateDependencies) { return; }

        if(constructorFunction.iValue != null && constructorFunction.iValue.prototypeDefinitionConstruct != null)
        {
            this.globalObject.browser.callDataDependencyEstablishedCallbacks
            (
                creationCodeConstruct,
                constructorFunction.iValue.prototypeDefinitionConstruct.codeConstruct,
                this.globalObject.getPreciseEvaluationPositionId(),
                constructorFunction.iValue.prototypeDefinitionConstruct.evaluationPositionId
            );
        }
    },

    createBreakContinueDependencies: function(breakContinueConstruct)
    {
        var dependencyCreationInfo = this.globalObject.getPreciseEvaluationPositionId();

        dependencyCreationInfo.shouldAlwaysBeFollowed = true;
        dependencyCreationInfo.isBreakReturnDependency = true;

        this.globalObject.browser.callDataDependencyEstablishedCallbacks
        (
            ASTHelper.getBreakContinueReturnImportantAncestor(breakContinueConstruct),
            breakContinueConstruct,
            dependencyCreationInfo
        );
    },

    createExitFunctionDependencies: function(callFunctionCommand)
    {
        if(!fcSimulator.DependencyCreator.shouldCreateDependencies) { return; }

        this.addDependenciesToPreviouslyExecutedBlockConstructs(callFunctionCommand.codeConstruct, this.executionContextStack.getPreviouslyExecutedBlockConstructs());

        if(callFunctionCommand.executedReturnCommand != null && callFunctionCommand.executedReturnCommand.codeConstruct.argument == null)
        {
            this.globalObject.browser.callControlDependencyEstablishedCallbacks
            (
                callFunctionCommand.codeConstruct,
                callFunctionCommand.executedReturnCommand.codeConstruct,
                this.globalObject.getReturnExpressionPreciseEvaluationPositionId()
            );
        }
    },

    createDependenciesForObjectPropertyDefinition: function(propertyConstruct)
    {
        if(!fcSimulator.DependencyCreator.shouldCreateDependencies) { return; }
        if(!ASTHelper.isObjectExpression(propertyConstruct)) { return; }

        var children = propertyConstruct.children;

        for(var i = 0; i < children.length; i++)
        {
            var child = children[i];
            this.createDataDependency(propertyConstruct, child);
            this.createDataDependency(propertyConstruct, child.value);
        }
    },

     createDataDependency: function(fromConstruct, toConstruct, evaluationPosition, toEvaluationPosition)
    {
        if(fcSimulator.DependencyCreator.shouldCreateSimpleDependencies) { this._createSimpleDependency(fromConstruct, toConstruct); }
        if(!fcSimulator.DependencyCreator.shouldCreateDependencies) { return; }

        this.globalObject.browser.callDataDependencyEstablishedCallbacks
        (
            fromConstruct,
            toConstruct,
            evaluationPosition || this.globalObject.getPreciseEvaluationPositionId(),
            toEvaluationPosition
        );
    },

    markEnterFunctionPoints: function(enterFunctionCommand)
    {
        if(!fcSimulator.DependencyCreator.shouldCreateDependencies) { return; }

        if(enterFunctionCommand == null || enterFunctionCommand.parentFunctionCommand == null) { return; }

        //TODO - this should not be here!
        var graphNode = enterFunctionCommand.parentFunctionCommand.codeConstruct.graphNode;

        if(graphNode != null)
        {
            var dataDependencies = graphNode.dataDependencies;

            if(dataDependencies.length > 0)
            {
                if(graphNode.enterFunctionPoints == null) { graphNode.enterFunctionPoints = []; }

                graphNode.enterFunctionPoints.push({lastDependencyIndex: dataDependencies[dataDependencies.length - 1].index});
            }
        }
    },

    createFunctionParametersDependencies: function(callCommand, formalParams, args)
    {
        if(fcSimulator.DependencyCreator.shouldCreateSimpleDependencies) { this._createFunctionParametersSimpleDependencies(callCommand, formalParams, args); }
        if(!fcSimulator.DependencyCreator.shouldCreateDependencies) { return; }
        if(callCommand == null) { return; }

        //this._createArgumentsToCallDependencies(callCommand, args);
        this._createFormalParameterDependencies(callCommand, formalParams, args);
    },

    _createArgumentsToCallDependencies: function(callCommand, args)
    {
        if(!fcSimulator.DependencyCreator.shouldCreateDependencies) { return; }
        if(args == null) { return; }

        var evaluationPosition = this.globalObject.getPreciseEvaluationPositionId();

        for(var i = 0; i < args.length; i++)
        {
            this.globalObject.browser.callDataDependencyEstablishedCallbacks(args[i], callCommand.codeConstruct, evaluationPosition);
        }
    },

    _createFunctionParametersSimpleDependencies: function(callCommand, formalParams, args)
    {
        if(callCommand == null || args == null) { return; }

        for(var i = 0; i < args.length; i++)
        {
            this._createSimpleDependency(args[i], callCommand.codeConstruct);
        }

        for(var i = 0, length = formalParams.length; i < length; i++)
        {
            var formalParam = formalParams[i].value.codeConstruct;

            this._createSimpleDependency(formalParam, args[i]);
            this._createSimpleDependency(formalParam, callCommand.codeConstruct);
        }
    },

    _createFormalParameterDependencies: function(callCommand, formalParams, args)
    {
        if(!fcSimulator.DependencyCreator.shouldCreateDependencies) { return; }
        if(args == null) { return; }

        if(callCommand.isApply) { this._createFormalParameterDependenciesInApply(callCommand, formalParams, args); }
        else if (callCommand.isCall) { this._createFormalParameterDependenciesInCall(callCommand, formalParams, args); }
        else if (callCommand.isExecuteCallbackCommand()) {this._createFormalParameterDependenciesInCallback(callCommand, formalParams, args);}
        else { this._createFormalParameterDependenciesInStandard(callCommand, formalParams, args); }
    },

    _createFormalParameterDependenciesInApply: function(callCommand, formalParams, args)
    {
        if(!fcSimulator.DependencyCreator.shouldCreateDependencies) { return; }
        var argumentValue = this.executionContextStack.getExpressionValue(args[1]);

        if(argumentValue == null) { return; }

        var evalPosition = this.globalObject.getPreciseEvaluationPositionId();
        var fcArray = argumentValue.iValue;

        for(var i = 0, length = formalParams.length; i < length; i++)
        {
            var arrayItem = fcArray.getProperty(i);
            var formalParameter = formalParams[i].value.codeConstruct;

            if(arrayItem != null && arrayItem.lastModificationPosition != null)
            {
                this.globalObject.browser.callDataDependencyEstablishedCallbacks(formalParameter, arrayItem.lastModificationPosition.codeConstruct, evalPosition);
            }

            this.globalObject.browser.callDataDependencyEstablishedCallbacks(formalParameter, callCommand.codeConstruct, evalPosition);
        }
    },

    _createFormalParameterDependenciesInCall: function(callCommand, formalParams, args)
    {
        if(!fcSimulator.DependencyCreator.shouldCreateDependencies) { return; }
        var evalPosition = this.globalObject.getPreciseEvaluationPositionId();

        for(var i = 0, length = formalParams.length; i < length; i++)
        {
            var formalParameter = formalParams[i].value.codeConstruct;

            this.globalObject.browser.callDataDependencyEstablishedCallbacks(formalParameter, args[i + 1], evalPosition);
            this.globalObject.browser.callDataDependencyEstablishedCallbacks(formalParameter, callCommand.codeConstruct, evalPosition);
        }
    },

    _createFormalParameterDependenciesInStandard: function(callCommand, formalParams, args)
    {
        if(!fcSimulator.DependencyCreator.shouldCreateDependencies) { return; }
        var evalPosition = this.globalObject.getPreciseEvaluationPositionId();

        for(var i = 0, length = formalParams.length; i < length; i++)
        {
            var formalParam = formalParams[i].value.codeConstruct;

            this.globalObject.browser.callDataDependencyEstablishedCallbacks(formalParam, args[i], evalPosition);
            this.globalObject.browser.callDataDependencyEstablishedCallbacks(formalParam, callCommand.codeConstruct, evalPosition);
        }
    },


    addDependenciesToPreviouslyExecutedBlockConstructs: function(codeConstruct, previouslyExecutedBlockConstructs)
    {
        if(!fcSimulator.DependencyCreator.shouldCreateDependencies) { return; }
        var evaluationPosition = this.globalObject.getPreciseEvaluationPositionId();
        evaluationPosition.isReturnDependency = true;

        for(var i = 0, length = previouslyExecutedBlockConstructs.length; i < length; i++)
        {
            var mapping = previouslyExecutedBlockConstructs[i];

            this.globalObject.browser.callControlDependencyEstablishedCallbacks
            (
                codeConstruct,
                mapping.codeConstruct,
                evaluationPosition,
                mapping.evaluationPositionId,
                true
            );
        }
    },

    addDependenciesToTopBlockConstructs: function(currentConstruct)
    {
        if(!fcSimulator.DependencyCreator.shouldCreateDependencies) { return; }
        var topBlockConstructs = this.executionContextStack.getTopBlockCommandConstructs();
        var evaluationPosition = this.globalObject.getPreciseEvaluationPositionId();

        for(var i = 0, length = topBlockConstructs.length; i < length; i++)
        {
            var topBlockConstruct = topBlockConstructs[i];
            this.globalObject.browser.callControlDependencyEstablishedCallbacks(currentConstruct, topBlockConstruct, evaluationPosition);
        }

        if(this.executionContextStack.handlerInfo != null)
        {
            this.globalObject.browser.callControlDependencyEstablishedCallbacks
            (
                currentConstruct,
                this.executionContextStack.handlerInfo.registrationPoint.codeConstruct,
                evaluationPosition,
                this.executionContextStack.handlerInfo.registrationPoint.evaluationPositionId
            );
        }

        /*this.executionContextStack.addDependencyToLastExecutedBlockStatement(currentConstruct);

         if(currentConstruct.previousCondition != null)
         {
         this.globalObject.browser.callControlDependencyEstablishedCallbacks(currentConstruct, currentConstruct.previousCondition, evaluationPosition);
         }*/
    },

    addNewExpressionDependencies: function(newExpression)
    {
        var evaluationPosition = this.globalObject.getPreciseEvaluationPositionId();
        this.globalObject.dependencyCreator.createDataDependency(newExpression, newExpression.callee, evaluationPosition);

        for(var i = 0; i < newExpression.arguments.length; i++)
        {
            this.globalObject.dependencyCreator.createDataDependency(newExpression, newExpression.arguments[i], evaluationPosition);
        }

        this.addDependenciesToTopBlockConstructs(newExpression);
    },

    addCallExpressionDependencies: function(callConstruct)
    {
        //TODO - hack to cover problems of object[callExpression()] where only callExpression is important
         /*if(ASTHelper.isMemberExpressionProperty(callConstruct))
         {
            this.globalObject.dependencyCreator.createDataDependency(callConstruct, callConstruct.parent, this.globalObject.getPreciseEvaluationPositionId());
         } */
        var evaluationPosition = this.globalObject.getPreciseEvaluationPositionId();
        this.globalObject.dependencyCreator.createDataDependency(callConstruct, callConstruct.callee, evaluationPosition);

        if(callConstruct.arguments != null)
        {
            for(var i = 0; i < callConstruct.arguments.length; i++)
            {
                this.globalObject.dependencyCreator.createDataDependency(callConstruct, callConstruct.arguments[i], evaluationPosition);
            }
        }

        this.addDependenciesToTopBlockConstructs(callConstruct);
    },

    _createFormalParameterDependenciesInCallback: function(callCommand, formalParameters, args)
    {
        if(!fcSimulator.DependencyCreator.shouldCreateDependencies) { return; }
        var params = callCommand.callbackFunction.codeConstruct.params;
        var evalPosition = this.globalObject.getPreciseEvaluationPositionId();

        for(var i = 0; i < params.length; i++)
        {
            var arg = callCommand.arguments[i];

            if(arg != null)
            {
                this.globalObject.browser.callDataDependencyEstablishedCallbacks(params[i], arg.codeConstruct, evalPosition);
            }

            this.globalObject.browser.callDataDependencyEstablishedCallbacks(params[i], callCommand.codeConstruct, evalPosition);
            if(callCommand.parentInitCallbackCommand != null)
            {
                this.globalObject.browser.callDataDependencyEstablishedCallbacks(params[i], callCommand.parentInitCallbackCommand.codeConstruct, evalPosition);
            }
        }
    },

    addCallbackDependencies: function(callbackConstruct, callCallbackConstruct)
    {
        this.globalObject.browser.callDataDependencyEstablishedCallbacks
        (
            callbackConstruct,
            callCallbackConstruct,
            this.globalObject.getPreciseEvaluationPositionId()
        );
    },

    createCallbackFunctionCommandDependencies: function(evalCallbackFunctionCommand){},
    _createSimpleCallbackFunctionCommandDependencies: function(evalCallbackFunctionCommand) {},

    createAssignmentDependencies: function(assignmentCommand)
    {
        if(fcSimulator.DependencyCreator.shouldCreateSimpleDependencies) { this._createAssignmentSimpleDependencies(assignmentCommand); }
        if(!fcSimulator.DependencyCreator.shouldCreateDependencies) { return; }
        var assignmentExpression = assignmentCommand.codeConstruct;

        var evaluationPosition = this.globalObject.getPreciseEvaluationPositionId();

        this.globalObject.browser.callDataDependencyEstablishedCallbacks(assignmentExpression, assignmentCommand.leftSide, evaluationPosition);
        this.globalObject.browser.callDataDependencyEstablishedCallbacks(assignmentExpression, assignmentCommand.rightSide, evaluationPosition);

        this.addDependenciesToTopBlockConstructs(assignmentExpression);
    },

    _createAssignmentSimpleDependencies: function(assignmentCommand)
    {
        var assignmentExpression = assignmentCommand.codeConstruct;

        this._createSimpleDependency(assignmentExpression, assignmentCommand.leftSide);
        this._createSimpleDependency(assignmentExpression, assignmentCommand.rightSide);
    },

    createUpdateExpressionDependencies: function(updateExpression)
    {
        if(fcSimulator.DependencyCreator.shouldCreateSimpleDependencies) { this._createUpdateSimpleDependencies(updateExpression); }
        if(!fcSimulator.DependencyCreator.shouldCreateDependencies) { return; }

        this.globalObject.browser.callDataDependencyEstablishedCallbacks(updateExpression, updateExpression.argument, this.globalObject.getPreciseEvaluationPositionId());
        this.addDependenciesToTopBlockConstructs(updateExpression);
    },

    _createUpdateSimpleDependencies: function(updateExpression)
    {
        this._createSimpleDependency(updateExpression, updateExpression.argument);
    },

    createIdentifierDependencies:function(identifier, identifierConstruct, evaluationPosition)
    {
        if(fcSimulator.DependencyCreator.shouldCreateSimpleDependencies) { this._createIdentifierSimpleDependencies(identifier, identifierConstruct); }
        if(!fcSimulator.DependencyCreator.shouldCreateDependencies) { return; }

        this._addDependencyToIdentifierDeclaration(identifier, identifierConstruct, evaluationPosition);

        if(this._willIdentifierBeReadInAssignmentExpression(identifierConstruct))
        {
            this._addDependencyToLastModificationPoint(identifier, identifierConstruct, evaluationPosition);
        }

        if(identifier != null && identifier.value != null && identifier.value.iValue != null && identifier.value.iValue.dummyDependencyNode != null)
        {
            this.createDataDependency(identifierConstruct, identifier.value.iValue.dummyDependencyNode, evaluationPosition);
        }
    },

    _createIdentifierSimpleDependencies: function(identifier, identifierConstruct)
    {
        if(this._willIdentifierBeReadInAssignmentExpression(identifierConstruct))
        {
            this._addSimpleDependencyToLastModificationPoint(identifier, identifierConstruct);
        }

        this._addSimpleDependencyToIdentifierDeclaration(identifier, identifierConstruct);
    },

    _willIdentifierBeReadInAssignmentExpression: function(identifierConstruct)
    {
        return !ASTHelper.isAssignmentExpression(identifierConstruct.parent) || identifierConstruct.parent.left != identifierConstruct || identifierConstruct.parent.operator.length == 2;
    },

    _addDependencyToLastModificationPoint: function(identifier, identifierConstruct, evaluationPosition)
    {
        if(!fcSimulator.DependencyCreator.shouldCreateDependencies) { return; }

        if(identifier.lastModificationPosition == null) { return; }

        this.globalObject.browser.callDataDependencyEstablishedCallbacks
        (
            identifierConstruct,
            identifier.lastModificationPosition.codeConstruct,
            evaluationPosition,
            identifier.lastModificationPosition.evaluationPositionId,
            null,
            true
        );

        this.globalObject.browser.callDataDependencyEstablishedCallbacks
        (
            identifierConstruct,
            identifier.value.codeConstruct,
            evaluationPosition,
            identifier.lastModificationPosition.evaluationPositionId,
            null,
            true
        );
    },

    _addSimpleDependencyToLastModificationPoint: function(identifier, identifierConstruct)
    {
        if(identifier.lastModificationPosition != null)
        {
            this._createSimpleDependency(identifierConstruct, identifier.lastModificationPosition.codeConstruct);
        }

        if(identifier.value != null)
        {
            this._createSimpleDependency(identifierConstruct, identifier.value.codeConstruct);
        }
    },

    _addDependencyToIdentifierDeclaration: function(identifier, identifierConstruct, evaluationPosition)
    {
        if(!fcSimulator.DependencyCreator.shouldCreateDependencies) { return; }

        if(identifier.declarationPosition == null || identifier.declarationPosition == identifier.lastModificationPosition) { return; }

        this.globalObject.browser.callDataDependencyEstablishedCallbacks
        (
            identifierConstruct,
            ASTHelper.isVariableDeclarator(identifier.declarationPosition.codeConstruct) ? identifier.declarationPosition.codeConstruct.id
                                                                                          : identifier.declarationPosition.codeConstruct,
            evaluationPosition,
            null, null,
            true
        );
    },

    _addSimpleDependencyToIdentifierDeclaration: function(identifier, identifierConstruct)
    {
        if(!fcSimulator.DependencyCreator.shouldCreateDependencies) { return; }

        if(identifier.declarationPosition == null || identifier.declarationPosition == identifier.lastModificationPosition) { return; }

        this._createSimpleDependency
        (
            identifierConstruct,
            ASTHelper.isVariableDeclarator(identifier.declarationPosition.codeConstruct) ? identifier.declarationPosition.codeConstruct.id
                                                                                         : identifier.declarationPosition.codeConstruct
        );
    },

    createBinaryExpressionDependencies: function(binaryExpression)
    {
        if(fcSimulator.DependencyCreator.shouldCreateSimpleDependencies) { this._createBinarySimpleDependencies(binaryExpression); }
        if(!fcSimulator.DependencyCreator.shouldCreateDependencies) { return; }

        var evaluationPosition = this.globalObject.getPreciseEvaluationPositionId();

        this.globalObject.browser.callDataDependencyEstablishedCallbacks(binaryExpression, binaryExpression.left, evaluationPosition);
        this.globalObject.browser.callDataDependencyEstablishedCallbacks(binaryExpression, binaryExpression.right, evaluationPosition);
    },

    createBinaryExpressionInDependencies: function(binaryExpression, objectFcValue, propertyNameFcValue)
    {
        if(objectFcValue == null || propertyNameFcValue == null) { return; }
        if(objectFcValue.iValue == null) { return; }

        var propertyValue = objectFcValue.iValue.getJsPropertyValue(propertyNameFcValue.jsValue, binaryExpression);
        var propertyExists = propertyValue !== undefined && propertyValue.jsValue !== undefined;

        var evaluationPosition = this.globalObject.getPreciseEvaluationPositionId();

        var fcProperty = objectFcValue.iValue.getProperty(propertyNameFcValue.jsValue, binaryExpression);

        if(fcProperty != null)
        {
            if(fcProperty.lastModificationPosition != null)
            {
                this.globalObject.browser.callDataDependencyEstablishedCallbacks
                (
                    binaryExpression,
                    fcProperty.lastModificationPosition.codeConstruct,
                    evaluationPosition,
                    fcProperty.lastModificationPosition.evaluationPositionId,
                    null,
                    true
                );
            }
            else  if(fcProperty.declarationPosition != null)
            {
                this.globalObject.browser.callDataDependencyEstablishedCallbacks
                (
                    binaryExpression,
                    fcProperty.declarationPosition.codeConstruct,
                    evaluationPosition,
                    fcProperty.declarationPosition.evaluationPositionId,
                    null,
                    true
                );
            }
        }

        if(!propertyExists)
        {
            var propertyDeletePosition = objectFcValue.iValue.getPropertyDeletionPosition(propertyNameFcValue.jsValue);

            if(propertyDeletePosition != null)
            {
                this.globalObject.browser.callDataDependencyEstablishedCallbacks(binaryExpression, propertyDeletePosition.codeConstruct, evaluationPosition, propertyDeletePosition.evaluationPosition);
            }
        }
    },

    _createBinarySimpleDependencies: function(binaryExpression)
    {
        this._createSimpleDependency(binaryExpression, binaryExpression.left);
        this._createSimpleDependency(binaryExpression, binaryExpression.right);
    },

    createReturnDependencies: function(returnCommand)
    {
        if(fcSimulator.DependencyCreator.shouldCreateSimpleDependencies) { this._createReturnSimpleDependencies(returnCommand); }
        if(!fcSimulator.DependencyCreator.shouldCreateDependencies) { return; }
        this.globalObject.browser.callControlDependencyEstablishedCallbacks(returnCommand.codeConstruct, returnCommand.codeConstruct.argument, this.globalObject.getPreciseEvaluationPositionId());

        this.addDependenciesToTopBlockConstructs(returnCommand.codeConstruct);

        if(returnCommand.parentFunctionCommand == null || returnCommand.parentFunctionCommand.isExecuteCallbackCommand()) { return; }

        this.globalObject.browser.callDataDependencyEstablishedCallbacks(returnCommand.parentFunctionCommand.codeConstruct, returnCommand.codeConstruct, this.globalObject.getReturnExpressionPreciseEvaluationPositionId());
    },

    _createReturnSimpleDependencies: function(returnCommand)
    {
        this._createSimpleDependency(returnCommand.codeConstruct, returnCommand.codeConstruct.argument);

        if(returnCommand.parentFunctionCommand == null || returnCommand.parentFunctionCommand.isExecuteCallbackCommand()) { return; }

        this._createSimpleDependency(returnCommand.parentFunctionCommand.codeConstruct, returnCommand.codeConstruct);
    },

    createMemberExpressionDependencies: function(object, property, propertyValue, memberExpression)
    {
        if(fcSimulator.DependencyCreator.shouldCreateSimpleDependencies) { this._createMemberSimpleDependencies(object, property, propertyValue, memberExpression); }
        if(!fcSimulator.DependencyCreator.shouldCreateDependencies) { return; }
        //TODO - possibly can create a problem? - for problems see slicing 54, 55, 56
        var propertyExists = propertyValue !== undefined && propertyValue.jsValue !== undefined;

        var evaluationPosition = this.globalObject.getPreciseEvaluationPositionId();

        if(object.iValue != null)
        {
            var fcProperty = object.iValue.getProperty(property.jsValue, memberExpression);

            if(fcProperty != null && !ASTHelper.isLastPropertyInLeftHandAssignment(memberExpression.property))
            {
                if(fcProperty.lastModificationPosition != null)
                {
                    this.globalObject.browser.callDataDependencyEstablishedCallbacks
                    (
                        memberExpression,
                        fcProperty.lastModificationPosition.codeConstruct,
                        evaluationPosition,
                        fcProperty.lastModificationPosition.evaluationPositionId,
                        null,
                        true
                    );

                    /*this.globalObject.browser.callDataDependencyEstablishedCallbacks
                    (
                        memberExpression,
                        fcProperty.lastModificationPosition.codeConstruct,
                        evaluationPosition,
                        fcProperty.lastModificationPosition.evaluationPositionId,
                        null,
                        true
                    );*/
                }
                else  if(fcProperty.declarationPosition != null)
                {
                    this.globalObject.browser.callDataDependencyEstablishedCallbacks
                    (
                        memberExpression.property,
                        fcProperty.declarationPosition.codeConstruct,
                        evaluationPosition,
                        fcProperty.declarationPosition.evaluationPositionId,
                        null,
                        true
                    );
                }
            }
        }

        this.globalObject.browser.callDataDependencyEstablishedCallbacks(memberExpression, memberExpression.object, this.globalObject.getPreciseEvaluationPositionId());

        //Create a dependency only if the property exists, the problem is that if we don't ignore it here, that will lead to links to constructs where the property was not null
        if(propertyExists || !ASTHelper.isIdentifier(memberExpression.property) || ASTHelper.isLastPropertyInLeftHandAssignment(memberExpression.property))
        {
            this.globalObject.browser.callDataDependencyEstablishedCallbacks(memberExpression, memberExpression.property, evaluationPosition);
        }
        else
        {
            var propertyDeletePosition = object.iValue.getPropertyDeletionPosition(property.jsValue);

            if(propertyDeletePosition != null)
            {
                this.globalObject.browser.callDataDependencyEstablishedCallbacks(memberExpression, propertyDeletePosition.codeConstruct, evaluationPosition, propertyDeletePosition.evaluationPosition, null, true);
            }

            this.globalObject.browser.callDataDependencyEstablishedCallbacks(memberExpression, memberExpression.property, evaluationPosition, evaluationPosition, true);

            if(memberExpression.computed && ASTHelper.isIdentifier(memberExpression.property))
            {
                var identifier = this.executionContextStack.getIdentifier(memberExpression.property.name);
                if(identifier != null && identifier.declarationPosition != null)
                {
                    this.globalObject.browser.callDataDependencyEstablishedCallbacks(memberExpression, identifier.declarationPosition.codeConstruct, evaluationPosition, identifier.declarationPosition.evaluationPositionId, true);
                }
            }
        }
    },

    _createMemberSimpleDependencies: function(object, property, propertyValue, memberExpression)
    {
        if(object.iValue != null)
        {
            var fcProperty = object.iValue.getProperty(property.jsValue, memberExpression);

            if(fcProperty != null && !ASTHelper.isLastPropertyInLeftHandAssignment(memberExpression.property))
            {
                if(fcProperty.lastModificationPosition != null)
                {
                    this._createSimpleDependency(memberExpression.property, fcProperty.lastModificationPosition.codeConstruct);
                }
                else  if(fcProperty.declarationPosition != null)
                {
                    this._createSimpleDependency(memberExpression.property, fcProperty.declarationPosition.codeConstruct);
                }
            }
        }

        this._createSimpleDependency(memberExpression, memberExpression.object);
        this._createSimpleDependency(memberExpression, memberExpression.property);

        if(memberExpression.computed && ASTHelper.isIdentifier(memberExpression.property))
        {
            var identifier = this.executionContextStack.getIdentifier(memberExpression.property.name);
            if(identifier != null && identifier.declarationPosition != null)
            {
                this._createSimpleDependency(memberExpression, identifier.declarationPosition.codeConstruct);
            }
        }
    },

    createDependenciesInForInWhereCommand: function(forInWhereConstruct, whereObject, nextPropertyName, isFirstIteration)
    {
        if(fcSimulator.DependencyCreator.shouldCreateSimpleDependencies) { this._createForInWhereSimpleDependencies(forInWhereConstruct, whereObject, nextPropertyName); }
        if(!fcSimulator.DependencyCreator.shouldCreateDependencies) { return; }
        var evaluationPosition = this.globalObject.getPreciseEvaluationPositionId();
        this.addDependenciesToTopBlockConstructs(forInWhereConstruct.left);
        this.globalObject.browser.callDataDependencyEstablishedCallbacks(forInWhereConstruct, forInWhereConstruct.right, evaluationPosition);
        this.globalObject.browser.callDataDependencyEstablishedCallbacks(forInWhereConstruct.left, forInWhereConstruct.right, evaluationPosition);

        if(!nextPropertyName || !nextPropertyName.jsValue) { return; }

        var property = whereObject.iValue.getProperty(nextPropertyName.jsValue);

        if(property != null && property.lastModificationPosition != null)
        {
            this.globalObject.browser.callDataDependencyEstablishedCallbacks
            (
                forInWhereConstruct.left,
                property.lastModificationPosition.codeConstruct,
                evaluationPosition,
                property.lastModificationPosition.evaluationPositionId
            );

            if (ASTHelper.isVariableDeclaration(forInWhereConstruct.left))
            {
                var declarator = forInWhereConstruct.left.declarations[0];

                this.globalObject.browser.callDataDependencyEstablishedCallbacks
                (
                    declarator.id,
                    property.lastModificationPosition.codeConstruct,
                    evaluationPosition,
                    property.lastModificationPosition.evaluationPositionId
                );

                this.globalObject.browser.callDataDependencyEstablishedCallbacks(declarator, forInWhereConstruct.right, evaluationPosition);
                this.globalObject.browser.callDataDependencyEstablishedCallbacks(declarator.id, forInWhereConstruct.right, evaluationPosition);
            }

            if(isFirstIteration)
            {
                this.globalObject.browser.callDataDependencyEstablishedCallbacks
                (
                    forInWhereConstruct.right,
                    property.lastModificationPosition.codeConstruct,
                    evaluationPosition,
                    property.lastModificationPosition.evaluationPositionId
                );
            }
        }
    },

    _createForInWhereSimpleDependencies: function(forInWhereConstruct, whereObject, nextPropertyName)
    {
        this._createSimpleDependency(forInWhereConstruct, forInWhereConstruct.right);
        this._createSimpleDependency(forInWhereConstruct.left, forInWhereConstruct.right);

        if(!nextPropertyName || !nextPropertyName.jsValue) { return; }

        var property = whereObject.iValue.getProperty(nextPropertyName.jsValue);

        if(property != null && property.lastModificationPosition != null)
        {
            this._createSimpleDependency(forInWhereConstruct.left, property.lastModificationPosition.codeConstruct);

            if (ASTHelper.isVariableDeclaration(forInWhereConstruct.left))
            {
                var declarator = forInWhereConstruct.left.declarations[0];

                this._createSimpleDependency(declarator.id, property.lastModificationPosition.codeConstruct);
                this._createSimpleDependency(declarator, forInWhereConstruct.right);
                this._createSimpleDependency(declarator.id, forInWhereConstruct.right);
            }
        }
    },

    createDependenciesForConditionalCommand: function(conditionalCommand)
    {
        if(fcSimulator.DependencyCreator.shouldCreateSimpleDependencies) { this._createConditionalSimpleDependencies(conditionalCommand); }
        if(!fcSimulator.DependencyCreator.shouldCreateDependencies) { return; }

        var evaluationPosition = this.globalObject.getPreciseEvaluationPositionId();

        this.globalObject.browser.callDataDependencyEstablishedCallbacks(conditionalCommand.codeConstruct, conditionalCommand.codeConstruct.test, evaluationPosition);
        this.globalObject.browser.callDataDependencyEstablishedCallbacks(conditionalCommand.codeConstruct, conditionalCommand.startCommand.body, evaluationPosition);
    },

    _createConditionalSimpleDependencies: function(conditionalCommand)
    {
        this._createSimpleDependency(conditionalCommand.codeConstruct, conditionalCommand.codeConstruct.test);
        this._createSimpleDependency(conditionalCommand.codeConstruct, conditionalCommand.startCommand.body);
    },

    createDependenciesForLogicalExpressionItemCommand: function(logicalExpression)
    {
        if(!fcSimulator.DependencyCreator.shouldCreateDependencies) { return; }
        //TODO: not sure about this -> should it be for both
        //if(logicalExpression.operator == "&&")
        {
            //So that the dependecies fall into the expression inside the logical expression item
            this.globalObject.browser.callDataDependencyEstablishedCallbacks
            (
                logicalExpression.right,
                logicalExpression.left,
                this.globalObject.getPrecisePreviousEvaluationPositionId()
            );
        }
    },

    createDependenciesForLogicalExpression: function(logicalExpressionCommand)
    {
        if(fcSimulator.DependencyCreator.shouldCreateSimpleDependencies) { this._createLogicalSimpleDependencies(logicalExpressionCommand); }
        if(!fcSimulator.DependencyCreator.shouldCreateDependencies) { return; }
        var executedItemsCommands = logicalExpressionCommand.executedLogicalItemExpressionCommands;
        var evaluationPosition = this.globalObject.getPreciseEvaluationPositionId();

        for(var i = 0, length = executedItemsCommands.length; i < length; i++)
        {
            var executedLogicalExpressionItemConstruct = executedItemsCommands[i].codeConstruct;

            this.globalObject.browser.callDataDependencyEstablishedCallbacks
            (
                logicalExpressionCommand.codeConstruct,
                executedLogicalExpressionItemConstruct,
                evaluationPosition,
                null, null, i == length - 1 //the data comes from the last
            );
        }
    },

    _createLogicalSimpleDependencies: function(logicalExpressionCommand)
    {
        var executedItemsCommands = logicalExpressionCommand.executedLogicalItemExpressionCommands;

        for(var i = 0, length = executedItemsCommands.length; i < length; i++)
        {
            var executedLogicalExpressionItemConstruct = executedItemsCommands[i].codeConstruct;
            this._createSimpleDependency(logicalExpressionCommand.codeConstruct, executedLogicalExpressionItemConstruct);
        }
    },

    createDependenciesForCallInternalFunction: function(callInternalFunctionCommand)
    {
        if(fcSimulator.DependencyCreator.shouldCreateSimpleDependencies) { this._createSimpleDependenciesForCallInternalFunction(callInternalFunctionCommand); }
        if(!fcSimulator.DependencyCreator.shouldCreateDependencies) { return; }
        var callExpression = callInternalFunctionCommand.codeConstruct;

        //Callback function called with an internal function
        if(callExpression == null) { return; }

        var args = callExpression.arguments;
        var evaluationPosition = this.globalObject.getPreciseEvaluationPositionId();

        this.globalObject.browser.callDataDependencyEstablishedCallbacks(callExpression, callExpression.callee, evaluationPosition);

        if(callInternalFunctionCommand.isCall || callInternalFunctionCommand.isApply)
        {
            this._createDependenciesToCallApplyInternalFunctionCall(callInternalFunctionCommand, args, callExpression);
        }
        else
        {
            if(args == null) { return; }

            for(var i = 0, length = args.length; i < length; i++)
            {
                this.globalObject.browser.callDataDependencyEstablishedCallbacks(callExpression, args[i], evaluationPosition);
            }
        }
    },

    _createSimpleDependenciesForCallInternalFunction: function(callInternalFunctionCommand)
    {
        var callExpression = callInternalFunctionCommand.codeConstruct;

        //Callback function called with an internal function
        if(callExpression == null) { return; }

        var args = callExpression.arguments;

        this._createSimpleDependency(callExpression, callExpression.callee);

        if(callInternalFunctionCommand.isCall || callInternalFunctionCommand.isApply)
        {
            this._createSimpleDependenciesToCallApplyInternalFunctionCall(callInternalFunctionCommand, args, callExpression);
        }
        else
        {
            if(args == null) { return; }

            for(var i = 0, length = args.length; i < length; i++)
            {
                var argument = args[i];
                this._createSimpleDependency(callExpression, argument);
                this._createSimpleDependency(argument, callExpression);
            }
        }
    },

    _createDependenciesToCallApplyInternalFunctionCall: function(callInternalFunctionCommand, args, callExpression)
    {
        if(!fcSimulator.DependencyCreator.shouldCreateDependencies) { return; }
        var evaluationPosition = this.globalObject.getPreciseEvaluationPositionId();

        if(callInternalFunctionCommand.isCall)
        {
            for(var i = 1, length = arguments.length; i < length; i++)
            {
                this.globalObject.browser.callDataDependencyEstablishedCallbacks(callExpression, args[i], evaluationPosition);
            }
        }
        else
        {
            var secondArgumentValue = this.executionContextStack.getExpressionValue(args[1]);

            if(secondArgumentValue != null && ValueTypeHelper.isArray(secondArgumentValue.jsValue))
            {
                secondArgumentValue.iValue.addDependenciesToAllProperties(callExpression);
            }
        }
    },

    _createSimpleDependenciesToCallApplyInternalFunctionCall: function(callInternalFunctionCommand, args, callExpression)
    {
        if(callInternalFunctionCommand.isCall)
        {
            for(var i = 1, length = arguments.length; i < length; i++)
            {
                this._createSimpleDependency(callExpression, args[i]);
            }
        }
        else
        {
            var secondArgumentValue = this.executionContextStack.getExpressionValue(args[1]);

            if(secondArgumentValue != null && ValueTypeHelper.isArray(secondArgumentValue.jsValue))
            {
                for(var i = 0; i < secondArgumentValue.jsValue.length; i++)
                {
                    if(secondArgumentValue.jsValue[i] != null)
                    {
                        this._createSimpleDependency(callExpression, secondArgumentValue.jsValue[i].codeConstruct);
                    }
                }
            }
        }
    },

    createSequenceExpressionDependencies: function(sequenceExpression, lastExpression)
    {
        if(fcSimulator.DependencyCreator.shouldCreateSimpleDependencies) { this._createSimpleSequenceExpressionDependencies(sequenceExpression, lastExpression); }
        if(!fcSimulator.DependencyCreator.shouldCreateDependencies) { return; }

        this.globalObject.browser.callDataDependencyEstablishedCallbacks
        (
            sequenceExpression,
            lastExpression,
            this.globalObject.getPreciseEvaluationPositionId()
        );
    },

    _createSimpleSequenceExpressionDependencies: function(sequenceExpression, lastExpression)
    {
        this._createSimpleDependency(sequenceExpression, lastExpression);
    },

    _createSimpleDependency: function(fromConstruct, toConstruct)
    {
        if(fromConstruct == null || toConstruct == null) { return; }

        this.globalObject.simpleDependencyEstablished(fromConstruct, toConstruct);
    }
};
/*************************************************************************************/
}});FBL.ns(function() { with (FBL) {
/*************************************************************************************/
var ValueTypeHelper = Firecrow.ValueTypeHelper;
var ASTHelper = Firecrow.ASTHelper;
var fcSimulator = Firecrow.Interpreter.Simulator;
var fcModel = Firecrow.Interpreter.Model;
var fcSymbolic = Firecrow.ScenarioGenerator.Symbolic;

fcSimulator.Evaluator = function(executionContextStack)
{
    try
    {
        this.executionContextStack = executionContextStack;
        this.globalObject = executionContextStack.globalObject;
        this.dependencyCreator = new fcSimulator.DependencyCreator(this.globalObject, this.executionContextStack);

        this.exceptionCallbacks = [];
    }
    catch(e) { fcSimulator.Evaluator.notifyError("Error when constructing evaluator: " + e);}
};

fcSimulator.Evaluator.notifyError = function(message) { alert("Evaluator - " + message); };

fcSimulator.Evaluator.prototype =
{
    registerExceptionCallback: function(callback, thisObject)
    {
        try
        {
            if(!ValueTypeHelper.isFunction(callback)) { this.notifyError(null, "Exception callback has to be a function!"); return; }

            this.exceptionCallbacks.push({callback: callback, thisObject: thisObject || this});
        }
        catch(e) { this.notifyError(null, "Error when registering exception callback:" + e);}
    },

    evaluateCommand: function(command)
    {
        try
        {

                 if (command.isEvalIdentifierCommand()) { this._evalIdentifierCommand(command); }
            else if (command.isEvalAssignmentExpressionCommand()) { this._evalAssignmentCommand(command); }
            else if (command.isEvalMemberExpressionCommand()) { this._evalMemberCommand(command); }
            else if (command.isEvalMemberExpressionPropertyCommand()) { this._evalMemberPropertyCommand(command); }
            else if (command.isThisExpressionCommand()) { this._evalThisCommand(command); }
            else if (command.isDeclareVariableCommand()) { this._evalDeclareVariableCommand(command); }
            else if (command.isDeclareFunctionCommand()) { this._evalDeclareFunctionCommand(command); }
            else if (command.isEvalLiteralCommand()) { this._evalLiteralCommand(command); }
            else if (command.isEvalRegExCommand()) { this._evalRegExLiteralCommand(command);}
            else if (command.isEvalUpdateExpressionCommand()) { this._evalUpdateCommand(command); }
            else if (command.isEvalUnaryExpressionCommand()) { this._evalUnaryExpression(command); }
            else if (command.isEvalBinaryExpressionCommand()) { this._evalBinaryCommand(command); }
            else if (command.isEvalLogicalExpressionItemCommand()) { this._evalLogicalItemCommand(command);}
            else if (command.isEndLogicalExpressionCommand()) { this._evalEndLogicalCommand(command); }
            else if (command.isEvalReturnExpressionCommand()) { this._evalReturnCommand(command); }
            else if (command.isObjectExpressionCommand()) { this._evalObjectCommand(command); }
            else if (command.isObjectPropertyCreationCommand()) { this._evalObjectPropertyCreationCommand(command);}
            else if (command.isArrayExpressionCommand()) { this._evalArrayExpressionCommand(command);}
            else if (command.isArrayExpressionItemCreationCommand()) { this._evalArrayExpressionItemCreationCommand(command);}
            else if (command.isFunctionExpressionCreationCommand()) { this._evalFunctionExpressionCreationCommand(command); }
            else if (command.isEvalForInWhereCommand()) { this._evalForInWhereCommand(command); }
            else if (command.isEndEvalConditionalExpressionCommand()) { this._evalConditionalCommand(command);}
            else if (command.isStartCatchStatementCommand()) { this._evalStartCatchStatementCommand(command);}
            else if (command.isEndCatchStatementCommand()) { this._evalEndCatchCommand(command);}
            else if (command.isCallInternalFunctionCommand()) { this._evalCallInternalFunction(command); }
            else if (command.isEvalCallbackFunctionCommand()) { this._evalCallbackFunctionCommand(command); }
            else if (command.isEvalSequenceExpressionCommand()) { this._evalSequence(command); }
            else if (command.isEvalThrowExpressionCommand()) { this._evalThrowExpressionCommand(command); }
            else
            {
                this.notifyError(command, "Evaluator: Still not handling command of type: " +  command.type); return;
            }
        }
        catch(e)
        {
            this.notifyError(command, "An error occurred when evaluating command: " + e + " " + e.fileName + " " + e.lineNumber);
        }
    },

    evalBreakContinueCommand: function(breakContinueCommand)
    {
        try
        {
            this.dependencyCreator.addDependenciesToTopBlockConstructs(breakContinueCommand.codeConstruct);
            this.globalObject.browser.callBreakContinueReturnEventCallbacks(breakContinueCommand.codeConstruct, this.globalObject.getPreciseEvaluationPositionId());

            this.globalObject.browser.logConstructExecuted(breakContinueCommand.codeConstruct);
            this.dependencyCreator.createBreakContinueDependencies(breakContinueCommand.codeConstruct);
        }
        catch(e) { this.notifyError(breakContinueCommand, "Error when evaluating break or continue command: " + e);}
    },

    _evalDeclareVariableCommand: function(declareVariableCommand)
    {
        this.executionContextStack.registerIdentifier(declareVariableCommand.codeConstruct);

        this.globalObject.browser.logConstructExecuted(declareVariableCommand.codeConstruct);
    },

    _evalDeclareFunctionCommand: function(declareFunctionCommand)
    {
        this.executionContextStack.registerFunctionDeclaration(declareFunctionCommand.codeConstruct);

        this.globalObject.browser.logConstructExecuted(declareFunctionCommand.codeConstruct);
    },

    _evalFunctionExpressionCreationCommand: function(functionCommand)
    {
        this.executionContextStack.setExpressionValue(functionCommand.codeConstruct, this.executionContextStack.createFunctionInCurrentContext(functionCommand.codeConstruct));

        this.globalObject.browser.logConstructExecuted(functionCommand.codeConstruct);
    },

    _evalLiteralCommand: function(evalLiteralCommand)
    {
        this.executionContextStack.setExpressionValue
        (
            evalLiteralCommand.codeConstruct,
            this.globalObject.internalExecutor.createInternalPrimitiveObject(evalLiteralCommand.codeConstruct, evalLiteralCommand.codeConstruct.value)
        );

        this.globalObject.browser.logConstructExecuted(evalLiteralCommand.codeConstruct);
    },

    _evalRegExLiteralCommand: function(evalRegExCommand)
    {
        var regEx = evalRegExCommand.regExLiteral instanceof RegExp ? evalRegExCommand.regExLiteral
                                                                    : eval(evalRegExCommand.regExLiteral);

        this.executionContextStack.setExpressionValue
        (
            evalRegExCommand.codeConstruct,
            this.globalObject.internalExecutor.createRegEx(evalRegExCommand.codeConstruct, regEx)
        );

        this.globalObject.browser.logConstructExecuted(evalRegExCommand.codeConstruct);
    },

    _evalAssignmentCommand: function(assignmentCommand)
    {
        var assignmentExpression = assignmentCommand.codeConstruct;

        this.dependencyCreator.createAssignmentDependencies(assignmentCommand);

        var finalValue = this._getAssignmentValue(assignmentCommand);

        if(ASTHelper.isIdentifier(assignmentCommand.leftSide)) { this._assignToIdentifier(assignmentCommand.leftSide, finalValue, assignmentExpression); }
        else if (ASTHelper.isMemberExpression(assignmentCommand.leftSide)) { this._assignToMemberExpression(assignmentCommand.leftSide, finalValue, assignmentExpression, assignmentCommand); }

        this.executionContextStack.setExpressionValue(assignmentExpression, finalValue);

        this.globalObject.browser.logConstructExecuted(assignmentExpression);
        this.globalObject.browser.logConstructExecuted(assignmentCommand.leftSide);
        this.globalObject.browser.logConstructExecuted(assignmentCommand.rightSide);
    },

    _evalUpdateCommand: function(evalUpdateCommand)
    {
        var updateExpression = evalUpdateCommand.codeConstruct;
        var currentValue = this.executionContextStack.getExpressionValue(updateExpression.argument);

        this.dependencyCreator.createUpdateExpressionDependencies(updateExpression);

        if(currentValue == null || currentValue.jsValue == null) { this._callExceptionCallbacks(evalUpdateCommand); return; }

        if(ASTHelper.isIdentifier(updateExpression.argument))
        {
            this._assignToIdentifier(updateExpression.argument, this._getUpdateValue(currentValue, updateExpression), updateExpression);
        }
        else if(ASTHelper.isMemberExpression(updateExpression.argument))
        {
            this._assignToMemberExpression(updateExpression.argument, this._getUpdateValue(currentValue, updateExpression), updateExpression, evalUpdateCommand);
        }
        else
        {
            this.notifyError(evalUpdateCommand, "Unknown code construct when updating expression!");
        }

        this.executionContextStack.setExpressionValue(updateExpression, this._getUpdatedCurrentValue(currentValue, updateExpression));

        this.globalObject.browser.logConstructExecuted(updateExpression);
        this.globalObject.browser.logConstructExecuted(updateExpression.argument);
    },

    _evalIdentifierCommand: function(identifierCommand)
    {
        var identifierConstruct = identifierCommand.codeConstruct;

        //if(identifierConstruct.nodeId == 99071)debugger
        //if(identifierConstruct.loc != null && identifierConstruct.loc.start.line == 2538) debugger;
        var identifier = this.executionContextStack.getIdentifier(identifierConstruct.name, identifierConstruct);
        var identifierValue = identifier != null ? identifier.value : null;
        this.executionContextStack.setExpressionValue
        (
            identifierConstruct,
            identifierValue != null && identifierValue.isPrimitive && identifierValue.isPrimitive() ? identifierValue.createCopy() : identifierValue
        );

        if(identifier != null)
        {
            this.dependencyCreator.createIdentifierDependencies(identifier, identifierConstruct, this.globalObject.getPreciseEvaluationPositionId());
            this._checkSlicing(identifierConstruct);
        }

        this.globalObject.browser.logConstructExecuted(identifierConstruct);
    },

    _evalMemberCommand: function(memberCommand)
    {
        var memberExpression = memberCommand.codeConstruct;

        var object = this.executionContextStack.getExpressionValue(memberExpression.object);
        //if(memberExpression.nodeId == 376) debugger;
        //if(memberExpression.loc != null && memberExpression.loc.start.line == 8589) debugger;

        if(object == null || (object.jsValue == null && object != this.globalObject)) { this._callExceptionCallbacks(memberCommand); return; }

        this.globalObject.browser.callExpressionEvaluatedCallbacks(memberExpression.object);

        var property = this.executionContextStack.getExpressionValue(memberExpression.property);
        var propertyValue = this._getPropertyValue(object, property, memberExpression);

        this.dependencyCreator.createMemberExpressionDependencies(object, property, propertyValue, memberExpression);

        this.executionContextStack.setExpressionValue(memberExpression, propertyValue);

        var propertyObject = object.iValue.getProperty(property.jsValue);

        if(propertyObject == null || propertyObject.modificationContext != this.executionContextStack.activeContext)
        {
            var creationConstructId = object.iValue.creationCodeConstruct != null ? object.iValue.creationCodeConstruct.nodeId : -1;
            this.globalObject.browser.logReadingObjectPropertyOutsideCurrentScope(creationConstructId, property.jsValue, memberExpression);
        }

        this.globalObject.browser.logConstructExecuted(memberExpression);
    },

    _evalMemberPropertyCommand: function(memberPropertyCommand)
    {
        var memberExpression = memberPropertyCommand.codeConstruct;
        var property = memberExpression.property;

        this.executionContextStack.setExpressionValue
        (
            property,
            memberExpression.computed ? this.executionContextStack.getExpressionValue(property)
                                      : this.globalObject.internalExecutor.createInternalPrimitiveObject(property, property.name)
        );

        this.globalObject.browser.logConstructExecuted(property);
    },

    _evalThisCommand: function(thisCommand)
    {
        this.executionContextStack.setExpressionValue(thisCommand.codeConstruct, this.executionContextStack.activeContext.thisObject);

        this.globalObject.browser.logConstructExecuted(thisCommand.codeConstruct);
    },

    _evalUnaryExpression: function(unaryCommand)
    {
        var unaryExpression = unaryCommand.codeConstruct;
        var argumentValue = this.executionContextStack.getExpressionValue(unaryExpression.argument);

        this.dependencyCreator.createDataDependency(unaryExpression, unaryExpression.argument);

        if(argumentValue == null && unaryExpression.operator != "typeof") { this._callExceptionCallbacks(unaryCommand); return; }

        var expressionValue = null;

        if (unaryExpression.operator == "-") { expressionValue = -argumentValue.jsValue; }
        else if (unaryExpression.operator == "+") { expressionValue = +argumentValue.jsValue; }
        else if (unaryExpression.operator == "!") { expressionValue = !argumentValue.jsValue; }
        else if (unaryExpression.operator == "~") { expressionValue = ~argumentValue.jsValue; }
        else if (unaryExpression.operator == "typeof") { expressionValue = argumentValue == null ? "undefined" : typeof argumentValue.jsValue; }
        else if (unaryExpression.operator == "void") { expressionValue = void argumentValue.jsValue;}
        else if (unaryExpression.operator == "delete") { expressionValue = this._evalDeleteExpression(unaryExpression, unaryCommand); }

        this.executionContextStack.setExpressionValue(unaryExpression, this.globalObject.internalExecutor.createInternalPrimitiveObject(unaryExpression, expressionValue));

        this.globalObject.browser.logConstructExecuted(unaryExpression);
    },

    _evalBinaryCommand: function(binaryCommand)
    {
        var binaryExpression = binaryCommand.codeConstruct;

        this.dependencyCreator.createBinaryExpressionDependencies(binaryExpression);

        var leftValue = this.executionContextStack.getExpressionValue(binaryExpression.left);
        var rightValue = this.executionContextStack.getExpressionValue(binaryExpression.right);

        if(leftValue == null) { this._callExceptionCallbacks(binaryCommand); return; }
        if(rightValue == null) { this._callExceptionCallbacks(binaryCommand); return; }

        if(binaryExpression.operator == "in")
        {
            this.dependencyCreator.createBinaryExpressionInDependencies(binaryExpression, rightValue, leftValue);
        }

        var result = this._evalBinaryExpression(leftValue, rightValue, binaryExpression.operator);

        this.executionContextStack.setExpressionValue
        (
            binaryExpression,
            this.globalObject.internalExecutor.createInternalPrimitiveObject
            (
                binaryExpression,
                result,
                fcSymbolic.SymbolicExecutor.evalBinaryExpression(leftValue, rightValue, binaryExpression.operator)
            )
        );

        this.globalObject.browser.logConstructExecuted(binaryExpression);
    },

    _evalReturnCommand: function(returnCommand)
    {
        this.dependencyCreator.createReturnDependencies(returnCommand);
        if(returnCommand.codeConstruct.loc.start.line == 101) debugger;

        this.globalObject.browser.logConstructExecuted(returnCommand.codeConstruct);
        this.globalObject.browser.callBreakContinueReturnEventCallbacks
        (
            returnCommand.codeConstruct,
            this.globalObject.getPreciseEvaluationPositionId(),
            returnCommand.parentFunctionCommand && returnCommand.parentFunctionCommand.isExecuteCallbackCommand()
        );

        //If return is in event handler function
        if(returnCommand.parentFunctionCommand == null)
        {
            return;
        }

        returnCommand.parentFunctionCommand.executedReturnCommand = returnCommand;

        var returnValue = this.executionContextStack.getExpressionValue(returnCommand.codeConstruct.argument);

        if(returnCommand.parentFunctionCommand.isExecuteCallbackCommand())
        {
            this._handleReturnFromCallbackFunction(returnCommand);
        }
        else if (returnCommand.parentFunctionCommand.isEvalNewExpressionCommand()
             && (returnValue.isPrimitive() || returnValue.jsValue == null))
        {
            //DO NOTHING, should only write if returnValue is not a primitive
        }
        else
        {
            this.executionContextStack.setExpressionValueInPreviousContext
            (
                returnCommand.parentFunctionCommand.codeConstruct,
                returnCommand.codeConstruct.argument != null ? returnValue
                                                             : null
            );
        }
    },

    _evalArrayExpressionCommand: function(arrayExpressionCommand)
    {
        var newArray = this.globalObject.internalExecutor.createArray(arrayExpressionCommand.codeConstruct);

        this.executionContextStack.setExpressionValue(arrayExpressionCommand.codeConstruct, newArray);

        arrayExpressionCommand.createdArray = newArray;

        this.globalObject.browser.logConstructExecuted(arrayExpressionCommand.codeConstruct);
    },

    _evalArrayExpressionItemCreationCommand: function(arrayItemCreationCommand)
    {
        var array = arrayItemCreationCommand.arrayExpressionCommand.createdArray;

        if(array == null || array.jsValue == null) { this.notifyError(arrayItemCreationCommand, "When evaluating array expression item the array must not be null!");  return; }

        var expressionItemValue = this.executionContextStack.getExpressionValue(arrayItemCreationCommand.codeConstruct);

        array.iValue.push(array.jsValue, expressionItemValue, arrayItemCreationCommand.codeConstruct);

        this.dependencyCreator.createDataDependency(arrayItemCreationCommand.arrayExpressionCommand.codeConstruct, arrayItemCreationCommand.codeConstruct, this.globalObject.getPreciseEvaluationPositionId());

        this.globalObject.browser.logConstructExecuted(arrayItemCreationCommand.codeConstruct);
    },

    _evalObjectCommand: function(objectCommand)
    {
        var newObject = this.globalObject.internalExecutor.createObject(null, objectCommand.codeConstruct);

        this.executionContextStack.setExpressionValue(objectCommand.codeConstruct, newObject);

        objectCommand.createdObject = newObject;

        this.globalObject.browser.logConstructExecuted(objectCommand.codeConstruct);
    },

    _evalObjectPropertyCreationCommand: function(objectPropertyCreationCommand)
    {
        var object = objectPropertyCreationCommand.objectExpressionCommand.createdObject;

        if(object == null || object.jsValue == null) { this.notifyError(objectPropertyCreationCommand, "When evaluating object property the object must not be null!");  return; }

        var propertyCodeConstruct = objectPropertyCreationCommand.codeConstruct;

        var propertyValue = this.executionContextStack.getExpressionValue(propertyCodeConstruct.value);

        propertyValue = propertyValue.isPrimitive() ? propertyValue.createCopy(propertyCodeConstruct) : propertyValue;

        var propertyKey = ASTHelper.isLiteral(propertyCodeConstruct.key) ? propertyCodeConstruct.key.value
                                                                         : propertyCodeConstruct.key.name;

        object.jsValue[propertyKey] = propertyValue;
        object.iValue.addProperty(propertyKey, propertyValue, objectPropertyCreationCommand.codeConstruct);

        this.globalObject.browser.logConstructExecuted(propertyCodeConstruct);
        this.globalObject.browser.logConstructExecuted(propertyCodeConstruct.key);
        this.globalObject.browser.logConstructExecuted(propertyCodeConstruct.key.value);
    },

    _evalConditionalCommand: function(conditionalCommand)
    {
        this.executionContextStack.setExpressionValue(conditionalCommand.codeConstruct, this.executionContextStack.getExpressionValue(conditionalCommand.startCommand.body));

        this.dependencyCreator.createDependenciesForConditionalCommand(conditionalCommand);

        this.globalObject.browser.logConstructExecuted(conditionalCommand.codeConstruct);
    },

    _evalForInWhereCommand: function(forInWhereCommand)
    {
        var forInWhereConstruct = forInWhereCommand.codeConstruct;

        var whereObject = this.executionContextStack.getExpressionValue(forInWhereConstruct.right);

        if(whereObject.iValue == null) { forInWhereCommand.willBodyBeExecuted = false; return; }

        if(!forInWhereCommand.propertyNames)
        {
            var isFirstIteration = true;
            forInWhereCommand.propertyNames = whereObject.iValue.getPropertyNames();
        }

        this._logForInIteration(forInWhereCommand, whereObject.iValue, isFirstIteration);

        while(forInWhereCommand.propertyNames.length > 0 && !propertyValue)
        {
            var nextPropertyNameString = forInWhereCommand.propertyNames[0];
            ValueTypeHelper.removeFromArrayByIndex(forInWhereCommand.propertyNames, 0);

            var propertyValue = whereObject.iValue.getPropertyValue(nextPropertyNameString);
        }

        forInWhereCommand.willBodyBeExecuted = !!propertyValue;

        if(!propertyValue) { return; }

        var propertyNameCodeConstruct = null;

        var property = whereObject.iValue.getProperty(nextPropertyNameString);

        if(property != null && property.declarationPosition != null && property.declarationPosition.codeConstruct != null)
        {
            var declarationConstruct = property.declarationPosition.codeConstruct;
            if(declarationConstruct.key != null) //Object literal
            {
                propertyNameCodeConstruct = declarationConstruct.key;
            }
            else if(ASTHelper.isAssignmentExpression()) //Assignment
            {
                propertyNameCodeConstruct = declarationConstruct.left;
            }
        }
        else
        {
            propertyNameCodeConstruct = forInWhereConstruct.left;
        }

        var nextPropertyName = this.globalObject.internalExecutor.createInternalPrimitiveObject(propertyNameCodeConstruct, nextPropertyNameString);

        this.dependencyCreator.createDependenciesInForInWhereCommand(forInWhereConstruct, whereObject, nextPropertyName, isFirstIteration);

        if(ASTHelper.isIdentifier(forInWhereConstruct.left))
        {
            this.executionContextStack.setIdentifierValue(forInWhereConstruct.left.name, nextPropertyName, forInWhereConstruct.left);
        }
        else if (ASTHelper.isVariableDeclaration(forInWhereConstruct.left))
        {
            var declarator = forInWhereConstruct.left.declarations[0];

            this.executionContextStack.setIdentifierValue(declarator.id.name, nextPropertyName, declarator);
        }
        else { this.notifyError(forInWhereCommand, "Unknown forIn left statement"); }

        this.globalObject.browser.logConstructExecuted(forInWhereConstruct);
    },

    _evalThrowExpressionCommand: function(throwCommand)
    {
        this.dependencyCreator.createDataDependency
        (
            throwCommand.codeConstruct,
            throwCommand.codeConstruct.argument,
            this.globalObject.getPreciseEvaluationPositionId()
        )
    },

    _evalStartCatchStatementCommand: function(startCatchCommand)
    {
        this.executionContextStack.setIdentifierValue
        (
            startCatchCommand.codeConstruct.param.name,
            startCatchCommand.exceptionArgument || this.globalObject.internalExecutor.createNonConstructorObject(startCatchCommand.codeConstruct),
            startCatchCommand.throwingCommand != null ? startCatchCommand.throwingCommand.codeConstruct
                                                      : null,
            true
         );

        this.globalObject.browser.logConstructExecuted(startCatchCommand.codeConstruct);

        if(startCatchCommand.exceptionArgument != null && startCatchCommand.exceptionArgument.codeConstruct != null)
        {
            this.dependencyCreator.createDataDependency(startCatchCommand.codeConstruct.param, startCatchCommand.exceptionArgument.codeConstruct);
        }
    },

    _evalEndCatchCommand: function(endCatchCommand)
    {
        this.executionContextStack.restoreIdentifier(endCatchCommand.codeConstruct.param.name);
    },

    _evalLogicalItemCommand: function(evalLogicalItemCommand)
    {
        var parentExpressionCommand = evalLogicalItemCommand.parentLogicalExpressionCommand;

        var wholeLogicalExpression = parentExpressionCommand.codeConstruct;
        var logicalExpressionItem = evalLogicalItemCommand.codeConstruct;

        evalLogicalItemCommand.parentEndLogicalExpressionCommand.executedLogicalItemExpressionCommands.push(evalLogicalItemCommand);

        if(logicalExpressionItem == wholeLogicalExpression.left)
        {
            var value = this.executionContextStack.getExpressionValue(logicalExpressionItem);

            this.executionContextStack.setExpressionValue(wholeLogicalExpression, value);

            evalLogicalItemCommand.shouldDeleteFollowingLogicalCommands = this._isLogicalExpressionDoneWithEvaluation(value, wholeLogicalExpression.operator);
        }
        else if(logicalExpressionItem == wholeLogicalExpression.right)
        {
            this.executionContextStack.setExpressionValue(wholeLogicalExpression, this._getLogicalExpressionValue(wholeLogicalExpression, evalLogicalItemCommand));

            this.dependencyCreator.createDependenciesForLogicalExpressionItemCommand(wholeLogicalExpression);
        }
        else { this.notifyError(evalLogicalItemCommand, "The expression item is neither left nor right expression"); return; }

        this.globalObject.browser.logConstructExecuted(logicalExpressionItem);
    },

    _evalEndLogicalCommand: function(endLogicalCommand)
    {
        this.dependencyCreator.createDependenciesForLogicalExpression(endLogicalCommand);

        var logicalExpression = endLogicalCommand.codeConstruct;
        var logicalExpressionValue = this.executionContextStack.getExpressionValue(logicalExpression);

        if(logicalExpressionValue != null)
        {
            var executedLogicalItemCommands = endLogicalCommand.executedLogicalItemExpressionCommands;

            if(executedLogicalItemCommands.length == 0) { alert("There are no executed logical commands"); return; }

            logicalExpressionValue.symbolicValue = fcSymbolic.SymbolicExecutor.evalLogicalExpression
            (
                executedLogicalItemCommands[0] != null ?  this.executionContextStack.getExpressionValue(executedLogicalItemCommands[0].codeConstruct) : null,
                executedLogicalItemCommands[1] != null ?  this.executionContextStack.getExpressionValue(executedLogicalItemCommands[1].codeConstruct) : null,
                logicalExpression.operator
            );
        }

        this.globalObject.browser.logConstructExecuted(logicalExpression);
    },

    _evalCallInternalFunction: function(callInternalFunctionCommand)
    {
        this.dependencyCreator.createDependenciesForCallInternalFunction(callInternalFunctionCommand);

        this.executionContextStack.setExpressionValue
        (
            callInternalFunctionCommand.codeConstruct,
            this.globalObject.internalExecutor.executeFunction
            (
                this._getThisObjectFromCallInternalFunctionCommand(callInternalFunctionCommand),
                callInternalFunctionCommand.functionObject,
                this._getArgumentsFromInternalFunctionCall
                (
                    callInternalFunctionCommand,
                    callInternalFunctionCommand.codeConstruct != null ? callInternalFunctionCommand.codeConstruct.arguments
                                                                      : []
                ),
                callInternalFunctionCommand.codeConstruct,
                callInternalFunctionCommand
            )
        );

        this.globalObject.browser.logConstructExecuted(callInternalFunctionCommand.codeConstruct);
    },

    _evalCallbackFunctionCommand: function(callbackFunctionCommand)
    {
        this.dependencyCreator.createCallbackFunctionCommandDependencies(callbackFunctionCommand);

        this.globalObject.logCallbackExecution
        (
            callbackFunctionCommand.codeConstruct,
            callbackFunctionCommand.parentInitCallbackCommand != null ? callbackFunctionCommand.parentInitCallbackCommand.codeConstruct
                                                                      : null
        );

        if(callbackFunctionCommand.isLastCallbackCommand)
        {
            this.globalObject.browser.logEndExecutingCallbacks(callbackFunctionCommand.codeConstruct);
        }
    },

    _evalSequence: function(sequenceCommand)
    {
        var sequenceExpression = sequenceCommand.codeConstruct;
        var lastExpression = sequenceExpression.expressions[sequenceExpression.expressions.length - 1];

        this.executionContextStack.setExpressionValue(sequenceExpression, this.executionContextStack.getExpressionValue(lastExpression));

        this.dependencyCreator.createSequenceExpressionDependencies(sequenceExpression, lastExpression);

        this.globalObject.browser.logConstructExecuted(sequenceExpression);
    },

    _getAssignmentValue: function(assignmentCommand)
    {
        var finalValue = null;
        var operator = assignmentCommand.operator;

        if(operator === "=") { finalValue = this.executionContextStack.getExpressionValue(assignmentCommand.rightSide); }
        else
        {
            var leftValue = this.executionContextStack.getExpressionValue(assignmentCommand.leftSide);
            var rightValue = this.executionContextStack.getExpressionValue(assignmentCommand.rightSide);

            var result = null;

                 if (operator == "+=") { result = leftValue.jsValue + rightValue.jsValue; }
            else if (operator == "-=") { result = leftValue.jsValue - rightValue.jsValue; }
            else if (operator == "*=") { result = leftValue.jsValue * rightValue.jsValue; }
            else if (operator == "/=") { result = leftValue.jsValue / rightValue.jsValue; }
            else if (operator == "%=") { result = leftValue.jsValue % rightValue.jsValue; }
            else if (operator == "<<=") { result = leftValue.jsValue << rightValue.jsValue; }
            else if (operator == ">>=") { result = leftValue.jsValue >> rightValue.jsValue; }
            else if (operator == ">>>=") { result = leftValue.jsValue >>> rightValue.jsValue; }
            else if (operator == "|=") { result = leftValue.jsValue | rightValue.jsValue; }
            else if (operator == "^=") { result = leftValue.jsValue ^ rightValue.jsValue; }
            else if (operator == "&=") { result = leftValue.jsValue & rightValue.jsValue; }
            else { this.notifyError(assignmentCommand, "jsValue assignment operator!"); return; }

            finalValue = this.globalObject.internalExecutor.createInternalPrimitiveObject(assignmentCommand.codeConstruct, result);
        }

        return finalValue.isPrimitive() ? finalValue.createCopy(assignmentCommand.rightSide) : finalValue;
    },

    _assignToIdentifier: function(identifier, finalValue, assignmentExpression)
    {
        if(this.globalObject.satisfiesIdentifierSlicingCriteria(identifier))
        {
            this.globalObject.browser.callImportantConstructReachedCallbacks(identifier);
        }

        this.executionContextStack.setIdentifierValue(identifier.name, finalValue, assignmentExpression);
    },

    _assignToMemberExpression: function(memberExpression, finalValue, assignmentExpression, command)
    {
        var object = this.executionContextStack.getExpressionValue(memberExpression.object);
        var property = this.executionContextStack.getExpressionValue(memberExpression.property);

        if(object == null || (object.jsValue == null && object != this.globalObject)) { this._callExceptionCallbacks(command); return; }

        if (this._hasAddJsPropertyFunction(object))
        {
            object.iValue.addJsProperty(property.jsValue, finalValue, assignmentExpression);
        }
        else
        {
            object.iValue.addProperty(property.jsValue, finalValue, assignmentExpression, true);
            object.jsValue[property.jsValue] = finalValue;
        }

        if(property.jsValue == "__proto__" || property.jsValue == "prototype")
        {
            object.jsValue[property.jsValue] = finalValue.jsValue;
        }

        var newProperty = object.iValue.getProperty(property.jsValue);

        if(newProperty != null)
        {
            newProperty.modificationContext = this.executionContextStack.activeContext;
        }

        if(object.iValue.creationContext != this.executionContextStack.activeContext)
        {
            //TODO HOW DO I UNIQUELY DIFFERENTIATE BETWEEN OBJECTS!?
            var objectCreationConstructId = object.iValue.creationCodeConstruct != null ? object.iValue.creationCodeConstruct.nodeId : -1;
            this.globalObject.browser.logModifyingExternalContextObject(objectCreationConstructId, property.jsValue);
        }
    },

    _hasAddJsPropertyFunction: function(object)
    {
        return object != null && object.iValue != null && object.iValue.addJsProperty != null;
    },

    _getUpdateValue: function(currentValue, updateExpression)
    {
        var result = updateExpression.operator == "++" ? (currentValue.jsValue - 0) + 1 : (currentValue.jsValue - 0) - 1;
        return this.globalObject.internalExecutor.createInternalPrimitiveObject(updateExpression, result);
    },

    _getUpdatedCurrentValue:function(currentValue, updateExpression)
    {
        var result = updateExpression.prefix ? updateExpression.operator == "++" ? ++currentValue.jsValue : --currentValue.jsValue
                                             : updateExpression.operator == "++" ? currentValue.jsValue++ : currentValue.jsValue--;

        return this.globalObject.internalExecutor.createInternalPrimitiveObject(updateExpression, result);
    },

    _checkSlicing: function(identifierConstruct)
    {
        if(this.globalObject.shouldTrackIdentifiers && this.globalObject.satisfiesIdentifierSlicingCriteria(identifierConstruct))
        {
            this.globalObject.browser.callImportantConstructReachedCallbacks(identifierConstruct);
        }
    },

    _evalBinaryExpression: function(leftValue, rightValue, operator)
    {
             if (operator == "==") { return leftValue.jsValue == rightValue.jsValue;}
        else if (operator == "!=") { return leftValue.jsValue != rightValue.jsValue; }
        else if (operator == "===") { return leftValue.jsValue === rightValue.jsValue; }
        else if (operator == "!==") { return leftValue.jsValue !== rightValue.jsValue; }
        else if (operator == "<") { return leftValue.jsValue < rightValue.jsValue; }
        else if (operator == "<=") { return leftValue.jsValue <= rightValue.jsValue; }
        else if (operator == ">") { return leftValue.jsValue > rightValue.jsValue; }
        else if (operator == ">=") { return leftValue.jsValue >= rightValue.jsValue; }
        else if (operator == "<<") { return leftValue.jsValue << rightValue.jsValue; }
        else if (operator == ">>") { return leftValue.jsValue >> rightValue.jsValue; }
        else if (operator == ">>>") { return leftValue.jsValue >>> rightValue.jsValue; }
        else if (operator == "-") { return leftValue.jsValue - rightValue.jsValue; }
        else if (operator == "*") { return leftValue.jsValue * rightValue.jsValue; }
        else if (operator == "/") { return leftValue.jsValue / rightValue.jsValue; }
        else if (operator == "%") { return leftValue.jsValue % rightValue.jsValue; }
        else if (operator == "|") { return leftValue.jsValue | rightValue.jsValue; }
        else if (operator == "^") { return leftValue.jsValue ^ rightValue.jsValue; }
        else if (operator == "&") { return leftValue.jsValue & rightValue.jsValue; }
        else if (operator == "in") { return leftValue.jsValue in rightValue.jsValue; }
        else if (operator == "+") { return this._evalAdd(leftValue.jsValue, rightValue.jsValue); }
        else if (operator == "instanceof") { return this._evalInstanceOf(leftValue, rightValue);}
        else { this.notifyError(null, "Unknown operator when evaluating binary expression"); return; }
    },

    _evalAdd: function(leftValue, rightValue)
    {
        if(ValueTypeHelper.arePrimitive(leftValue, rightValue))
        {
            return leftValue + rightValue;
        }

        //TODO - this needs more tests!
        if(typeof leftValue== "object" && !(leftValue instanceof String) && leftValue != null
       || (typeof rightValue== "object" && !(rightValue instanceof String) && rightValue != null))
        {
            //TODO - temp jQuery hack
            if(ValueTypeHelper.isArray(leftValue) && ValueTypeHelper.isArray(rightValue))
            {
                return this.globalObject.getJsValues(leftValue).join("")
                     + this.globalObject.getJsValues(rightValue).join("")
            }
            else if (ValueTypeHelper.isObject(rightValue) || ValueTypeHelper.isObject(leftValue))
            {
                console.log("Concatenating strings from object!");
                return leftValue + rightValue;
            }
            else
            {
                this.notifyError(null, "Still not handling implicit toString conversion in binary expression!");
                return null;
            }
        }

        return null;
    },

    _evalInstanceOf: function(leftValue, rightValue)
    {
        var compareWith = null;

        if(rightValue == this.globalObject.arrayFunction || rightValue.jsValue == this.globalObject.arrayFunction) { compareWith = Array; }
        else if (rightValue == this.globalObject.stringFunction || rightValue.jsValue == this.globalObject.stringFunction) { compareWith = String; }
        else if (rightValue == this.globalObject.regExFunction || rightValue.jsValue == this.globalObject.regExFunction) { compareWith = RegExp; }
        else if (rightValue.jsValue != undefined) { compareWith = rightValue.jsValue; }
        else { this.notifyError(null, "Unhandled instanceof"); }

        return leftValue.jsValue instanceof compareWith;
    },

    _handleReturnFromCallbackFunction: function(returnCommand)
    {
        var executeCallbackCommand = returnCommand.parentFunctionCommand;
        var returnArgument = returnCommand.codeConstruct.argument;

        if(ValueTypeHelper.isArray(executeCallbackCommand.originatingObject.jsValue)
        || ValueTypeHelper.isArrayLike(executeCallbackCommand.originatingObject.jsValue))
        {
            fcModel.ArrayCallbackEvaluator.evaluateCallbackReturn
            (
                executeCallbackCommand,
                returnArgument != null ? this.executionContextStack.getExpressionValue(returnArgument)
                                       : null,
                returnCommand.codeConstruct
            );
        }
        else if(ValueTypeHelper.isString(executeCallbackCommand.originatingObject.jsValue))
        {
            fcModel.StringExecutor.evaluateCallbackReturn
            (
                executeCallbackCommand,
                returnArgument != null ? this.executionContextStack.getExpressionValue(returnArgument)
                                       : null,
                returnCommand.codeConstruct,
                this.globalObject
            );
        }
        else { this.notifyError(returnCommand, "Unhandled callback function"); }
    },

    _getPropertyValue: function(object, property, memberExpression)
    {
        try
        {
            var propertyValue = object.iValue.getJsPropertyValue(property.jsValue, memberExpression);
        }
        catch(e) { debugger; }


        if(!ValueTypeHelper.isOfType(propertyValue, fcModel.fcValue) && propertyValue != this.globalObject)
        {
            if(propertyValue != null && propertyValue.fcValue != null && !ValueTypeHelper.isPrimitive(propertyValue)) { propertyValue = propertyValue.fcValue; }
            else if (ValueTypeHelper.isPrimitive(propertyValue)) { propertyValue = this.globalObject.internalExecutor.createInternalPrimitiveObject(memberExpression, propertyValue);}
            else { this.notifyError(null, "The property value should be of type JsValue"); return; }
        }

        return propertyValue;
    },

    _isLogicalExpressionDoneWithEvaluation: function(value, operator)
    {
        return  (value.jsValue && operator == "||") || (!value.jsValue && operator == "&&");
    },

    _getLogicalExpressionValue: function(wholeLogicalExpression, command)
    {
        var leftValue = this.executionContextStack.getExpressionValue(wholeLogicalExpression.left);
        var rightValue = this.executionContextStack.getExpressionValue(wholeLogicalExpression.right);

        if(leftValue == null || rightValue == null) { this._callExceptionCallbacks(command); return; }

        var result = wholeLogicalExpression.operator == "&&" ? leftValue.jsValue && rightValue.jsValue
                                                             : leftValue.jsValue || rightValue.jsValue;

        return ValueTypeHelper.isPrimitive(result) ? this.globalObject.internalExecutor.createInternalPrimitiveObject(wholeLogicalExpression, result)
                                                   : result === leftValue.jsValue ? leftValue : rightValue;
    },

    _evalDeleteExpression: function(deleteExpression, command)
    {
        if(ASTHelper.isIdentifier(deleteExpression.argument))
        {
            this.executionContextStack.deleteIdentifier(deleteExpression.argument.name);
            return true;
        }
        else if(ASTHelper.isMemberExpression(deleteExpression.argument))
        {
            var object = this.executionContextStack.getExpressionValue(deleteExpression.argument.object);

            if(object == null) { this._callExceptionCallbacks(command); return; }

            var propertyName = "";

            if(deleteExpression.argument.computed)
            {
                var propertyValue = this.executionContextStack.getExpressionValue(deleteExpression.argument.property);
                propertyName = propertyValue != null ? propertyValue.jsValue : "";
            }
            else
            {
                propertyName = deleteExpression.argument.property.name;
            }

            object.iValue.deleteProperty(propertyName, deleteExpression);
            return delete object.jsValue[propertyName];
        }

        return false;
    },

    _getThisObjectFromCallInternalFunctionCommand: function(callInternalFunctionCommand)
    {
        return callInternalFunctionCommand.isCall || callInternalFunctionCommand.isApply
            ? this.executionContextStack.getExpressionValue(callInternalFunctionCommand.codeConstruct.arguments[0])
            : callInternalFunctionCommand.thisObject;
    },

    _getArgumentsFromInternalFunctionCall: function(callInternalFunctionCommand, callExpressionArgs)
    {
        if(callInternalFunctionCommand.isCall)
        {
            return this.executionContextStack.getExpressionsValues(ValueTypeHelper.getWithoutFirstElement(callExpressionArgs));
        }

        if(callInternalFunctionCommand.isApply)
        {
            var secondArgumentValue = this.executionContextStack.getExpressionValue(callExpressionArgs[1]);

            return secondArgumentValue != null && secondArgumentValue.jsValue != null ? secondArgumentValue.jsValue : [];
        }
        return callExpressionArgs == null ? [] : this.executionContextStack.getExpressionsValues(callExpressionArgs);
    },

    _logForInIteration: function(forInWhereCommand, whereObject, isFirstIteration)
    {
        if(forInWhereCommand == null || !isFirstIteration || whereObject == null) { return; }

        this.globalObject.logForInIteration(forInWhereCommand.codeConstruct, whereObject.proto);
    },

    _callExceptionCallbacks: function(exceptionInfo)
    {
        this.exceptionCallbacks.forEach(function(callbackObject)
        {
            callbackObject.callback.call(callbackObject.thisObject, exceptionInfo);
        });
    },

    notifyError: function(command, message)
    {
        debugger;
        fcSimulator.Evaluator.notifyError(message + "@" + (command != null ? (command.codeConstruct.loc.source + " - Ln:" + command.codeConstruct.loc.start.line) : ""));
    }
};
}});FBL.ns(function() { with (FBL) {
    /*************************************************************************************/
    var ExecutionContextStack = Firecrow.Interpreter.Simulator.ExecutionContextStack;
    var Command = Firecrow.Interpreter.Commands.Command;
    var CommandGenerator = Firecrow.Interpreter.Commands.CommandGenerator;
    var ValueTypeHelper = Firecrow.ValueTypeHelper;
    var ASTHelper = Firecrow.ASTHelper;
    var fcSymbolic = Firecrow.ScenarioGenerator.Symbolic;

    Firecrow.Interpreter.logExecution = false;

    Firecrow.Interpreter.InterpreterSimulator = function(programAst, globalObject, handlerInfo)
    {
        this.programAst = programAst;
        this.globalObject = globalObject;
        this.handlerInfo = handlerInfo;
        this.tryStack = [];

        this.executionContextStack = new ExecutionContextStack(globalObject, handlerInfo);
        this.executionContextStack.registerExceptionCallback(this._removeCommandsAfterException, this);

        this.globalObject.executionContextStack = this.executionContextStack;

        this.commands = CommandGenerator.generateCommands(programAst);

        this.messageGeneratedCallbacks = [];
        this.controlFlowConnectionCallbacks = [];
    };

    var fcSimulator = Firecrow.Interpreter.InterpreterSimulator;

    fcSimulator.log = [];
    fcSimulator.logTrace = false;
    fcSimulator.notifyError = function(message) { alert("InterpreterSimulator - " + message); }

    fcSimulator.prototype = dummy =
    {
        runSync: function()
        {
            try
            {
                if(fcSimulator.logTrace) { console.log("Logging trace!"); }

                var timer = Firecrow.TimerHelper.createTimer();

                for(this.currentCommandIndex = 0; this.currentCommandIndex < this.commands.length; this.currentCommandIndex++)
                {
                    var command = this.commands[this.currentCommandIndex];

                    var codeConstruct = command.codeConstruct;

                    this.globalObject.setCurrentCommand(command);

                    this._processCommand(command); //if(command.codeConstruct.loc != null && command.codeConstruct.loc.start.line == 1378)debugger;3

                    if(codeConstruct) { codeConstruct.hasBeenExecuted = true; }

                    fcSimulator.noOfEvaluatedExpressions++;

                    //Uncomment to enable application tracing
                    /*if(codeConstruct.loc != null && codeConstruct.loc.start.line >= 9491 && codeConstruct.loc.start.line <= 9507)
                     {
                     fcSimulator.logTrace = true;
                     }

                     if(!fcSimulator.logTrace || command.codeConstruct == null) { continue; }

                     if(command.codeConstruct.loc == null) { continue; }

                     if(fcSimulator.log.length == 0 || fcSimulator.log[fcSimulator.log.length-1] != command.codeConstruct.loc.start.line)
                     {
                     if(command.isDeclareVariableCommand() && command.parentFunctionCommand != null) { continue; }
                     if(command.type.indexOf("End") == 0) { continue; }

                     fcSimulator.log.push(command.codeConstruct.loc.start.line);
                     }*/
                }
            }
            catch(e)
            {
                debugger;
                fcSimulator.notifyError("Error while running the InterpreterSimulator: " + e);
            }
        },

        runAsync: function(callback)
        {
            try
            {
                this.currentCommandIndex = 0;
                var that = this;
                var timer = Firecrow.TimerHelper.createTimer();

                var asyncLoop = function()
                {
                    var command = that.commands[that.currentCommandIndex];

                    that._processCommand(command);

                    that.callMessageGeneratedCallbacks("ExCommand@" + command.getLineNo() + ":" + command.type);

                    that.currentCommandIndex++;

                    if(timer.hasMoreThanSecondsElapsed(120))
                    {
                        if(!confirm("Interpreter Simulator - runAsync has been running for more than 2 minutes, Continue?"))
                        {
                            return;
                        }
                    }

                    if(that.currentCommandIndex < that.commands.length) { that.currentCommandIndex % 20 == 0 ? setTimeout(asyncLoop, 10) : asyncLoop(); }
                    else { callback(); }
                };

                setTimeout(asyncLoop, 10)
            }
            catch(e) { fcSimulator.notifyError("Error when executing async loop"); }
        },

        destruct: function()
        {
            delete this.programAst;
            delete this.globalObject;
            delete this.handlerInfo;
            delete this.tryStack;

            this.executionContextStack.destruct();
            delete this.executionContextStack;

            delete this.commands;

            delete this.messageGeneratedCallbacks;
            delete this.controlFlowConnectionCallbacks;
        },

        _processCommand: function(command)
        {
            if(command.isStartTryStatementCommand() || command.isEndTryStatementCommand()) { this._processTryCommand(command); }
            if(command.isEvalThrowExpressionCommand())
            {
                this._processThrowCommand(command);
                this._removeCommandsAfterException(command);
            }

            this.executionContextStack.executeCommand(command);
            command.hasBeenExecuted = true;

            if (command.removesCommands) { this._processRemovingCommandsCommand(command); }
            if (command.generatesNewCommands) { this._processGeneratingNewCommandsCommand(command); }
        },

        _processThrowCommand: function(throwCommand)
        {
            this.throwExpressionValue = this.executionContextStack.getExpressionValue(throwCommand.codeConstruct.argument);
        },

        _processGeneratingNewCommandsCommand: function(command)
        {
            if (command.isEvalCallbackFunctionCommand()) { this._generateCommandsAfterCallbackFunctionCommand(command); }
            else if (command.isEvalNewExpressionCommand()) { this._generateCommandsAfterNewExpressionCommand(command); }
            else if (command.isEvalCallExpressionCommand()) { this._generateCommandsAfterCallFunctionCommand(command); }
            else if (command.isCallInternalFunctionCommand()) { if(command.generatesCallbacks) { this._generateCommandsAfterCallbackFunctionCommand(command); this.globalObject.browser.logStartExecutingCallbacks(command.callbackFunction != null && command.callbackFunction.codeConstruct); }}
            else if (command.isLoopStatementCommand()) { this._generateCommandsAfterLoopCommand(command); }
            else if (command.isIfStatementCommand()) { this._generateCommandsAfterIfCommand(command); }
            else if (command.isEvalConditionalExpressionBodyCommand()) { this._generateCommandsAfterConditionalCommand(command); }
            else if (command.isCaseCommand()) { this._generateCommandsAfterCaseCommand(command); }
            else if (command.isConvertToPrimitiveCommand()) { this._generateCommandsAfterConvertToPrimitiveCommand(command); }
            else { fcSimulator.notifyError("Unknown generating new commands command!"); }
        },

        _processRemovingCommandsCommand: function(command)
        {
                 if (command.isEvalReturnExpressionCommand()) { this._removeCommandsAfterReturnStatement(command); }
            else if (command.isEvalBreakCommand()) { this._removeCommandsAfterBreak(command); }
            else if (command.isEvalContinueCommand()) { this._removeCommandsAfterContinue(command); }
            else if (command.isEvalThrowExpressionCommand()) { this._removeCommandsAfterException(command); }
            else if (command.isEvalLogicalExpressionItemCommand()) { this._removeCommandsAfterLogicalExpressionItem(command); }
            else { fcSimulator.notifyError("Unknown removing commands command: " + command.type); }
        },

        _processTryCommand: function(command)
        {
            if(command.isStartTryStatementCommand())
            {
                this.tryStack.push(command);
            }
            else if (command.isEndTryStatementCommand())
            {
                this._removeTryCommandFromStack(command);
            }
            else { fcSimulator.notifyError("Unknown command type when processing try command"); }
        },

        _removeTryCommandFromStack: function(command)
        {
            var topCommand = this.tryStack[this.tryStack.length - 1];

            if(topCommand != null && topCommand.codeConstruct == command.codeConstruct)
            {
                this.tryStack.pop();
            }
            else if (topCommand == null || topCommand.codeConstruct != command.codeConstruct)
            {
                debugger;
                fcSimulator.notifyError("No top command to remove from stack!");
            }
        },

        removeOtherCallbackCommands: function (command)
        {
            var endIndex = this.commands.indexOf(command.lastCallbackCommand);
            var hasFirstExitContextCommandBeenSkipped = false;
            for(var i = this.currentCommandIndex + 1; i <= endIndex;)
            {
                var currentCommand = this.commands[i];

                if(currentCommand.isExitFunctionContextCommand() && !hasFirstExitContextCommandBeenSkipped)
                {
                    i++;
                    hasFirstExitContextCommandBeenSkipped = true;
                }
                else
                {
                    ValueTypeHelper.removeFromArrayByIndex(this.commands, i);
                    endIndex--;
                }
            }
        },

        _removeCommandsAfterReturnStatement: function(returnCommand)
        {
            var callExpressionCommand = returnCommand.parentFunctionCommand;

            for(var i = this.currentCommandIndex + 1; i < this.commands.length;)
            {
                var command = this.commands[i];

                if(!command.isExitFunctionContextCommand() && command.parentFunctionCommand == callExpressionCommand)
                {
                    ValueTypeHelper.removeFromArrayByIndex(this.commands, i);

                    if(command.isEndTryStatementCommand() && command.startCommand.hasBeenExecuted)
                    {
                        this._removeTryCommandFromStack(command);
                    }
                }
                else { break; }
            }
        },

        _removeCommandsAfterBreak: function(breakCommand)
        {
            if(breakCommand.codeConstruct.label != null) { this._removeCommandsAfterLabeledBreak(breakCommand);}
            else { this._removeCommandsAfterNonLabeledBreak(breakCommand); }
        },

        _removeCommandsAfterLabeledBreak: function(breakCommand)
        {
            var breakParent = ASTHelper.getLoopOrSwitchParent(breakCommand.codeConstruct);

            var labelName = breakCommand.codeConstruct.label.name;
            var label = ASTHelper.getParentLabelStatement(breakCommand.codeConstruct, labelName);

            if(label == null) { this._removeCommandsAfterNonLabeledBreak(breakCommand); return; }

            var labeledStatement = label.body;

            for(var i = this.currentCommandIndex + 1; i < this.commands.length; )
            {
                var command = this.commands[i];
                var isThisLabel = command.codeConstruct == labeledStatement;

                if(command.isEndSwitchStatementCommand() || command.isEndLoopStatementCommand() ){ i++; }
                else { ValueTypeHelper.removeFromArrayByIndex(this.commands, i); }

                if((command.isLoopStatementCommand() || command.isEndSwitchStatementCommand())
                 && isThisLabel && command.codeConstruct == breakParent) { break;}
            }
        },

        _removeCommandsAfterNonLabeledBreak: function(breakCommand)
        {
            var breakParent = ASTHelper.getLoopOrSwitchParent(breakCommand.codeConstruct);

            for(var i = this.currentCommandIndex + 1; i < this.commands.length; )
            {
                var command = this.commands[i];

                if(!command.isEndSwitchStatementCommand() && !command.isEndLoopStatementCommand())
                {
                    ValueTypeHelper.removeFromArrayByIndex(this.commands, i);
                }
                else
                {
                    i++;
                }

                if((command.isLoopStatementCommand() || command.isEndSwitchStatementCommand())
                && command.codeConstruct == breakParent) { break;}
            }
        },

        _removeCommandsAfterContinue: function(continueCommand)
        {
            if(continueCommand.codeConstruct.label != null) { this._removeCommandsAfterLabeledContinue(continueCommand); }
            else { this._removeCommandsAfterNonLabeledContinue(continueCommand); }
        },

        _removeCommandsAfterNonLabeledContinue: function(continueCommand)
        {
            var continueParent = ASTHelper.getLoopParent(continueCommand.codeConstruct);

            for(var i = this.currentCommandIndex + 1; i < this.commands.length; )
            {
                var command = this.commands[i];

                if(!command.isForUpdateStatementCommand()
                && !command.isEndLoopStatementCommand()
                && (!command.isEvalForInWhereCommand() || command.codeConstruct != continueParent ))
                {
                    ValueTypeHelper.removeFromArrayByIndex(this.commands, i);
                }
                else
                {
                    i++;
                }

                if((command.isLoopStatementCommand() || command.isForUpdateStatementCommand())
                && command.codeConstruct == continueParent)
                {
                    break;
                }
            }
        },

        _removeCommandsAfterLabeledContinue: function(continueCommand)
        {
            var continueParent = ASTHelper.getLoopParent(continueCommand.codeConstruct);

            var labelName = continueCommand.codeConstruct.label.name;
            var label = ASTHelper.getParentLabelStatement(continueCommand.codeConstruct, labelName);

            if(label == null) { this._removeCommandsAfterNonLabeledContinue(continueCommand); return; }

            var labeledStatement = label.body;

            for(var i = this.currentCommandIndex + 1; i < this.commands.length; )
            {
                var command = this.commands[i];
                var isThisLabel = command.codeConstruct == labeledStatement;

                if(command.isForUpdateStatementCommand() && isThisLabel) { i++;}
                else if (command.isEndLoopStatementCommand()) { i++; }
                else if(command.isEvalForInWhereCommand() && command.codeConstruct != continueParent)
                {
                    this.notifyError("Haven't thought about this, possible bug!");
                    i++;
                }
                else { ValueTypeHelper.removeFromArrayByIndex(this.commands, i);}

                if((command.isLoopStatementCommand() || command.isForUpdateStatementCommand())
                && isThisLabel && command.codeConstruct == continueParent)
                {
                    break;
                }
            }
        },

        _removeCommandsAfterException: function(exceptionGeneratingArgument)
        {
            if(exceptionGeneratingArgument == null ||
            !(exceptionGeneratingArgument.isDomStringException || exceptionGeneratingArgument.isPushExpectedException
          || (ValueTypeHelper.isOfType(exceptionGeneratingArgument, Firecrow.Interpreter.Commands.Command) && exceptionGeneratingArgument.isEvalThrowExpressionCommand())))
            {
                debugger;
                fcSimulator.notifyError("Exception generating error at:" + " - " + this.commands[this.currentCommandIndex].codeConstruct.loc.start.line + ": " + FBL.Firecrow.CodeTextGenerator.generateJsCode(this.commands[this.currentCommandIndex].codeConstruct));
            }

            if(this.tryStack.length == 0)
            {
                debugger;
                fcSimulator.notifyError("Removing commands and there is no enclosing try catch block @ " + this.commands[this.currentCommandIndex].codeConstruct.loc.source);
                return;
            }

            for(var i = this.currentCommandIndex + 1; i < this.commands.length; )
            {
                var command = this.commands[i];

                if(command.isEndTryStatementCommand()) { break; }
                if(command.isExitFunctionContextCommand()) { i++; continue;}

                if(command.isEndIfCommand() || command.isEndLoopStatementCommand())
                {
                    if(command.startCommand != null && command.startCommand.hasBeenExecuted) { i++; continue; }
                }

                ValueTypeHelper.removeFromArrayByIndex(this.commands, i);
            }

            if(this.tryStack.length > 0)
            {
                if(ValueTypeHelper.isOfType(exceptionGeneratingArgument, Firecrow.Interpreter.Commands.Command))
                {
                    var expressionValue = this.executionContextStack.getExpressionValue(exceptionGeneratingArgument.codeConstruct.argument);

                    if(expressionValue != null)
                    {
                        exceptionGeneratingArgument = expressionValue;
                    }
                }

                ValueTypeHelper.insertElementsIntoArrayAtIndex
                (
                    this.commands,
                    CommandGenerator.generateCatchStatementExecutionCommands
                    (
                        this.tryStack[this.tryStack.length - 1],
                        exceptionGeneratingArgument,
                        this.commands[this.currentCommandIndex]
                    ),
                    i
                );
            }
        },

        _removeCommandsAfterLogicalExpressionItem: function(evalLogicalExpressionItemCommand)
        {
            if(evalLogicalExpressionItemCommand.shouldDeleteFollowingLogicalCommands)
            {
                var parentCommand = evalLogicalExpressionItemCommand.parentLogicalExpressionCommand;

                for(var i = this.currentCommandIndex + 1; i < this.commands.length; )
                {
                    var command = this.commands[i];

                    if(command.isEndLogicalExpressionCommand() && command.startCommand == parentCommand) { break;}

                    ValueTypeHelper.removeFromArrayByIndex(this.commands, i);
                }
            }
        },

        _generateCommandsAfterCallbackFunctionCommand: function(callInternalFunctionCommand)
        {
            ValueTypeHelper.insertElementsIntoArrayAtIndex
            (
                this.commands,
                CommandGenerator.generateCallbackFunctionExecutionCommands(callInternalFunctionCommand),
                this.currentCommandIndex + 1
            );
        },

        _generateCommandsAfterNewExpressionCommand: function(newCommand)
        {
            var callConstruct = newCommand.codeConstruct;
            var callee = this.executionContextStack.getExpressionValue(callConstruct.callee);
            var newObject = this.globalObject.internalExecutor.createObject
            (
                callee,
                newCommand.codeConstruct,
                this.executionContextStack.getExpressionsValues(callConstruct.arguments)
            );

            this.executionContextStack.setExpressionValue(newCommand.codeConstruct, newObject);

            ValueTypeHelper.insertElementsIntoArrayAtIndex
            (
                this.commands,
                CommandGenerator.generateFunctionExecutionCommands(newCommand, callee, newObject),
                this.currentCommandIndex + 1
            );
        },

        _generateCommandsAfterCallFunctionCommand: function(callExpressionCommand)
        {
            var callConstruct = callExpressionCommand.codeConstruct;

            var baseObject = this.executionContextStack.getBaseObject(callConstruct.callee);
            var callFunction = this.executionContextStack.getExpressionValue(callConstruct.callee);

            if(callFunction == null) { debugger; alert("Call function can not be null!"); }

            var baseObjectValue = baseObject.jsValue;
            var callFunctionValue = callFunction.jsValue;

            if(ValueTypeHelper.isFunction(baseObjectValue) && ValueTypeHelper.isFunction(callFunctionValue))
            {
                if(callFunctionValue.name == "call" || callFunctionValue.name == "apply")
                {
                    if(callFunctionValue.name == "call") { callExpressionCommand.isCall = true; }
                    else if(callFunctionValue.name == "apply") { callExpressionCommand.isApply = true; }

                    callFunction = baseObject;
                    baseObject = this.executionContextStack.getExpressionValue(callConstruct.arguments[0]);
                }
            }

            ValueTypeHelper.insertElementsIntoArrayAtIndex
            (
                this.commands,
                CommandGenerator.generateFunctionExecutionCommands(callExpressionCommand, callFunction, baseObject),
                this.currentCommandIndex + 1
            );
        },

        _generateCommandsAfterLoopCommand: function(loopCommand)
        {
            if(loopCommand == null || loopCommand.isStartDoWhileCommand()) { return; }

            ValueTypeHelper.insertElementsIntoArrayAtIndex
            (
                this.commands,
                CommandGenerator.generateLoopExecutionCommands
                (
                    loopCommand,
                    !loopCommand.isEvalForInWhereCommand() ? this.executionContextStack.getExpressionValue(loopCommand.codeConstruct.test).jsValue : null
                ),
                this.currentCommandIndex + 1
            );
        },

        _generateCommandsAfterIfCommand: function(ifCommand)
        {
            var ifConditionValue = this.executionContextStack.getExpressionValue(ifCommand.codeConstruct.test);

            var generatedCommands = CommandGenerator.generateIfStatementBodyCommands(ifCommand, ifConditionValue.jsValue, ifCommand.parentFunctionCommand);

            this.globalObject.browser.addPathConstraint(ifCommand.codeConstruct, ifConditionValue.symbolicValue, !ifConditionValue.jsValue);

            ValueTypeHelper.insertElementsIntoArrayAtIndex(this.commands, generatedCommands, this.currentCommandIndex + 1);
        },

        _generateCommandsAfterConditionalCommand: function(conditionalCommand)
        {
            var conditionValue = this.executionContextStack.getExpressionValue(conditionalCommand.codeConstruct.test);

            this.globalObject.browser.addPathConstraint(conditionalCommand.codeConstruct, conditionValue.symbolicValue, !conditionValue.jsValue);

            ValueTypeHelper.insertElementsIntoArrayAtIndex
            (
                this.commands,
                CommandGenerator.generateConditionalExpressionEvalBodyCommands
                (
                    conditionalCommand,
                    conditionValue.jsValue
                ),
                this.currentCommandIndex + 1
            );
        },

        _generateCommandsAfterCaseCommand: function(caseCommand)
        {
            var switchDiscriminantValue = this.executionContextStack.getExpressionValue(caseCommand.parent.codeConstruct.discriminant);
            var caseValue = caseCommand.codeConstruct.test != null ? this.executionContextStack.getExpressionValue(caseCommand.codeConstruct.test)
                                                                   : null;

            var pathConstraint = fcSymbolic.SymbolicExecutor.evalSwitchCase(caseValue, switchDiscriminantValue);

            if(caseCommand.codeConstruct.test == null //is default
            || caseCommand.parent.hasBeenMatched //falls through
            || caseValue.jsValue == switchDiscriminantValue.jsValue)
            {
                if(!caseCommand.parent.hasBeenMatched) //On first matching case - add path
                {
                    this.globalObject.browser.addPathConstraint(caseCommand.parent, pathConstraint);
                }

                caseCommand.parent.hasBeenMatched = true;
                caseCommand.parent.matchedCaseCommand = caseCommand;

                ValueTypeHelper.insertElementsIntoArrayAtIndex(this.commands, CommandGenerator.generateCaseExecutionCommands(caseCommand), this.currentCommandIndex + 1);
            }
            else //will not generate case commands - add inverted path constraint
            {
                this.globalObject.browser.addPathConstraint(caseCommand.parent, pathConstraint, true);
            }
        },

        _generateCommandsAfterConvertToPrimitiveCommand: function(convertToPrimitiveCommand)
        {
            var expression = convertToPrimitiveCommand.codeConstruct;
            var expressionValue = this.executionContextStack.getExpressionValue(expression);

            //Is null, don't do anything - will throw exception later when processing binary expression
            //If primitive, there is nothing to do
            if(expressionValue == null || expressionValue.isPrimitive()) { return; }

            var valueOfFunction = expressionValue.iValue.getPropertyValue("valueOf");

            //If there is no user-defined valueOf function just return
            if(valueOfFunction == null || valueOfFunction.iValue == null || valueOfFunction.isInternalFunction ) { return; }

            ValueTypeHelper.insertElementsIntoArrayAtIndex
            (
                this.commands,
                CommandGenerator.generateFunctionExecutionCommands(convertToPrimitiveCommand, valueOfFunction, expressionValue),
                this.currentCommandIndex + 1
            );
        },

        registerMessageGeneratedCallback: function(callbackFunction, thisValue)
        {
            this.messageGeneratedCallbacks.push
            ({
                callback: callbackFunction,
                thisValue: thisValue || this
            });
        },

        registerControlFlowConnectionCallback: function(calleeFunction, thisValue)
        {
            this.controlFlowConnectionCallbacks.push
            ({
                callback: calleeFunction,
                thisValue: thisValue || this
            });
        },

        callMessageGeneratedCallbacks: function(message)
        {
            this.messageGeneratedCallbacks.forEach(function(callbackDescription)
            {
                callbackDescription.callback.call(callbackDescription.thisValue, message);
            });
        }
    };
    /******************************************************************************************/
}});FBL.ns(function() { with (FBL) {
    /*************************************************************************************/
    var ValueTypeHelper = Firecrow.ValueTypeHelper;
    var ASTHelper = Firecrow.ASTHelper;
    var WebFile = Firecrow.DoppelBrowser.WebFile;
    var Node = Firecrow.DependencyGraph.Node;
    var HtmlHelper = Firecrow.htmlHelper;

    var Interpreter = Firecrow.Interpreter.InterpreterSimulator;
    var GlobalObject = Firecrow.Interpreter.Model.GlobalObject;

    var fcSimulator = Firecrow.Interpreter.Simulator;
    var fcModel = Firecrow.Interpreter.Model;
    var fcBrowser = Firecrow.DoppelBrowser;

    fcBrowser.Browser = function(pageModel)
    {
        try
        {
            this.id = fcBrowser.Browser.LAST_USED_ID++;
            this.pageModel = pageModel;
            this.hostDocument = Firecrow.getDocument();
            this._clearHostDocument();
            this.htmlWebFile = pageModel;

            this.globalObject = new GlobalObject(this, this.hostDocument);

            this.nodeCreatedCallbacks = [];
            this.nodeInsertedCallbacks = [];
            this.interpretJsCallbacks = [];
            this.expressionEvaluatedCallbackInfo = { callback: function(){}, thisObject: this};
            this.controlFlowProblematicCallbacks = [];

            this.dataDependencyEstablishedCallbacks = [];
            this.controlDependencyEstablishedCallbacks = [];
            this.interpreterMessageGeneratedCallbacks = [];
            this.controlFlowConnectionCallbacks = [];
            this.importantConstructReachedCallbacks = [];
            this.documentReadyCallbacks = [];
            this.enterFunctionCallbacks = [];
            this.exitFunctionCallbacks = [];
            this.callbackCalledCallbacks = [];
            this.startedExecutingCallbackCallbacks = [];
            this.stoppedExecutingCallbackCallbacks = [];
            this.breakContinueReturnEventsCallbacks = [];

            this.domQueriesMap = {};
            this.dynamicIdMap = {};
            this.dynamicClassMap = {};

            this.errorMessages = [];
            this.cssRules = [];

            this.executionInfo = new fcBrowser.ExecutionInfo();

            this.loadingEventsExecuted = false;

            this._matchesSelector = Element.prototype.matchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.webkitMatchesSelector;

            if(!Firecrow.IsDebugMode)
            {
                var errorMessages = this.errorMessages

                Firecrow.Interpreter.Commands.CommandGenerator.notifyError = function(message) { errorMessages.push("CommandGenerator - " + message); };
                Firecrow.Interpreter.Commands.Command.notifyError = function(message) { errorMessages.push("Command - " + message); };
                Firecrow.CodeTextGenerator.notifyError = function(message) { errorMessages.push("CodeTextGenerator - " + message); }
                Firecrow.DependencyGraph.DependencyGraph.notifyError = function(message) { errorMessages.push("DependencyGraph - " + message); }
                Firecrow.Interpreter.Model.GlobalObject.notifyError = function(message) { errorMessages.push("GlobalObject - " + message); }
                Firecrow.DependencyGraph.DependencyPostprocessor.notifyError = function(message) { errorMessages.push("DependencyPostprocessor - " + message); }
                Firecrow.DependencyGraph.Edge.notifyError = function(message) { errorMessages.push("Edge - " + message); }
                Firecrow.DependencyGraph.InclusionFinder.notifyError = function(message) { errorMessages.push("InclusionFinder - " + message); }
                Firecrow.DependencyGraph.Node.notifyError = function(message) { errorMessages.push("Node - " + message); }
                Firecrow.DoppelBrowser.Browser.notifyError = function(message) { errorMessages.push("Browser - " + message); }
                Firecrow.Interpreter.Model.RegEx.notifyError = function(message) { errorMessages.push("RegEx - " + message); }
                Firecrow.Interpreter.Model.String.notifyError = function(message) { errorMessages.push("String - " + message); }
                Firecrow.Interpreter.Model.Array.notifyError = function(message) { errorMessages.push("Array - " + message); }
                Firecrow.Interpreter.Model.Attr.notifyError = function(message) { errorMessages.push("Attr - " + message); }
                Firecrow.Interpreter.Model.Identifier.notifyError = function(message) { errorMessages.push("Identifier - " + message); }
                Firecrow.Interpreter.Model.fcValue.notifyError = function(message) { errorMessages.push("FcValue - " + message); }
                Firecrow.Interpreter.Model.Object.notifyError = function(message) { errorMessages.push("Object - " + message); }
                Firecrow.Interpreter.Model.Math.notifyError = function(message) { errorMessages.push("Math - " + message); }
                Firecrow.Interpreter.Simulator.Evaluator.notifyError = function(message) { errorMessages.push("Evaluator - " + message); }
                Firecrow.Interpreter.Simulator.ExecutionContext.notifyError = function(message) { errorMessages.push("ExecutionContext - " + message); }
                Firecrow.Interpreter.Simulator.InternalExecutor.notifyError = function(message) { errorMessages.push("InternalExecutor - " + message); }
                Firecrow.Interpreter.Simulator.VariableObject.notifyError = function(message) { errorMessages.push("VariableObject - " + message); }
                Firecrow.Interpreter.InterpreterSimulator.notifyError = function(message) { errorMessages.push("InterpreterSimulator - " + message); }

                Firecrow.DependencyGraph.Node.LAST_ID = 0;
                Firecrow.Interpreter.Model.fcValue.LAST_ID = 0;
                Firecrow.Interpreter.Commands.Command.LAST_COMMAND_ID = 0;
                Firecrow.Interpreter.Model.Identifier.LAST_ID = 0;
                Firecrow.Interpreter.Model.Object.LAST_ID = 0;
            }
        }
        catch(e) { fcBrowser.Browser.notifyError("Error when initialising Doppel Browser.Browser: " + e); }
    };

    fcBrowser.Browser.notifyError = function(message) { debugger; alert("Browser - " + message); };
    fcBrowser.Browser.LAST_USED_ID = 0;

    var Browser = Firecrow.DoppelBrowser.Browser;

    Browser.prototype = dummy =
    {
        evaluatePage: function()
        {
            try
            {
                Firecrow.Interpreter.InterpreterSimulator.noOfEvaluatedExpressions = 0;
                this._buildSubtree(this.pageModel.htmlElement, null);
                this._handleEvents();
            }
            catch(e) { this.notifyError("Exception when building page from model: " + e); }
        },

        executeLoadingEvents: function()
        {
            var loadedHandlers = this.globalObject.getLoadedHandlers();

            for(var i = 0; i < loadedHandlers.length; i++)
            {
                this.executeEvent(loadedHandlers[i]);
            }

            this.setLoadingEventsExecuted();
        },

        executeAjaxEvents: function()
        {
            var ajaxEvents = this.globalObject.ajaxHandlers;

            for(var i = 0; i < ajaxEvents.length; i++)
            {
                var ajaxEvent = ajaxEvents[i];
                if(!ajaxEvent.hasBeenHandled)
                {
                    this.executeEvent(ajaxEvent);
                    ajaxEvent.hasBeenHandled = true;
                }
            }
        },

        noOfTimingEventsExe: 0,
        executeTimingEvents: function()
        {
            var events = this._getTimingEventsSortedByRegistrationPoint();

            while(events.length != 0 && this.noOfTimingEventsExe < 3)
            {
                var event = events[0];
                console.log("Executing event");
                this._interpretJsCode
                (
                    event.handlerConstruct.body,
                    {
                        functionHandler: event.handler,
                        thisObject: this.globalObject,
                        argumentValues: event.callArguments,
                        registrationPoint: event.registrationPoint
                    }
                );

                if(event.eventType == "timeout")
                {
                    var eventIndex = this.globalObject.timeoutHandlers.indexOf(event);

                    if(eventIndex != -1)
                    {
                        ValueTypeHelper.removeFromArrayByIndex(this.globalObject.timeoutHandlers, event);
                    }
                }

                events = this._getTimingEventsSortedByRegistrationPoint();
                this.noOfTimingEventsExe++;
            }
        },

        _getTimingEventsSortedByRegistrationPoint: function()
        {
            var events = this.globalObject.timeoutHandlers.concat(this.globalObject.intervalHandlers);

            events.sort(function(event1, event2)
            {
                return event1.registrationPoint.evaluationPositionId.currentCommandId - event2.registrationPoint.evaluationPositionId.currentCommandId;
            });

            return events;
        },

        clear: function(){},

        getEventRegistrations: function()
        {
            return this.globalObject.timeoutHandlers.concat(this.globalObject.intervalHandlers)
                       .concat(this.globalObject.htmlElementEventHandlingRegistrations)
                       .concat(this.globalObject.ajaxHandlers);
        },

        setLoadingEventsExecuted: function()
        {
            this.loadingEventsExecuted = true;
        },

        executeEvent: function(eventInfo, argumentValues)
        {
            if(eventInfo == null) { return; }

            var handlerConstruct = eventInfo.handler.codeConstruct;

            this.executionInfo.logEventExecution(eventInfo.thisObjectDescriptor, eventInfo.eventType, handlerConstruct);

            this._interpretJsCode
            (
                handlerConstruct.body,
                {
                    functionHandler: eventInfo.handler,
                    thisObject: eventInfo.thisObject,
                    argumentValues: argumentValues || [],
                    registrationPoint: eventInfo.registrationPoint
                }
            );

            if(eventInfo.eventType == "onreadystatechange")
            {
                eventInfo.thisObject.updateToNext();
            }
        },

        _clearHostDocument: function()
        {
            this.hostDocument.head.innerHTML = "";
            this.hostDocument.body.innerHTML = "";
        },

        _buildSubtree: function(htmlModelElement, parentDomElement)
        {
            var htmlDomElement = this._createStaticHtmlNode(htmlModelElement);
            if(htmlDomElement == null) { return; }
            htmlModelElement.hasBeenExecuted = true;

            this._setAttributes(htmlDomElement, htmlModelElement);
            this._insertIntoDom(htmlDomElement, parentDomElement);

            if(this.globalObject.satisfiesDomSlicingCriteria(htmlDomElement))
            {
                Firecrow.includeNode(htmlModelElement);
            }

            if(this._isScriptNode(htmlModelElement) || this._isCssInclusionNode(htmlModelElement))
            {
                if(this._isScriptNode(htmlModelElement)) { this._handleScriptNode(htmlModelElement); }
                else if(this._isCssInclusionNode(htmlModelElement)) { this._buildCssNodes(htmlModelElement); }

                if(htmlModelElement.textContent)
                {
                    htmlDomElement.textContent = htmlModelElement.textContent;
                }
            }

            this.createDependenciesBetweenHtmlNodeAndCssNodes(htmlModelElement);
            this._processChildren(htmlDomElement, htmlModelElement);
        },

        _handleScriptNode: function(htmlModelElement)
        {
            this._buildJavaScriptNodes(htmlModelElement);
            this._interpretJsCode(htmlModelElement.pathAndModel.model, null);
            this._callInterpretJsCallbacks(htmlModelElement.pathAndModel.model);
        },

        _isScriptNode: function(htmlModelElement)
        {
            if(htmlModelElement == null) { return false; }

            return  htmlModelElement.type == "script";
        },

        _isCssInclusionNode: function(htmlModelElement)
        {
            if(htmlModelElement == null) { return false; }

            return htmlModelElement.type == "style" || this._isExternalStyleLink(htmlModelElement);
        },

        _setAttributes: function(htmlDomElement, htmlModelElement)
        {
            var attributes = htmlModelElement.attributes;

            if(attributes == null || htmlModelElement.type == "textNode") { return; }

            for(var i = 0, length = attributes.length; i < length; i++)
            {
                var attribute = attributes[i];

                try
                {
                    htmlDomElement[attribute.name] = attribute.value;
                    htmlDomElement.setAttribute(attribute.name, attribute.value);
                }
                catch(e) { debugger; }

                if(attribute.name == "src" && htmlModelElement.type == "img")
                {
                    htmlDomElement.setAttribute(attribute.name, Firecrow.UriHelper.getAbsoluteUrl(attribute.value, this.url));
                }
            }
        },

        _processChildren: function(htmlDomElement, htmlModelElement)
        {
            var childNodes = htmlModelElement.childNodes;

            if(childNodes == null) { return; }

            for(var i = 0, length = childNodes.length; i < length; i++)
            {
                this._buildSubtree(childNodes[i], htmlDomElement);
            }
        },

        _createStaticHtmlNode: function(htmlModelNode)
        {
            var htmlDomElement = null;

            if(htmlModelNode.type == null) { return null; }
            else if(htmlModelNode.type == "html") { htmlDomElement = this.hostDocument.documentElement; }
            else if (htmlModelNode.type == "head" || htmlModelNode.type == "body") { htmlDomElement = this.hostDocument[htmlModelNode.type]; }
            else if (htmlModelNode.type == "textNode") { htmlDomElement = this.hostDocument.createTextNode(htmlModelNode.textContent); }
            else
            {
                if(this._isExternalStyleLink(htmlModelNode))
                {
                    htmlDomElement = this.hostDocument.createElement("style");
                }
                else
                {
                    htmlDomElement = this.hostDocument.createElement(htmlModelNode.type);
                }
            }

            htmlDomElement.modelElement = htmlModelNode;

            if(fcBrowser.Browser.isForSlicing)
            {
                htmlModelNode.domElement = htmlDomElement;
            }

            this.callNodeCreatedCallbacks(htmlModelNode, "html", false);

            return htmlDomElement;
        },

        _isExternalStyleLink: function(htmlModelElement)
        {
            if(htmlModelElement == null || htmlModelElement.type != "link"
                || htmlModelElement.attributes == null || htmlModelElement.attributes.length == 0) { return false; }

            for(var i = 0; i < htmlModelElement.attributes.length; i++)
            {
                var attribute = htmlModelElement.attributes[i];

                if(attribute.name == "type" && attribute.value == "text/css") { return true; }
                else if (attribute.name == "rel" && attribute.value == "stylesheet") { return true; }
            }

            return false;
        },

        _interpretJsCode: function(codeModel, handlerInfo)
        {
            try
            {
                this.interpreter = new Interpreter(codeModel, this.globalObject, handlerInfo);

                this.globalObject.dependencyCreator = new fcSimulator.DependencyCreator(this.globalObject, this.interpreter.executionContextStack);

                this.interpreter.registerMessageGeneratedCallback(function(message)
                {
                    this._callInterpreterMessageGeneratedCallbacks(message);
                }, this);

                this.interpreter.registerControlFlowConnectionCallback(function(codeConstruct)
                {
                    this._callControlFlowConnectionCallbacks(codeConstruct);
                }, this);

                this.interpreter.runSync();
                this.interpreter.destruct();
                delete this.interpreter;
                this.interpreter = null;

                this.globalObject.registerPreRegisteredAjaxEvents();
            }
            catch(e)
            {
                this.notifyError("DoppelBrowser.browser error when interpreting js code: " + e + "@" + e.fileName + " " + e.lineNumber);
            }
        },

        getExecutionInfo: function()
        {
            return this.executionInfo;
        },

        getSimplifiedUndefinedGlobalPropertiesAccessMap: function()
        {
            var simplified = {};

            var map = this.getUndefinedGlobalPropertiesAccessMap();

            for(var varName in map)
            {
                simplified[varName] = {};

                for(var constructId in map[varName])
                {
                    simplified[varName][constructId] = {nodeId: constructId };
                }
            }

            return simplified;
        },

        getUndefinedGlobalPropertiesAccessMap: function()
        {
            var map = {};

            var itemMap = this.executionInfo.undefinedGlobalPropertiesAccessMap;

            for(var propertyName in itemMap)
            {
                if(propertyName == "") { continue; }

                if(map[propertyName] == null)
                {
                    map[propertyName] = itemMap[propertyName];
                }
                else
                {
                    var expanderObject = itemMap[propertyName];
                    var expandedObject = map[propertyName];

                    for(var codeConstructId in expanderObject)
                    {
                        expandedObject[codeConstructId] = expanderObject[codeConstructId];
                    }
                }
            }

            return map;
        },

        getSimplifiedResourceSetterMap: function()
        {
            var resourceSetterMap = this.getResourceSetterMap();
            var simplified = {};

            for(var nodeId in resourceSetterMap)
            {
                simplified[nodeId] =
                {
                    resourceValue: resourceSetterMap[nodeId].resourceValue,
                    codeConstructId: nodeId
                };
            }

            return simplified;
        },

        getInternalPrototypeExtensions: function()
        {
            var prototypes = this.globalObject.internalPrototypes;
            var prototypeExtensions = {};

            for(var i = 0; i < prototypes.length; i++)
            {
                var prototype = prototypes[i];
                var userDefinedProperties = prototype.getUserDefinedProperties();

                if(userDefinedProperties.length == 0) { continue; }

                prototypeExtensions[prototype.name] = [];

                for(var j = 0; j < userDefinedProperties.length; j++)
                {
                    var property = userDefinedProperties[j]
                    prototypeExtensions[prototype.name].push
                    ({
                        name: property.name,
                        codeConstructId: property.declarationPosition != null && property.declarationPosition.codeConstruct != null
                                       ? property.declarationPosition.codeConstruct.nodeId
                                       : -1
                    });
                }
            }

            return prototypeExtensions;
        },

        getResourceSetterMap: function()
        {
            var map = {};

            var itemMap = this.executionInfo.resourceSetterPropertiesMap;

            for(var propName in itemMap)
            {
                map[propName] = itemMap[propName];
            }

            return map;
        },

        logStartExecutingCallbacks: function(codeConstruct)
        {
            for(var i = 0; i < this.startedExecutingCallbackCallbacks.length; i++)
            {
                var callbackObject = this.startedExecutingCallbackCallbacks[i];
                callbackObject.callback.call(callbackObject.thisObject, codeConstruct);
            }
        },

        logEndExecutingCallbacks: function(codeConstruct)
        {

            for(var i = 0; i < this.stoppedExecutingCallbackCallbacks.length; i++)
            {
                var callbackObject = this.stoppedExecutingCallbackCallbacks[i];
                callbackObject.callback.call(callbackObject.thisObject, codeConstruct);
            }
        },

        logEnteringFunction: function(callExpression, functionConstruct, executionContextId)
        {
            if(functionConstruct != null)
            {
                this.executionInfo.logEnteringFunction(functionConstruct, executionContextId);
            }

            this.callEnterFunctionCallbacks(callExpression, functionConstruct, executionContextId);
        },

        logExitingFunction: function()
        {
            this.callExitFunctionCallbacks();
        },

        logConstructExecuted: function(codeConstruct)
        {
            if(codeConstruct == null || codeConstruct.type == null) { return; }

            codeConstruct.hasBeenExecuted = true;
            this.executionInfo.logExecutedConstruct(codeConstruct);

            var parentStatementOrFunction = ASTHelper.getParentStatementOrFunction(codeConstruct);
            if(parentStatementOrFunction != null)
            {
                parentStatementOrFunction.hasBeenExecuted = true;
                this.executionInfo.logExecutedConstruct(parentStatementOrFunction);
            }
        },

        getSimplifiedForInIterations: function()
        {
            var forInIterations = this.executionInfo.objectForInIterations;
            var simplified = {};

            for(var i = 0; i < forInIterations.length; i++)
            {
                var forInIteration = forInIterations[i];

                if(simplified[forInIteration.codeConstruct.nodeId] == null)
                {
                    simplified[forInIteration.codeConstruct.nodeId] = { codeConstructId: forInIteration.codeConstruct.nodeId, prototypes:{}};
                }

                var internalPrototypes = forInIteration.proto.iValue.getInternalPrototypeChain();

                for(var j = 0; j < internalPrototypes.length; j++)
                {
                    simplified[forInIteration.codeConstruct.nodeId].prototypes[internalPrototypes[j].name] = 1;
                }
            }

            return simplified;
        },

        getForInIterationsLog: function()
        {
            return this.executionInfo.objectForInIterations;
        },

        logAccessingUndefinedProperty: function(propertyName, codeConstruct)
        {
            this.executionInfo.logAccessingUndefinedProperty(propertyName, codeConstruct);
        },

        logAccessingSizeProperty: function(propertyName, codeConstruct)
        {
            this.executionInfo.logAccessingSizeProperty(propertyName, codeConstruct);
        },

        logResourceSetting: function(codeConstruct, resourcePath)
        {
            this.executionInfo.logResourceSetting(codeConstruct, resourcePath);
        },

        logForInIteration: function(codeConstruct, objectPrototype)
        {
            this.executionInfo.logForInIteration(codeConstruct, objectPrototype);
        },

        logModifyingExternalContextIdentifier: function(identifier)
        {
            this.executionInfo.logModifyingExternalContextIdentifier(identifier);
        },

        logReadingIdentifierOutsideCurrentScope: function(identifier, codeConstruct)
        {
            this.executionInfo.logReadingIdentifierOutsideCurrentScope(identifier, codeConstruct);
        },

        logReadingObjectPropertyOutsideCurrentScope: function(creationConstructId, propertyName, codeConstruct)
        {
            this.executionInfo.logReadingObjectPropertyOutsideCurrentScope(creationConstructId, propertyName, codeConstruct);
        },

        logModifyingExternalContextObject: function(objectCreationConstructId, propertyName)
        {
            this.executionInfo.logModifyingExternalContextObject(objectCreationConstructId, propertyName);
        },

        addPathConstraint: function(codeConstruct, constraint, inverse)
        {
            this.executionInfo.addConstraint(codeConstruct, constraint, inverse);
        },

        simpleDependencyEstablished: function(fromConstruct, toConstruct)
        {
            this.executionInfo.logDependencies(fromConstruct, toConstruct);
        },

        _insertIntoDom: function(htmlDomElement, parentDomElement)
        {
            if (htmlDomElement.tagName != null
                &&(htmlDomElement.tagName.toLowerCase() == "html"
                || htmlDomElement.tagName.toLowerCase() == "head"
                || htmlDomElement.tagName.toLowerCase() == "body"))
            {
                return;
            }

            if(htmlDomElement.tagName != null && htmlDomElement.tagName.toLowerCase() == "script")
            {
                //This is necessary in order to disable the automatic in-browser interpretation of script code
                htmlDomElement.type="DONT_PROCESS_SCRIPT";
            }

            parentDomElement == null ? this.hostDocument.appendChild(htmlDomElement)
                : parentDomElement.appendChild(htmlDomElement);

            this._callNodeInsertedCallbacks(htmlDomElement.modelElement, parentDomElement != null ? parentDomElement.modelElement : null);
        },

        _buildCssNodes: function(cssHtmlElementModelNode)
        {
            cssHtmlElementModelNode.cssRules = cssHtmlElementModelNode.pathAndModel.model.rules;
            var cssText = "";
            for(var i = 0; i < cssHtmlElementModelNode.cssRules.length; i++)
            {
                var cssRule = cssHtmlElementModelNode.cssRules[i];
                cssRule.hasBeenExecuted = true;
                this.callNodeCreatedCallbacks(cssRule, "css", false);
                this._callNodeInsertedCallbacks(cssRule, cssHtmlElementModelNode);
                cssText += cssRule.cssText;
                this.cssRules.push(cssRule);
            }

            if(this._isExternalStyleLink(cssHtmlElementModelNode))
            {
                if(cssHtmlElementModelNode.domElement != null)
                {
                    cssHtmlElementModelNode.domElement.textContent = cssText;
                }
            }
        },

        createDependenciesBetweenHtmlNodeAndCssNodes: function(htmlModelNode)
        {
            if(htmlModelNode == null || htmlModelNode.type == "textNode") { return; }

            var cssRules = this.cssRules;

            for(var i = 0, length = cssRules.length; i < length; i++)
            {
                var cssRule = cssRules[i];

                if(this.matchesSelector(htmlModelNode.domElement, cssRule.selector))
                {
                    this.callDataDependencyEstablishedCallbacks(htmlModelNode, cssRule, this.globalObject.getPreciseEvaluationPositionId());
                }
            }
        },

        matchesSelector: function(htmlElement, selector)
        {
            if(htmlElement == null || this._matchesSelector == null || selector == null
            || ValueTypeHelper.isDocumentFragment(htmlElement) || ValueTypeHelper.isTextNode(htmlElement)
            || ValueTypeHelper.isDocument(htmlElement)) { return false; }

            if(selector.indexOf(":hover") != -1 || selector.indexOf(":active") != -1)
            {
                selector = selector.replace(/:hover|:active/gi, "");
            }

            try
            {
                return this._matchesSelector.call(htmlElement, selector);
            }
            catch(e)
            {
                //debugger;
                return false;
            }
        },

        _buildJavaScriptNodes: function(scriptHtmlElementModelNode)
        {
            try
            {
                var that = this;
                ASTHelper.traverseAst(scriptHtmlElementModelNode.pathAndModel.model, function(currentNode, nodeName, parentNode)
                {
                    that.callNodeCreatedCallbacks(currentNode, "js", false);
                    that._callNodeInsertedCallbacks(currentNode, ASTHelper.isProgram(parentNode) ? scriptHtmlElementModelNode : parentNode);
                });
            }
            catch(e) { this.notifyError("DoppelBrowser.browser error when building js nodes: " + e); }
        },

        _isExecutionWithinHandler: function(eventTrace, handlerConstruct)
        {
            if(eventTrace == null || handlerConstruct == null) { return false; }

            //TODO FF15 removed source: handlerConstruct.loc.source.replace("///", "/") == eventFile add this also when compensate
            return eventTrace.line >= handlerConstruct.loc.start.line && eventTrace.line <= handlerConstruct.loc.end.line;
        },

        _isBrowserGeneratedEvent: function(eventTrace)
        {
            if (eventTrace == null || eventTrace.args == null) { return false; }

            return eventTrace.args.type === "" || eventTrace.args.type == "load"
                || eventTrace.args.type == "DOMContentLoaded";
        },

        _isElementEvent: function(eventTrace, eventType)
        {
            if (eventTrace == null || eventTrace.args == null) { return false; }

            return eventTrace.args.type == eventType || "on" + eventTrace.args.type == eventType
                || eventTrace.args.type == "elementEvent";
        },

        _handleEvents: function()
        {
            try
            {
                console.log("Started handling events");

                if(this.pageModel.eventTraces == null) { return; }

                this.globalObject.document.addProperty("readyState", new fcModel.fcValue("complete", null, null));

                var eventTraces = this.pageModel.eventTraces;

                var domContentReadyMethods = this.globalObject.getDOMContentLoadedHandlers();
                var onLoadFunctions = this.globalObject.getOnLoadFunctions();

                var htmlElementEvents = this.globalObject.htmlElementEventHandlingRegistrations;
                var timeoutEvents = this.globalObject.timeoutHandlers;
                var intervalEvents = this.globalObject.intervalHandlers;

                for(var i = 0, length = eventTraces.length; i < length; i++)
                {
                    var eventTrace = eventTraces[i];
                    this._adjustCurrentInputStates(eventTrace.args.currentInputStates);
                    var eventFile = eventTrace.filePath;
                    this.globalObject.currentEventTime = eventTrace.currentTime;

                    if(eventTrace.args.type == "focus") continue;

                    if(this._isBrowserGeneratedEvent(eventTrace))
                    {
                        if(this._handleDomContentReadyMethods(domContentReadyMethods, eventTrace)) { continue; }
                        if(this._handleOnLoadMethod(onLoadFunctions, eventTrace)) { continue; }
                        if(this._handleTimingEvents(intervalEvents, timeoutEvents, eventTrace)) { continue; }
                    }
                    else
                    {
                        this._handleHtmlEvents(htmlElementEvents, eventTrace);
                    }

                    if(!eventTrace.hasBeenHandled)
                    {
                        console.log(eventTrace.args.type + "@" + eventTrace.line + " not handled!");
                    }
                    else
                    {
                        console.log(eventTrace.args.type + "@" + eventTrace.line + " handled!");
                    }
                }

                console.log("Events handled");
            }
            catch(e)
            {
                this.notifyError("Error when handling events: " + e + this.url + e.fileName +  e.lineNumber );
            }
        },

        _handleDomContentReadyMethods: function(domContentReadyMethods, eventTrace)
        {
            var domContentReadyInfo = domContentReadyMethods[0];

            if(domContentReadyInfo != null)
            {
                var handlerConstruct = domContentReadyInfo.handler.codeConstruct;

                if(this._isExecutionWithinHandler(eventTrace, handlerConstruct))
                {
                    this._interpretJsCode
                    (
                        handlerConstruct.body,
                        {
                            functionHandler: domContentReadyInfo.handler,
                            thisObject: domContentReadyInfo.thisObject,
                            argumentValues: [],
                            registrationPoint: domContentReadyInfo.registrationPoint
                        }
                    );

                    eventTrace.hasBeenHandled = true;

                    domContentReadyMethods.shift();
                    return true;
                }
            }

            return false;
        },

        _handleOnLoadMethod: function(onLoadFunctions, eventTrace)
        {
            for(var i = 0; i < onLoadFunctions.length; i++)
            {
                var onLoadInfo = onLoadFunctions[i];

                var handlerConstruct = onLoadInfo.handler.codeConstruct;

                if(this._isExecutionWithinHandler(eventTrace, handlerConstruct))
                {
                    this._interpretJsCode
                    (
                        handlerConstruct.body,
                        {
                            functionHandler: onLoadInfo.handler,
                            thisObject: this.globalObject,
                            argumentValues: this._getArguments(eventTrace.args, this.globalObject),
                            registrationPoint: onLoadInfo.registrationPoint
                        }
                    );

                    eventTrace.hasBeenHandled = true;

                    ValueTypeHelper.removeFromArrayByIndex(onLoadFunctions, i);
                    return true;
                }
            }

            return false;
        },

        _handleTimingEvents: function(intervalEvents, timeoutEvents, eventTrace)
        {
            for(var j = 0, intervalLength = intervalEvents.length; j < intervalLength; j++)
            {
                var event = intervalEvents[j];

                var handlerConstruct = event.handler.codeConstruct;

                if(this._isExecutionWithinHandler(eventTrace, handlerConstruct))
                {
                    this._interpretJsCode
                    (
                        handlerConstruct.body,
                        {
                            functionHandler: event.handler,
                            thisObject: this.globalObject,
                            argumentValues: event.callArguments,
                            registrationPoint: event.registrationPoint
                        }
                    );

                    eventTrace.hasBeenHandled = true;

                    break;
                }
            }

            for(var j = 0, timeoutLength = timeoutEvents.length; j < timeoutLength; j++)
            {
                var event = timeoutEvents[j];

                var handlerConstruct = event.handler.codeConstruct;

                if(this._isExecutionWithinHandler(eventTrace, handlerConstruct))
                {
                    this._interpretJsCode
                    (
                        handlerConstruct.body,
                        {
                            functionHandler: event.handler,
                            thisObject: this.globalObject,
                            argumentValues: event.callArguments,
                            registrationPoint: event.registrationPoint
                        }
                    );

                    eventTrace.hasBeenHandled = true;

                    if(j < timeoutEvents.length)
                    {
                        ValueTypeHelper.removeFromArrayByIndex(timeoutEvents, j);
                    }

                    break;
                }
            }
        },

        _handleHtmlEvents: function(htmlElementEvents, eventTrace)
        {
            var targetElement = this._getElementByXPath(eventTrace.args.targetXPath);
            var thisElement = this._getElementByXPath(eventTrace.thisValue.xPath);

            if(eventTrace.args != null && eventTrace.args.type == "readystatechange")
            {
                targetElement = this.globalObject.document.implementationObject;;
                thisElement = this.globalObject.document.implementationObject;
            }

            var event = this._getMatchingEventTrace(htmlElementEvents, eventTrace, targetElement, thisElement);

            if(event == null)
            {
                event = this._getMatchingEventTrace(htmlElementEvents, eventTrace, targetElement, thisElement, true);
            }

            if(event != null)
            {
                var eventThisObject = new fcModel.fcValue(event.fcHtmlElement.htmlElement, event.fcHtmlElement, null);
                var handlerConstruct = event.handler.codeConstruct;

                this._interpretJsCode
                (
                    handlerConstruct.body,
                    {
                        functionHandler: event.handler,
                        thisObject: eventThisObject,
                        argumentValues: this._getArguments(eventTrace.args, eventThisObject),
                        registrationPoint: event.registrationPoint
                    }
                );

                eventTrace.hasBeenHandled = true;
            }
        },

        _getMatchingEventTrace: function(htmlElementEvents, eventTrace, targetElement, thisElement, allowAncestors)
        {
            for(var i = 0, htmlEventsLength = htmlElementEvents.length; i < htmlEventsLength; i++)
            {
                var event = htmlElementEvents[i];
                var fcHtmlElement = event.fcHtmlElement;

                if(!fcHtmlElement.isGlobalObject)
                {
                    //if the xPath matches or if the event raising element is within the event handling element
                    if(allowAncestors)
                    {
                        if(!this._isElementOrAncestor(fcHtmlElement.htmlElement, targetElement)
                        && !this._isElementOrAncestor(fcHtmlElement.htmlElement, thisElement)) { continue; }
                    }
                    else
                    {
                        if(fcHtmlElement.htmlElement != targetElement
                        && fcHtmlElement.htmlElement != thisElement) { continue; }
                    }
                }

                if(this._isElementEvent(eventTrace, event.eventType))
                {
                    var handlerConstruct = event.handler.codeConstruct;

                    if(this._isExecutionWithinHandler(eventTrace, handlerConstruct))
                    {
                        return event;
                    }
                }
            }
        },

        _adjustCurrentInputStates: function(currentInputStates)
        {
            if(currentInputStates == null || currentInputStates.length == 0) { return; }

            for(var i = 0, length = currentInputStates.length; i < length; i++)
            {
                var inputState = currentInputStates[i];

                var wrappedElement = this.globalObject.document.getElementByXPath(inputState.elementXPath)

                if(wrappedElement != null && wrappedElement.value != null)
                {
                    var element = wrappedElement.value;
                    element.checked = inputState.checked;
                    element.value = inputState.value;
                }
            }
        },

        registerNodeCreatedCallback: function(callback, thisObject)
        {
            if(!ValueTypeHelper.isFunction(callback)) { this.notifyError("DoppelBrowser.Browser - node created callback has to be a function!"); return; }

            this.nodeCreatedCallbacks.push({callback: callback, thisObject: thisObject || this});
        },

        registerNodeInsertedCallback: function(callback, thisObject)
        {
            if(!ValueTypeHelper.isFunction(callback)) { this.notifyError("DoppelBrowser.Browser - node inserted callback has to be a function!"); return; }

            this.nodeInsertedCallbacks.push({callback: callback, thisObject: thisObject || this});
        },

        registerInterpretJsCallback: function(callback, thisObject)
        {
            if(!ValueTypeHelper.isFunction(callback)) { this.notifyError("DoppelBrowser.Browser - interpret js callback has to be a function!"); return; }

            this.interpretJsCallbacks.push({callback: callback, thisObject: thisObject || this});
        },

        registerExpressionEvaluatedCallback: function(callback, thisObject)
        {
            if(!ValueTypeHelper.isFunction(callback)) { this.notifyError("DoppelBrowser.Browser - expression evaluated callback has to be a function!"); return; }

            this.expressionEvaluatedCallbackInfo = {callback: callback, thisObject: thisObject || this};
        },

        registerControlFlowProblematicExpressionReachedCallback: function(callback, thisObject)
        {
            if(!ValueTypeHelper.isFunction(callback)) { this.notifyError("DoppelBrowser.Browser - control flow problematic callback has to be a function!"); return; }

            this.controlFlowProblematicCallbacks.push({callback: callback, thisObject: thisObject || this});
        },

        registerInterpreterMessageGeneratedCallback: function(callback, thisObject)
        {
            if(!ValueTypeHelper.isFunction(callback)) { this.notifyError("DoppelBrowser.Browser - interpreter message generated callback has to be a function!"); return; }

            this.interpreterMessageGeneratedCallbacks.push({callback: callback, thisObject: thisObject || this});
        },

        registerInterpretJsCallback: function(callback, thisObject)
        {
            if(!ValueTypeHelper.isFunction(callback)) { this.notifyError("DoppelBrowser.Browser - interpret js callback has to be a function!"); return; }

            this.interpretJsCallbacks.push({callback: callback, thisObject: thisObject || this});
        },

        registerControlFlowConnectionCallback: function(callback, thisObject)
        {
            if(!ValueTypeHelper.isFunction(callback)) { this.notifyError("DoppelBrowser.Browser - control flow connection callback has to be a function!"); return; }

            this.controlFlowConnectionCallbacks.push({callback: callback, thisObject: thisObject || this});
        },

        registerControlDependencyEstablishedCallback: function(callback, thisObject)
        {
            if(!ValueTypeHelper.isFunction(callback)) { this.notifyError("DoppelBrowser.Browser - control dependency established callback has to be a function!"); return; }

            this.controlDependencyEstablishedCallbacks.push({callback: callback, thisObject: thisObject || this});
        },

        registerDataDependencyEstablishedCallback: function(callback, thisObject)
        {
            if(!ValueTypeHelper.isFunction(callback)) { this.notifyError("DoppelBrowser.Browser - data dependency established callback has to be a function!"); return; }

            this.dataDependencyEstablishedCallbacks.push({callback: callback, thisObject: thisObject || this});
        },

        registerImportantConstructReachedCallback: function(callback, thisObject)
        {
            if(!ValueTypeHelper.isFunction(callback)) { this.notifyError("DoppelBrowser.Browser - important construct reached callback has to be a function!"); return; }

            this.importantConstructReachedCallbacks.push({callback: callback, thisObject: thisObject || this});
        },

        registerBreakContinueReturnEventReached: function(callback, thisObject)
        {
            if(!ValueTypeHelper.isFunction(callback)) { this.notifyError("DoppelBrowser.Browser - break continue return event construct reached callback has to be a function!"); return; }

            this.breakContinueReturnEventsCallbacks.push({callback: callback, thisObject: thisObject || this});
        },

        registerDocumentReadyCallback: function(callback, thisObject)
        {
            if(!ValueTypeHelper.isFunction(callback)) { this.notifyError("DoppelBrowser.Browser - important document ready callback has to be a function!"); return; }

            this.documentReadyCallbacks.push({callback: callback, thisObject: thisObject || this});
        },

        registerEnterFunctionCallback: function(callback, thisObject)
        {
            if(!ValueTypeHelper.isFunction(callback)) { this.notifyError("DoppelBrowser.Browser - enter function callback has to be a function!"); return; }

            this.enterFunctionCallbacks.push({callback: callback, thisObject: thisObject || this});
        },

        registerExitFunctionCallback: function(callback, thisObject)
        {
            if(!ValueTypeHelper.isFunction(callback)) { this.notifyError("DoppelBrowser.Browser - enter function callback has to be a function!"); return; }

            this.exitFunctionCallbacks.push({callback: callback, thisObject: thisObject || this});
        },

        registerCallbackCalled: function(callback, thisObject)
        {
            if(!ValueTypeHelper.isFunction(callback)) { this.notifyError("DoppelBrowser.Browser - enter function callback has to be a function!"); return; }

            this.callbackCalledCallbacks.push({callback: callback, thisObject: thisObject || this});
        },

        registerCallbackStartedExecuting: function(callback, thisObject)
        {
            if(!ValueTypeHelper.isFunction(callback)) { this.notifyError("DoppelBrowser.Browser - enter function callback has to be a function!"); return; }

            this.startedExecutingCallbackCallbacks.push({callback: callback, thisObject: thisObject || this});
        },

        registerCallbackStoppedExecuting: function(callback, thisObject)
        {
            if(!ValueTypeHelper.isFunction(callback)) { this.notifyError("DoppelBrowser.Browser - enter function callback has to be a function!"); return; }

            this.stoppedExecutingCallbackCallbacks.push({callback: callback, thisObject: thisObject || this});
        },

        _callDocumentReadyCallbacks: function()
        {
            for(var i = 0; i < this.documentReadyCallbacks.length; i++)
            {
                var callbackObject = this.documentReadyCallbacks[i];
                callbackObject.callback.call(callbackObject.thisObject);
            }
        },

        callEnterFunctionCallbacks: function(callExpression, functionConstruct, executionContextId)
        {
            for(var i = 0; i < this.enterFunctionCallbacks.length; i++)
            {
                var callbackObject = this.enterFunctionCallbacks[i];
                callbackObject.callback.call(callbackObject.thisObject, callExpression, functionConstruct, executionContextId);
            }
        },

        callCallbackCalledCallbacks: function(callbackConstruct, callCallbackConstruct, evaluationPosition)
        {
            for(var i = 0; i < this.callbackCalledCallbacks.length; i++)
            {
                var callbackObject = this.callbackCalledCallbacks[i];
                callbackObject.callback.call(callbackObject.thisObject, callbackConstruct, callCallbackConstruct, evaluationPosition);
            }
        },

        callExitFunctionCallbacks: function()
        {
            for(var i = 0; i < this.exitFunctionCallbacks.length; i++)
            {
                var callbackObject = this.exitFunctionCallbacks[i];
                callbackObject.callback.call(callbackObject.thisObject);
            }
        },

        callNodeCreatedCallbacks: function(nodeModelObject, nodeType, isDynamic)
        {
            for(var i = 0; i < this.nodeCreatedCallbacks.length; i++)
            {
                var callbackObject = this.nodeCreatedCallbacks[i];
                callbackObject.callback.call(callbackObject.thisObject, nodeModelObject, nodeType, isDynamic);
            }
        },

        callExpressionEvaluatedCallbacks: function(codeConstruct)
        {
            this.expressionEvaluatedCallbackInfo.callback.call(this.expressionEvaluatedCallbackInfo.thisObject, codeConstruct);
        },

        callControlFlowProblematicReachedCallbacks: function(codeConstruct)
        {
            for(var i = 0; i < this.controlFlowProblematicCallbacks.length; i++)
            {
                var callbackObject = this.controlFlowProblematicCallbacks[i];
                callbackObject.callback.call(callbackObject.thisObject, codeConstruct);
            }
        },

        _callNodeInsertedCallbacks: function(nodeModelObject, nodeType, isDynamic)
        {
            for(var i = 0; i < this.nodeInsertedCallbacks.length; i++)
            {
                var callbackObject = this.nodeInsertedCallbacks[i];
                callbackObject.callback.call(callbackObject.thisObject, nodeModelObject, nodeType, isDynamic);
            }
        },

        _callInterpreterMessageGeneratedCallbacks: function(message)
        {
            for(var i = 0; i < this.interpreterMessageGeneratedCallbacks.length; i++)
            {
                var callbackObject = this.interpreterMessageGeneratedCallbacks[i];
                callbackObject.callback.call(callbackObject.thisObject, message);
            }
        },

        _callInterpretJsCallbacks: function(programModel)
        {
            for(var i = 0; i < this.interpretJsCallbacks.length; i++)
            {
                var callbackObject = this.interpretJsCallbacks[i];
                callbackObject.callback.call(callbackObject.thisObject, programModel);
            }
        },

        _callControlFlowConnectionCallbacks: function(codeConstruct)
        {
            for(var i = 0; i < this.controlFlowConnectionCallbacks.length; i++)
            {
                var callbackObject = this.controlFlowConnectionCallbacks[i];
                callbackObject.callback.call(callbackObject.thisObject, codeConstruct);
            }
        },

        callControlDependencyEstablishedCallbacks: function(sourceNode, targetNode, dependencyCreationInfo, destinationNodeDependencyInfo, isPreviouslyExecutedBlockStatementDependency)
        {
            for(var i = 0; i < this.controlDependencyEstablishedCallbacks.length; i++)
            {
                var callbackObject = this.controlDependencyEstablishedCallbacks[i];
                callbackObject.callback.call(callbackObject.thisObject, sourceNode, targetNode, dependencyCreationInfo, destinationNodeDependencyInfo, isPreviouslyExecutedBlockStatementDependency);
            }
        },

        callDataDependencyEstablishedCallbacks: function(sourceNode, targetNode, dependencyCreationInfo, destinationNodeDependencyInfo, shouldNotFollowDependencies, isValueDependency)
        {
            if(sourceNode == null || targetNode == null) { return; }

            for(var i = 0; i < this.dataDependencyEstablishedCallbacks.length; i++)
            {
                var callbackObject = this.dataDependencyEstablishedCallbacks[0];
                callbackObject.callback.call
                (
                    callbackObject.thisObject, sourceNode, targetNode,
                    dependencyCreationInfo, destinationNodeDependencyInfo, shouldNotFollowDependencies,
                    isValueDependency
                );
            }
        },

        logDomQueried: function(methodName, selector, codeConstruct)
        {
            if(this.domQueriesMap[codeConstruct.nodeId] == null)
            {
                this.domQueriesMap[codeConstruct.nodeId] = { methodName: methodName, selectorsMap: {}, codeConstruct: codeConstruct};
            }

            this.domQueriesMap[codeConstruct.nodeId].selectorsMap[selector] = true;
        },

        logDynamicId: function(idValue, codeConstructId, nodeId)
        {
            if(this.dynamicIdMap[idValue] == null) { this.dynamicIdMap[idValue] = { value: idValue, codeConstructIdMap: {}, nodeIdMap: {}}; }

            this.dynamicIdMap[idValue].codeConstructIdMap[codeConstructId] = 1;
            this.dynamicIdMap[idValue].nodeIdMap[nodeId] = 1;
        },

        logDynamicClass: function(classValue, codeConstructId, nodeId)
        {
            if(this.dynamicClassMap[classValue] == null) { this.dynamicClassMap[classValue] = { value: classValue, codeConstructIdMap: {}, nodeIdMap: {}}; }

            this.dynamicClassMap[classValue].codeConstructIdMap[codeConstructId] = 1;
            this.dynamicClassMap[classValue].nodeIdMap[nodeId] = 1;
        },

        //TODO - think about new name
        callBreakContinueReturnEventCallbacks: function(node, evaluationPosition, isCallbackReturn)
        {
            for(var i = 0; i < this.breakContinueReturnEventsCallbacks.length; i++)
            {
                var callbackObject = this.breakContinueReturnEventsCallbacks[i];
                callbackObject.callback.call(callbackObject.thisObject, node, evaluationPosition, isCallbackReturn);
            }
        },

        callImportantConstructReachedCallbacks: function(importantNode)
        {
            this.executionInfo.logImportantModificationReached(importantNode);
            for(var i = 0; i < this.importantConstructReachedCallbacks.length; i++)
            {
                var callbackObject = this.importantConstructReachedCallbacks[i];
                callbackObject.callback.call(callbackObject.thisObject, importantNode);
            }
        },

        _getDocumentObject: function()
        {
            return Firecrow.IsDebugMode ? document : Firecrow.fbHelper._getCurrentPageDocument();
        },

        registerSlicingCriteria: function(slicingCriteria)
        {
            this.globalObject.registerSlicingCriteria(slicingCriteria);
        },

        _isElementOrAncestor: function(potentialAncestor, element)
        {
            if(element == null || potentialAncestor == null) { return false;}
            if(element == potentialAncestor) { return true; }
            if(element.parentElement == null) { return false; }

            if(potentialAncestor.nodeType == 9) { return true; } //document is ancestor to all!

            element = element.parentElement;

            while(element != null)
            {
                if(element == potentialAncestor) { return true; }

                element = element.parentElement;
            }

            return false;
        },

        _getElementByXPath: function(xPath)
        {
            if(xPath == "window" || xPath == "") { return this.globalObject; }
            if(xPath == "document") { return this.globalObject.document.implementationObject; }

            try
            {
                return this.globalObject.document.implementationObject.evaluate
                (
                    xPath,
                    this.globalObject.document.implementationObject,
                    null, XPathResult.FIRST_ORDERED_NODE_TYPE,
                    null
                ).singleNodeValue;
            }
            catch(e)
            {
                alert("Getting element by XPath: " + xPath);
                debugger;
                return this.globalObject;
            }
        },

        _getElementXPath: function(element)
        {
            var paths = [];

            for (; element && element.nodeType == 1; element = element.parentNode)
            {
                var index = 0;
                for (var sibling = element.previousSibling; sibling; sibling = sibling.previousSibling)
                {
                    if (sibling.localName == element.localName)
                        ++index;
                }

                var tagName = element.localName.toLowerCase();
                var pathIndex = (index ? "[" + (index+1) + "]" : "");
                paths.splice(0, 0, tagName + pathIndex);
            }

            return paths.length ? "/" + paths.join("/") : "";
        },

        _getArguments: function(eventTraceArgs, thisValue)
        {
            var arguments = [];

            var eventInfo = {};
            var eventInfoJsObject = new fcModel.Event(eventInfo, this.globalObject, thisValue);

            for(var propName in eventTraceArgs)
            {
                if(propName == "currentInputStates") { continue; }

                if(propName.indexOf("XPath") != -1)
                {
                    var element =  this.globalObject.document.getElementByXPath(eventTraceArgs[propName]);
                    propName = propName.replace("XPath", "");
                    eventInfoJsObject.addProperty(propName, element);
                    eventInfo[propName] = element;
                }
                else
                {
                    var value = this.globalObject.internalExecutor.createInternalPrimitiveObject(null, eventTraceArgs[propName]);
                    eventInfoJsObject.addProperty(propName, value);
                    eventInfo[propName] = value;
                }
            }

            arguments.push(new fcModel.fcValue(eventInfo, eventInfoJsObject, null));

            return arguments;
        },

        destruct: function()
        {
            fcBrowser.Browser.LAST_USED_ID = 0;

            delete this.pageModel;

            this.hostDocument = null;
            delete this.hostDocument;

            delete this.htmlWebFile;

            this.globalObject.destruct();
            delete this.globalObject;

            delete this.nodeCreatedCallbacks;
            delete this.nodeInsertedCallbacks;
            delete this.interpretJsCallbacks;

            delete this.dataDependencyEstablishedCallbacks;
            delete this.controlDependencyEstablishedCallbacks;
            delete this.interpreterMessageGeneratedCallbacks;
            delete this.controlFlowConnectionCallbacks;
            delete this.importantConstructReachedCallbacks;
            delete this.documentReadyCallbacks;
            delete this.enterFunctionCallbacks;
            delete this.exitFunctionCallbacks;
            delete this.breakContinueReturnEventsCallbacks;

            delete this.domQueriesMap;

            delete this.errorMessages;
            delete this.cssRules;

            delete this.executionInfo;
        },

        notifyError: function(message) { Firecrow.DoppelBrowser.Browser.notifyError(message); }
    };

    fcBrowser.Browser.isForSlicing = false;
}});FBL.ns(function() { with (FBL) {
/*************************************************************************************/
var fcBrowser = Firecrow.DoppelBrowser;
var fcModel = Firecrow.Interpreter.Model;
var ValueTypeHelper = Firecrow.ValueTypeHelper;
var ASTHelper = Firecrow.ASTHelper;

Firecrow.DATA_DEPENDENCIES = {};

fcBrowser.ExecutionInfo = function()
{
    this.pathConstraint = new Firecrow.ScenarioGenerator.Symbolic.PathConstraint();

    this.undefinedGlobalPropertiesAccessMap = {};
    this.resourceSetterPropertiesMap = {};
    this.objectForInIterations = [];

    this.globalModifiedIdentifiers = {};
    this.globalModifiedObjects = {};

    this.afterLoadingModifiedIdentifiers = {};
    this.afterLoadingModifiedObjects = {};

    this.globalAccessedIdentifiers = {};
    this.globalAccessedObjects = {};

    this.afterLoadingAccessedIdentifiers = {};
    this.afterLoadingAccessedObjects = {};

    this.eventRegistrations = [];
    this.eventExecutionsMap = {};
    this.typeExecutionMap = {};
    this.eventExecutions = [];
    this.currentEventExecutionInfo = null;

    this.executedConstructsIdMap = {};
    this.dataDependencies = {};
    this.branchingConstructs = {};
    this.importantModifications = {};

    this.sizePropertiesAccessMap = {};
};

fcBrowser.ExecutionInfo.shouldKeepAllSimpleDependencies = false;

fcBrowser.ExecutionInfo.prototype =
{
    setSerializeToReuseJson: function()
    {
        this.toJSON = this.toReuseJson;
    },

    toReuseJson: function()
    {
        return {
            dependencyGraph: this.dependencyGraph,
            includedNodeIds: this.includedNodeIds,
            domQueriesMap: this._getSimplifiedDomQueries(this.domQueriesMap),
            dynamicIdMap: this.dynamicIdMap,
            dynamicClassMap: this.dynamicClassMap,
            userSetGlobalProperties: this.userSetGlobalProperties,
            userSetDocumentProperties: this.userSetDocumentProperties,
            undefinedGlobalProperties: this.undefinedGlobalProperties,
            eventHandlerPropertiesMap: this.eventHandlerPropertiesMap,
            resourceSetterMap: this.resourceSetterMap,
            prototypeExtensions: this.prototypeExtensions,
            forInIterations: this.forInIterations,
            dataDependencies: Firecrow.DATA_DEPENDENCIES,
            postProcessorInclusions: this.postProcessorInclusions
        };
    },

    _getSimplifiedDomQueries: function(domQueriesMap)
    {
        var simplifiedMap = {};

        for(var prop in domQueriesMap)
        {
            simplifiedMap[prop] = { methodName: domQueriesMap[prop].methodName, selectorsMap: domQueriesMap[prop].selectorsMap };
        }

        return simplifiedMap;
    },

    toJSON: function()
    {
        return {
            pathConstraint: this.pathConstraint,

            undefinedGlobalPropertiesAccessMap: this.getUndefinedGlobalPropertiesAccessMapJson(),
            sizePropertiesAccessMap: this.getSizePropertiesAccessMapJson(this),
            /*Resource setter and for in iterations are not required*/

            globalModifiedIdentifiers: ValueTypeHelper.convertObjectPropertyNamesToArray(this.globalModifiedIdentifiers),
            /*SKIPPED global modified objects, for now*/

            afterLoadingModifiedIdentifiers: ValueTypeHelper.convertObjectPropertyNamesToArray(this.afterLoadingModifiedIdentifiers),
            afterLoadingModifiedObjects: this.afterLoadingModifiedObjects,

            globalAccessedIdentifiers: ValueTypeHelper.convertObjectPropertyNamesToArray(this.globalAccessedIdentifiers),
            /*SKIPPED global accessed objects, for now*/

            afterLoadingAccessedIdentifiers: ValueTypeHelper.convertObjectPropertyNamesToArray(this.afterLoadingAccessedIdentifiers),
            afterLoadingAccessedObjects: ValueTypeHelper.convertObjectPropertyNamesToArray(this.afterLoadingAccessedObjects),

            eventRegistrations: this._getEventRegistrationsJson(this.eventRegistrations),
            eventExecutionsMap: this._getEventExecutionsMapJson(),
            typeExecutionMap: this._getTypeExecutionMapJson(),
            eventExecutions: this._getEventExecutionsJson(),
            executedConstructsIdMap: ValueTypeHelper.convertObjectPropertyNamesToArray(this.executedConstructsIdMap),
            /*SKIPPED DATA DEPENDENCIES*/
            branchingConstructs: ValueTypeHelper.convertObjectPropertyNamesToArray(this.branchingConstructs),
            /*SKIPPED IMPORTANT MODIFICATIONS*/

            dataDependencies: this.dataDependencies,
            achievedCoverage: this.achievedCoverage,
            hasImportantModifications: ValueTypeHelper.objectHasProperties(this.importantModifications),
            undefinedGlobalProperties: this.undefinedGlobalProperties,
            postProcessorInclusions: this.postProcessorInclusions,
            cookie: this.cookie
        };
    },

    _getEventExecutionJson: function(eventExecution)
    {
        return {
            baseObjectDescriptor: eventExecution.baseObjectDescriptor,
            sizePropertiesAccessMap: this.getSizePropertiesAccessMapJson(eventExecution),
            branchingConstructs: ValueTypeHelper.convertObjectPropertyNamesToArray(eventExecution.branchingConstructs),
            eventDescriptor: eventExecution.eventDescriptor,
            eventRegistrations: this._getEventRegistrationsJson(eventExecution.eventRegistrations),
            eventType: eventExecution.eventType,
            globalAccessedIdentifiers: ValueTypeHelper.convertObjectPropertyNamesToArray(eventExecution.globalAccessedIdentifiers),
            /*SKIPPED GLOBAL ACCESSED OBJECTS, for now*/
            globalModifiedIdentifiers: ValueTypeHelper.convertObjectPropertyNamesToArray(eventExecution.globalModifiedIdentifiers),
            globalModifiedObjects: eventExecution.globalModifiedObjects,
            /*SKIPPED important modifications*/
            typeDescriptor: eventExecution.typeDescriptor,
            typeVisitedFunctionsMap: ValueTypeHelper.convertObjectPropertyNamesToArray(eventExecution.typeVisitedFunctionsMap),
            visitedFunctionsMap: ValueTypeHelper.convertObjectPropertyNamesToArray(eventExecution.visitedFunctionsMap),
            dataDependencies: eventExecution.dataDependencies
        };
    },


    getUndefinedGlobalPropertiesAccessMapJson: function()
    {
        var obj = {};

        for(var propertyName in this.undefinedGlobalPropertiesAccessMap)
        {
            if(!this.undefinedGlobalPropertiesAccessMap.hasOwnProperty(propertyName)) { continue; }
            if(obj[propertyName] == null) { obj[propertyName] = [] }

            for(var constructId in this.undefinedGlobalPropertiesAccessMap[propertyName])
            {
                if(!this.undefinedGlobalPropertiesAccessMap[propertyName].hasOwnProperty(constructId)) { continue; }
                try
                {
                    obj[propertyName].push(constructId);
                }
                catch(e)
                {
                    debugger;
                }
            }
        }

        return obj;
    },

    getSizePropertiesAccessMapJson: function(executionInfo)
    {
        var obj = {};

        for(var propertyName in executionInfo.sizePropertiesAccessMap)
        {
            if(!executionInfo.sizePropertiesAccessMap.hasOwnProperty(propertyName)) { continue; }
            if(obj[propertyName] == null) { obj[propertyName] = [] }

            for(var constructId in executionInfo.sizePropertiesAccessMap[propertyName])
            {
                if(!executionInfo.sizePropertiesAccessMap[propertyName].hasOwnProperty(constructId)) { continue; }
                try
                {
                    obj[propertyName].push(constructId);
                }
                catch(e)
                {
                    debugger;
                }
            }
        }

        return obj;
    },

    _getEventRegistrationsJson: function(eventRegistrations)
    {
        var eventRegistrationsInfo = [];

        for(var i = 0; i < eventRegistrations.length; i++)
        {
            var eventRegistration = eventRegistrations[i];

            eventRegistrationsInfo.push
            ({
                eventType: eventRegistration.eventType,
                thisObjectDescriptor: eventRegistration.thisObjectDescriptor,
                thisObjectModelNodeId: eventRegistration.thisObjectModel != null ? eventRegistration.thisObjectModel.nodeId || -1 : null,
                registrationConstructNodeId: eventRegistration.registrationConstruct != null ? eventRegistration.registrationConstruct.nodeId : null,
                handlerConstructNodeId: eventRegistration.handlerConstruct != null ? eventRegistration.handlerConstruct.nodeId : null,
                timePeriod: eventRegistration.timePeriod,
                timerId: eventRegistration.timerId,
                thisObjectCssSelector: eventRegistration.thisObjectCssSelector
            });
        }

        return eventRegistrationsInfo;
    },

    _getEventExecutionsMapJson: function()
    {
        var object = {};

        for(var thisDescriptor in this.eventExecutionsMap)
        {
            object[thisDescriptor] = {};

            for(var eventType in this.eventExecutionsMap[thisDescriptor])
            {
                object[thisDescriptor][eventType] = [];

                for(var functionNodeId in this.eventExecutionsMap[thisDescriptor][eventType])
                {
                    object[thisDescriptor][eventType].push(functionNodeId);
                }
            }
        }

        return object;
    },

    _getTypeExecutionMapJson: function()
    {
        var object = { };

        for(var eventTypeId in this.typeExecutionMap)
        {
            object[eventTypeId] = [];

            for(var functionConstructId in this.typeExecutionMap[eventTypeId])
            {
                object[eventTypeId].push(functionConstructId);
            }
        }

        return object;
    },

    _getEventExecutionsJson: function()
    {
        var eventExecutionsJson = [];

        for(var i = 0; i < this.eventExecutions.length; i++)
        {
            eventExecutionsJson.push(this._getEventExecutionJson(this.eventExecutions[i]));
        }

        return eventExecutionsJson;
    },

    getLastEventInfoString: function()
    {
        var object = this.currentEventExecutionInfo || this;
        return "PathConstraint: " + this.pathConstraint.toString() + "\r\n"
            +  "AI: " + ValueTypeHelper.convertObjectPropertyNamesToArray(object.globalAccessedIdentifiers).join(",")  + "\r\n"
            +  "MI: " + ValueTypeHelper.convertObjectPropertyNamesToArray(object.globalModifiedIdentifiers).join(",") + "\r\n"
            +  "MO: " + ValueTypeHelper.convertObjectPropertyNamesToArray(object.globalModifiedObjects).join(",") + "\r\n"
            +  "AO: " + ValueTypeHelper.convertObjectPropertyNamesToArray(object.globalAccessedObjects).join(",");
    },

    lastExecutionSummaryModifiesDom: function()
    {
        if(this.currentEventExecutionInfo == null) { return ValueTypeHelper.objectHasProperties(this.importantModifications); }

        return ValueTypeHelper.objectHasProperties(this.currentEventExecutionInfo.importantModifications);
    },

    executionSummaryFromEndModifiesDom: function(indexFromEnd)
    {
        var eventExecutionInfo = this.eventExecutions[this.eventExecutions.length - indexFromEnd];

        if(eventExecutionInfo == null) { return false; }

        return ValueTypeHelper.objectHasProperties(eventExecutionInfo.importantModifications);
    },

    logImportantModificationReached: function(codeConstruct)
    {
        if(codeConstruct == null) { return; }

        if(this.currentEventExecutionInfo != null)
        {
            this.currentEventExecutionInfo.importantModifications[codeConstruct.nodeId] = codeConstruct;
        }

        this.importantModifications[codeConstruct.nodeId] = codeConstruct;
    },

    logEventExecution: function(baseObjectDescriptor, eventType, handlerConstruct)
    {
        if(this.currentEventExecutionInfo == null && (eventType == "onload" || eventType == "DOMContentLoaded" || eventType == "load"))
        {
            return;
        }

        if(baseObjectDescriptor == null || eventType == null) { debugger; alert("Error when logging event execution"); return; }

        var typeDescriptor = eventType + handlerConstruct.nodeId;

        if(this.eventExecutionsMap[baseObjectDescriptor] == null)
        {
            this.eventExecutionsMap[baseObjectDescriptor] = {};
        }

        if(this.eventExecutionsMap[baseObjectDescriptor][eventType] == null)
        {
            this.eventExecutionsMap[baseObjectDescriptor][eventType] = {};
        }

        if(this.typeExecutionMap[typeDescriptor] == null)
        {
            this.typeExecutionMap[typeDescriptor] = {};
        }

        this.currentEventExecutionInfo =
        {
            baseObjectDescriptor: baseObjectDescriptor,
            eventType: eventType,
            visitedFunctionsMap: this.eventExecutionsMap[baseObjectDescriptor][eventType],
            typeVisitedFunctionsMap: this.typeExecutionMap[typeDescriptor],
            eventDescriptor: baseObjectDescriptor + eventType,
            typeDescriptor: typeDescriptor,
            globalModifiedIdentifiers: {},
            globalAccessedIdentifiers: {},
            eventRegistrations: [],
            globalAccessedObjects: {},
            globalModifiedObjects: {},
            branchingConstructs: {},
            importantModifications: {},
            dataDependencies: {},
            sizePropertiesAccessMap: {}
        };

        this.eventExecutions.push(this.currentEventExecutionInfo);
    },

    logExecutedConstruct: function(codeConstruct)
    {
        if(codeConstruct == null) { return; }

        this.executedConstructsIdMap[codeConstruct.nodeId] = true;

        if(this.currentEventExecutionInfo != null)
        {
            if(codeConstruct.test != null)
            {
                this.currentEventExecutionInfo.branchingConstructs[codeConstruct.test.nodeId] = codeConstruct.test;
            }

            if(codeConstruct.discriminant != null)
            {
                this.currentEventExecutionInfo.branchingConstructs[codeConstruct.discriminant.nodeId] = codeConstruct.discriminant;
            }
        }

        if(codeConstruct.test != null)
        {
            this.branchingConstructs[codeConstruct.test.nodeId] = codeConstruct.test;
        }

        if(codeConstruct.discriminant != null)
        {
            this.branchingConstructs[codeConstruct.discriminant.nodeId] = codeConstruct.discriminant;
        }

        if(this.currentEventExecutionInfo != null)
        {
            if(codeConstruct.executorEventsMap == null) { codeConstruct.executorEventsMap = {}; }

            codeConstruct.executorEventsMap[this.currentEventExecutionInfo.eventDescriptor] = true;
            codeConstruct.executorEventsMap[this.currentEventExecutionInfo.typeDescriptor] = true;
        }
    },

    logEnteringFunction: function(functionConstruct, executionContextId)
    {
        if(functionConstruct == null) { return; }

        if(this.currentEventExecutionInfo != null)
        {
            this.currentEventExecutionInfo.visitedFunctionsMap[functionConstruct.nodeId] = functionConstruct;
            this.currentEventExecutionInfo.typeVisitedFunctionsMap[functionConstruct.nodeId] = functionConstruct;
        }
    },

    logDependencies: function(fromConstruct, toConstruct)
    {
        if(fromConstruct == null || toConstruct == null || fromConstruct.nodeId == null || toConstruct.nodeId == null) { return; }

        if(fcBrowser.ExecutionInfo.shouldKeepAllSimpleDependencies)
        {
            //if(this.dataDependencies[fromConstruct.nodeId] == null) { this.dataDependencies[fromConstruct.nodeId] = {}; }
            if(Firecrow.DATA_DEPENDENCIES[fromConstruct.nodeId] == null) { Firecrow.DATA_DEPENDENCIES[fromConstruct.nodeId] = {}; }

            //this.dataDependencies[fromConstruct.nodeId][toConstruct.nodeId] = true;
            Firecrow.DATA_DEPENDENCIES[fromConstruct.nodeId][toConstruct.nodeId] = true;
        }

        if(this.currentEventExecutionInfo != null)
        {
            if(this.currentEventExecutionInfo.dataDependencies[fromConstruct.nodeId] == null) { this.currentEventExecutionInfo.dataDependencies[fromConstruct.nodeId] = {}; }
            this.currentEventExecutionInfo.dataDependencies[fromConstruct.nodeId][toConstruct.nodeId] = true;
        }
    },

    addConstraint: function(codeConstruct, constraint, inverse)
    {
        if(constraint == null) { return; }

        this.pathConstraint.addConstraint(codeConstruct, constraint, inverse);
    },

    addPathConstraintItem: function(pathConstraintItem)
    {
        this.pathConstraint.addPathConstraintItem(pathConstraintItem);
    },

    addPathConstraintItemToBeginning: function(pathConstraintItem)
    {
        this.pathConstraint.addPathConstraintItemToBeginning(pathConstraintItem);
    },

    compareExecutedConstructs: function(executionInfoB)
    {
        var executedConstructsA = this.executedConstructsIdMap;
        var executedConstructsB = executionInfoB.executedConstructsIdMap;

        var totalExecutionInfoAProperties = 0;
        var totalExecutionInfoBProperties = 0;
        var commonPropertiesNumber = 0;

        var isFirstIterationOverB = true;

        for(var nodeIdA in executedConstructsA)
        {
            for(var nodeIdB in executedConstructsB)
            {
                if(isFirstIterationOverB)
                {
                    totalExecutionInfoBProperties++;
                }

                if(nodeIdA == nodeIdB)
                {
                    commonPropertiesNumber++;
                }
            }

            totalExecutionInfoAProperties++;
            isFirstIterationOverB = false;
        }

        return {
            areEqual: commonPropertiesNumber == totalExecutionInfoAProperties
                && commonPropertiesNumber == totalExecutionInfoBProperties,

            isFirstSubsetOfSecond: commonPropertiesNumber == totalExecutionInfoAProperties
                &&  totalExecutionInfoAProperties < totalExecutionInfoBProperties,

            isSecondSubsetOfFirst: commonPropertiesNumber == totalExecutionInfoBProperties
                &&  totalExecutionInfoBProperties < totalExecutionInfoAProperties
        };
    },

    logAccessingUndefinedProperty: function(propertyName, codeConstruct)
    {
        if(codeConstruct == null || fcModel.GlobalObject.CONST.isEventProperty(propertyName)) { return; }

        if(this.undefinedGlobalPropertiesAccessMap[propertyName] == null)
        {
            this.undefinedGlobalPropertiesAccessMap[propertyName] = {};
        }

        this.undefinedGlobalPropertiesAccessMap[propertyName][codeConstruct.nodeId] = codeConstruct;
    },

    logAccessingSizeProperty: function(propertyName, codeConstruct)
    {
        if(codeConstruct == null) { return; }

        var executionInfo = this.currentEventExecutionInfo || this;

        if(executionInfo.sizePropertiesAccessMap[propertyName] == null) { executionInfo.sizePropertiesAccessMap[propertyName] = {}; }

        executionInfo.sizePropertiesAccessMap[propertyName][codeConstruct.nodeId] = codeConstruct
    },

    logResourceSetting: function(codeConstruct, resourcePath)
    {
        if(codeConstruct == null) { return; }

        this.resourceSetterPropertiesMap[codeConstruct.nodeId] =
        {
            codeConstruct: codeConstruct,
            resourceValue: resourcePath
        };
    },

    logForInIteration: function(codeConstruct, objectPrototype)
    {
        //console.log("Not logging for in iterations");
        this.objectForInIterations.push({ proto: objectPrototype, codeConstruct: codeConstruct });
    },

    getLastEventRegistrations: function()
    {
        return this.eventExecutions[this.eventExecutions.length - 1] != null
            ? this.eventExecutions[this.eventExecutions.length - 1].eventRegistrations
            : this.eventRegistrations;
    },

    logEventRegistered: function(thisObjectDescriptor, thisObjectModel, eventType, registrationConstruct, handlerConstruct, loadingEventsExecuted, timerId, timePeriod, thisObjectCssSelector)
    {
        var eventRegistrationInfo =
        {
            thisObjectDescriptor: thisObjectDescriptor,
            thisObjectModel: thisObjectModel,
            eventType: eventType,
            registrationConstruct: registrationConstruct,
            handlerConstruct: handlerConstruct,
            loadingEventsExecuted: loadingEventsExecuted,
            timerId: timerId,
            timePeriod: timePeriod,
            thisObjectCssSelector: thisObjectCssSelector
        };

        if(this.currentEventExecutionInfo != null)
        {
            this.currentEventExecutionInfo.eventRegistrations.push(eventRegistrationInfo);
        }

        this.eventRegistrations.push(eventRegistrationInfo);
    },

    logEventDeRegistered: function(htmlNode, eventType, deregistrationConstruct, timerId)
    {
        if(eventType == "interval") { this._removeFirstRegisteredEventByTypeAndTimerId(eventType, timerId); return; }
    },

    _removeFirstRegisteredEventByTypeAndTimerId: function(eventType, timerId)
    {
        return;
        for(var i = 0, length = this.eventRegistrations.length; i < length; i++)
        {
            var eventRegistration = this.eventRegistrations[i];

            if(eventRegistration.eventType == eventType && eventRegistration.timerId == timerId)
            {
                ValueTypeHelper.removeFromArrayByIndex(this.eventRegistrations, i);
                break;
            }
        }

        for(var i = 0; i < this.eventExecutions.length; i++)
        {
            var eventExecution = this.eventExecutions[i];

            for(var j = 0; j < eventExecution.eventRegistrations.length; j++)
            {
                var eventRegistration = eventExecution.eventRegistrations[j];

                if(eventRegistration.eventType == eventType && eventRegistration.timerId == timerId)
                {
                    ValueTypeHelper.removeFromArrayByIndex(eventExecution.eventRegistrations, i);
                    return;
                }
            }
        }
    },

    logModifyingExternalContextIdentifier: function(identifier)
    {
        if(identifier.declarationPosition == null) { return; }
        if(identifier.declarationPosition.codeConstruct == null) { return; }
        //START TEST
        if(this.currentEventExecutionInfo != null)
        {
            //MEMORY//this.currentEventExecutionInfo.globalModifiedIdentifiers[identifier.declarationPosition.codeConstruct.nodeId] = identifier.declarationPosition.codeConstruct;
            this.afterLoadingModifiedIdentifiers[identifier.declarationPosition.codeConstruct.nodeId] = identifier.declarationPosition.codeConstruct;
        }

        this.globalModifiedIdentifiers[identifier.declarationPosition.codeConstruct.nodeId] = identifier.declarationPosition.codeConstruct;

        return;
        //END TEST

        if(identifier.name.indexOf("_FC_") == 0) { return; }

        var modifiedIdentifierInfoID = identifier.name + "_FC_" + identifier.declarationPosition.codeConstruct.nodeId;
        if(this.currentEventExecutionInfo != null)
        {
            this.currentEventExecutionInfo.globalModifiedIdentifiers[modifiedIdentifierInfoID] = true;
        }

        this.globalModifiedIdentifiers[modifiedIdentifierInfoID] = true;
    },

    logReadingIdentifierOutsideCurrentScope: function(identifier, codeConstruct)
    {
        //START TEST
        if(!ASTHelper.isBranchingConditionConstruct(codeConstruct)) { return; }

        if(this.currentEventExecutionInfo != null)
        {
            this.currentEventExecutionInfo.globalAccessedIdentifiers[codeConstruct.nodeId] = codeConstruct;
            this.afterLoadingAccessedIdentifiers[codeConstruct.nodeId] = codeConstruct;
        }

        this.globalAccessedIdentifiers[codeConstruct.nodeId] = codeConstruct;

        return;
        //END TEST

        //OLD CODE BELOW

        //The idea was to log only identifiers that are in the branching statements
        //but that is not correct, because of the following case:
        //one event writes to a "global" variable A, the global variable A is used to create a global variable B
        //global variable B influences the control flow
        if(identifier.declarationPosition == null) { return; }
        if(identifier.name.indexOf("_FC_") == 0) { return; }

        var accessedGlobalIdentifierInfoID = identifier.name + "_FC_" + identifier.declarationPosition.codeConstruct.nodeId;

        if(this.currentEventExecutionInfo != null)
        {
            this.currentEventExecutionInfo.globalAccessedIdentifiers[accessedGlobalIdentifierInfoID] = true;
        }

        this.globalAccessedIdentifiers[accessedGlobalIdentifierInfoID] = true;
    },

    logReadingObjectPropertyOutsideCurrentScope: function(objectCreationConstructId, propertyName, codeConstruct)
    {
        //START TEST
        if(!ASTHelper.isBranchingConditionConstruct(codeConstruct)) { return; }

        if(this.currentEventExecutionInfo != null)
        {
            this.currentEventExecutionInfo.globalAccessedObjects[codeConstruct.nodeId] = codeConstruct;
            this.afterLoadingAccessedObjects[codeConstruct.nodeId] = codeConstruct;
        }

        this.globalAccessedObjects[codeConstruct.nodeId] = codeConstruct;

        return;
        //END TEST
        if(ValueTypeHelper.isNumber(propertyName)) { return; }

        var accessedObjectInfoID = propertyName + "_FC_" + objectCreationConstructId;

        if(this.currentEventExecutionInfo != null)
        {
            this.currentEventExecutionInfo.globalAccessedObjects[accessedObjectInfoID] = true;
        }

        this.globalAccessedObjects[accessedObjectInfoID] = true;
    },

    logModifyingExternalContextObject: function(objectCreationConstructId, propertyName)
    {
        //START TEST
        if(this.currentEventExecutionInfo != null)
        {
            //MEMORY//this.currentEventExecutionInfo.globalModifiedObjects[objectCreationConstructId] = propertyName;
            this.afterLoadingModifiedObjects[objectCreationConstructId] = propertyName;
        }

        this.globalModifiedObjects[objectCreationConstructId] = propertyName;
        return;
        //END TEST
        if(ValueTypeHelper.isNumber(propertyName)) { return; }

        var modifiedObjectInfoID = propertyName + "_FC_" + objectCreationConstructId;

        if(this.currentEventExecutionInfo != null)
        {
            this.currentEventExecutionInfo.globalModifiedObjects[modifiedObjectInfoID] = true;
        }

        this.globalModifiedObjects[modifiedObjectInfoID] = true;
    },

    isDependentOn: function(executionInfo, checkWholeExecution)
    {
        return this._isIdentifierDependent(executionInfo, checkWholeExecution) || this._isObjectModificationsDependent(executionInfo, checkWholeExecution);
    },

    _isIdentifierDependent: function(executionInfo, checkWholeExecution)
    {
        //Compare only to last event execution info (since all events are always traversed)
        var thisGlobalAccessedIdentifiers = this.eventExecutions[this.eventExecutions.length - 1] != null && !checkWholeExecution
                                          ? this.eventExecutions[this.eventExecutions.length - 1].globalAccessedIdentifiers
                                          : this.globalAccessedIdentifiers;

        var comparisonGlobalModifiedIdentifiers = executionInfo.eventExecutions[executionInfo.eventExecutions.length - 1] != null && !checkWholeExecution
                                                ? executionInfo.eventExecutions[executionInfo.eventExecutions.length - 1].globalModifiedIdentifiers
                                                : executionInfo.globalModifiedIdentifiers;

        for(var accessedIdentifier in thisGlobalAccessedIdentifiers)
        {
            if(comparisonGlobalModifiedIdentifiers[accessedIdentifier])
            {
                return true;
            }
        }

        return false;
    },

    _isObjectModificationsDependent: function(executionInfo, checkWholeExecution)
    {
        //Compare only to last event execution info (since all events are always traversed)
        var thisGlobalAccessedObjects = this.eventExecutions[this.eventExecutions.length - 1] != null && !checkWholeExecution
                                      ? this.eventExecutions[this.eventExecutions.length - 1].globalAccessedObjects
                                      : this.globalAccessedObjects;

        var comparisonGlobalModifiedObjects = executionInfo.eventExecutions[executionInfo.eventExecutions.length - 1] != null && !checkWholeExecution
                                            ? executionInfo.eventExecutions[executionInfo.eventExecutions.length - 1].globalModifiedObjects
                                            : executionInfo.globalModifiedObjects;

        for(var accessed in thisGlobalAccessedObjects)
        {
            if(comparisonGlobalModifiedObjects[accessed])
            {
                return true;
            }
        }

        return false;
    }
};

/*************************************************************************************/
}});FBL.ns(function() { with (FBL) {
/*************************************************************************************/
Firecrow.Interpreter.DependencyGenerator =
{
    generateDependencies: function(callbackFunction, thisValue)
    {
        var WebFile = Firecrow.DoppelBrowser.WebFile;
        var Browser = Firecrow.DoppelBrowser.Browser;
        var webFile = new WebFile("file:///C:/GitWebStorm/Firecrow/debug/testFiles/08/index.html");

        var dependencyGraph = new Firecrow.DependencyGraph.DependencyGraph();
        var browser = new Browser(webFile, []);

        browser.registerNodeCreatedCallback(dependencyGraph.handleNodeCreated, dependencyGraph);
        browser.registerNodeInsertedCallback(dependencyGraph.handleNodeInserted, dependencyGraph);
        browser.registerDataDependencyEstablishedCallback(dependencyGraph.handleDataDependencyEstablished, dependencyGraph);
        browser.registerControlDependencyEstablishedCallback(dependencyGraph.handleControlDependencyEstablished, dependencyGraph);
        browser.registerImportantConstructReachedCallback(dependencyGraph.handleImportantConstructReached, dependencyGraph);

        browser.asyncBuildPage(function()
        {
            var allNodes = dependencyGraph.nodes;

            for(var i = 0, length = allNodes.length; i < length; i++)
            {
                var node = allNodes[i];
                var nodeModel = node.model;

                if(nodeModel.dependencies == null) { nodeModel.dependencies = [];}

                var edges = node.dataDependencies;

                for(var j = 0, depLength = edges.length; j < depLength; j++)
                {
                    var edge = edges[j];
                    var destinationModel = edge.destinationNode.model;

                    nodeModel.dependencies.push(destinationModel.nodeId);
                }
            }

            if(callbackFunction != null)
            {
                callbackFunction.call(thisValue, browser.model);
            }
        });
    }
}
/*************************************************************************************/
}});/**
 * User: Jomaras
 * Date: 13.07.12.
 * Time: 08:06
 */
FBL.ns(function() { with (FBL) {
// ************************************************************************************************
    Firecrow.Slicer = {
        slice: function(htmlModel, slicingCriteria, url, executeRegisteredEvents, doNotFixSliceUnionProblems)
        {
            var Firecrow = FBL.Firecrow;
            Firecrow.ASTHelper.setParentsChildRelationships(htmlModel);

            var dependencyGraph = new Firecrow.DependencyGraph.DependencyGraph();
            Firecrow.DoppelBrowser.Browser.isForSlicing = true;
            var browser = new Firecrow.DoppelBrowser.Browser(htmlModel);
            Firecrow.Slicer.browser = browser;
            browser.url = url || htmlModel.pageUrl;

            Firecrow.Interpreter.Simulator.DependencyCreator.shouldCreateDependencies = true;

            browser.registerSlicingCriteria(slicingCriteria);
            browser.registerNodeCreatedCallback(dependencyGraph.handleNodeCreated, dependencyGraph);
            browser.registerNodeInsertedCallback(dependencyGraph.handleNodeInserted, dependencyGraph);
            browser.registerDataDependencyEstablishedCallback(dependencyGraph.handleDataDependencyEstablished, dependencyGraph);
            browser.registerControlDependencyEstablishedCallback(dependencyGraph.handleControlDependencyEstablished, dependencyGraph);
            browser.registerImportantConstructReachedCallback(dependencyGraph.handleImportantConstructReached, dependencyGraph);
            browser.registerBreakContinueReturnEventReached(dependencyGraph.handleBreakContinueReturnEventReached, dependencyGraph);
            browser.registerEnterFunctionCallback(dependencyGraph.handleEnterFunction, dependencyGraph);
            browser.registerExitFunctionCallback(dependencyGraph.handleExitFunction, dependencyGraph);
            browser.registerCallbackCalled(dependencyGraph.handleCallbackCalled, dependencyGraph);
            browser.registerExpressionEvaluatedCallback(dependencyGraph.handleExpressionEvaluated, dependencyGraph);
            browser.registerCallbackStartedExecuting(dependencyGraph.handleCallbackStartedExecuting, dependencyGraph);
            browser.registerCallbackStoppedExecuting(dependencyGraph.handleCallbackStoppedExecuting, dependencyGraph);

            browser.evaluatePage();

            if(executeRegisteredEvents)
            {
                browser.executeLoadingEvents();
                browser.executeAjaxEvents();
                browser.executeTimingEvents();
            }

            Firecrow.DependencyGraph.DependencyGraph.sliceUnions = true;
            if(doNotFixSliceUnionProblems)
            {
                Firecrow.DependencyGraph.DependencyGraph.sliceUnions = false;
            }

            dependencyGraph.markGraph(htmlModel.htmlElement);

            return {
                browser: browser,
                dependencyGraph: dependencyGraph
            };
        },

        profile: function(htmlModel, url, executeRegisteredEvents)
        {
            var Firecrow = FBL.Firecrow;

            Firecrow.ASTHelper.setParentsChildRelationships(htmlModel);

            var dependencyGraph = new Firecrow.DependencyGraph.DependencyGraph();
            Firecrow.DoppelBrowser.Browser.isForSlicing = true;
            var browser = new Firecrow.DoppelBrowser.Browser(htmlModel);
            Firecrow.Slicer.browser = browser;
            browser.url = url || htmlModel.pageUrl;

            Firecrow.Interpreter.Simulator.DependencyCreator.shouldCreateDependencies = false;

            browser.evaluatePage();

            if(executeRegisteredEvents)
            {
                browser.executeLoadingEvents();
                browser.executeAjaxEvents();
                browser.executeTimingEvents();
            }

            return {
                browser: browser,
                dependencyGraph: dependencyGraph
            };
        },

        getSlicedCode: function(htmlModel, slicingCriteria, url)
        {
            this.slice(htmlModel, slicingCriteria, url);

            return FBL.Firecrow.CodeTextGenerator.generateSlicedCode(htmlModel);
        }
    };
// ************************************************************************************************
}});