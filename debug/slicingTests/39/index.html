<!DOCTYPE html>
<html>
<head>
    <title>Test</title>
</head>
<body>
<h2>Firecrow - simple Js Test</h2>
<div>JsTest</div>
<div id="resultContainer"></div>
<script>
    var Sylvester = { precision: 1e-6 }

    Sylvester.Vector = function() {};
    Sylvester.Vector.create = function(elements)
    {
        var V = new Sylvester.Vector();
        return V.setElements(elements);
    };

    Sylvester.Vector.prototype = {
        eql: function(vector) {
            var n = this.elements.length;
            var V = vector.elements || vector;
            if (n !== V.length) { return false; }
            while (n--) {
                if (Math.abs(this.elements[n] - V[n]) > Sylvester.precision) { return false; }
            }
            return true;
        },
        dup: function() {
            return Sylvester.Vector.create(this.elements);
        },

        subtract: function(vector) {
            var V = vector.elements || vector;
            if (this.elements.length !== V.length) { return null; }
            return this.map(function(x, i) { return x - V[i-1]; });
        },
        map: function(fn, context) {
            var elements = [];
            this.each(function(x, i) {
                elements.push(fn.call(context, x, i));
            });
            return Sylvester.Vector.create(elements);
        },
        to3D: function() {
            var V = this.dup();
            switch (V.elements.length) {
                case 3: break;
                case 2: V.elements.push(0); break;
                default: return null;
            }
            return V;
        },
        setElements: function(els) {
            this.elements = (els.elements || els).slice();
            return this;
        },
        forEach: function(fn, context) {
            var n = this.elements.length;
            for (var i = 0; i < n; i++) {
                fn.call(context, this.elements[i], i+1);
            }
        },
        modulus: function() {
            return Math.sqrt(this.dot(this));
        },
        dot: function(vector) {
            var V = vector.elements || vector;
            var i, product = 0, n = this.elements.length;
            if (n !== V.length) { return null; }
            while (n--) { product += this.elements[n] * V[n]; }
            return product;
        }
    }

    Sylvester.Vector.prototype.each = Sylvester.Vector.prototype.forEach;

    Sylvester.Line = function() {};
    Sylvester.Line.create = function(anchor, direction) {
        var L = new Sylvester.Line();
        return L.setVectors(anchor, direction);
    };

    Sylvester.Line.prototype =
    {
        setVectors: function(anchor, direction)
        {
            anchor = Sylvester.Vector.create(anchor);
            direction = Sylvester.Vector.create(direction);
            if (anchor.elements.length === 2) {anchor.elements.push(0); }
            if (direction.elements.length === 2) { direction.elements.push(0); }
            if (anchor.elements.length > 3 || direction.elements.length > 3) { return null; }
            var mod = direction.modulus();
            if (mod === 0) { return null; }
            this.anchor = anchor;
            this.direction = Sylvester.Vector.create([
                direction.elements[0] / mod,
                direction.elements[1] / mod,
                direction.elements[2] / mod
            ]);
            return this;
        }
    }

    Sylvester.Line.Segment = function() {};
    Sylvester.Line.Segment.create = function(v1, v2)
    {
        var S = new Sylvester.Line.Segment();
        return S.setPoints(v1, v2);
    };

    Sylvester.Line.Segment.prototype = {
        eql: function(segment)
        {
            return (this.start.eql(segment.start) && this.end.eql(segment.end)) ||
                    (this.start.eql(segment.end) && this.end.eql(segment.start));
        },

        setPoints: function(startPoint, endPoint)
        {
            startPoint = Sylvester.Vector.create(startPoint).to3D();
            endPoint = Sylvester.Vector.create(endPoint).to3D();
            if (startPoint === null || endPoint === null) { return null; }
            this.line = Sylvester.Line.create(startPoint, endPoint.subtract(startPoint));
            this.start = startPoint;
            this.end = endPoint;
            return this;
        }
    }

    segment = Sylvester.Line.Segment.create([5,5,5], [10,10,10]);
    var a1 = segment.eql(segment);
    a1;
</script>
</body>
</html>