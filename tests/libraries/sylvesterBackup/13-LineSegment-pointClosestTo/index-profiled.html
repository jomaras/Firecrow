<!DOCTYPE html>
<html>
  <head>
    <script>
      var Sylvester = {precision: 0.000001};
      Sylvester.Vector = function ()
      {};
      Sylvester.Vector.create = function (elements)
      {
        var V = new Sylvester.Vector();
        return V.setElements(elements);
      };
      var $V = Sylvester.Vector.create;
      Sylvester.Vector.Random = function (n)
      {};
      Sylvester.Vector.Zero = function (n)
      {
        var elements = [];
        while(n--)
        {
          elements.push(0);
        }

        return Sylvester.Vector.create(elements);
      };
      Sylvester.Vector.prototype = {
        e: function (i)
        {}, 
        dimensions: function ()
        {}, 
        modulus: function ()
        {
          return Math.sqrt(this.dot(this));
        }, 
        eql: function (vector)
        {
          var n = this.elements.length;
          var V = vector.elements || vector;
          while(n--)
          {
            if(Math.abs(this.elements[n] - V[n]) > Sylvester.precision)
            {
              return false;
            }
          }

          return true;
        }, 
        dup: function ()
        {
          return Sylvester.Vector.create(this.elements);
        }, 
        map: function (fn, context)
        {
          var elements = [];
          this.each(function (x, i)
          {
            elements.push(fn.call(context, x, i));
          });
          return Sylvester.Vector.create(elements);
        }, 
        forEach: function (fn, context)
        {
          var n = this.elements.length;
          for(var i = 0;i < n;i++)
          {
            fn.call(context, this.elements[i], i + 1);
          }
        }, 
        toUnitVector: function ()
        {
          var r = this.modulus();
          return this.map(function (x)
          {
            return x / r;
          });
        }, 
        angleFrom: function (vector)
        {
          var V = vector.elements;
          var n = this.elements.length, k = n, i;
          var dot = 0, mod1 = 0, mod2 = 0;
          this.each(function (x, i)
          {
            dot += x * V[i - 1];
            mod1 += x * x;
            mod2 += V[i - 1] * V[i - 1];
          });
          mod1 = Math.sqrt(mod1);
          mod2 = Math.sqrt(mod2);
          var theta = dot / (mod1 * mod2);
          return Math.acos(theta);
        }, 
        isParallelTo: function (vector)
        {}, 
        isAntiparallelTo: function (vector)
        {
          var angle = this.angleFrom(vector);
          return angle === null ? 0 : Math.abs(angle - Math.PI) <= Sylvester.precision;
        }, 
        isPerpendicularTo: function (vector)
        {
          var dot = this.dot(vector);
          return dot === null ? 0 : Math.abs(dot) <= Sylvester.precision;
        }, 
        add: function (vector)
        {}, 
        subtract: function (vector)
        {
          var V = vector.elements;
          return this.map(function (x, i)
          {
            return x - V[i - 1];
          });
        }, 
        multiply: function (k)
        {}, 
        dot: function (vector)
        {
          var V = vector.elements;
          var i, product = 0, n = this.elements.length;
          while(n--)
          {
            product += this.elements[n] * V[n];
          }

          return product;
        }, 
        cross: function (vector)
        {
          var B = vector.elements;
          var A = this.elements;
          return Sylvester.Vector.create([(A[1] * B[2]) - (A[2] * B[1]), (A[2] * B[0]) - (A[0] * B[2]), (A[0] * B[1]) - (A[1] * B[0])]);
        }, 
        max: function ()
        {}, 
        indexOf: function (x)
        {}, 
        toDiagonalMatrix: function ()
        {}, 
        round: function ()
        {}, 
        snapTo: function (x)
        {}, 
        distanceFrom: function (obj)
        {}, 
        liesOn: function (line)
        {}, 
        liesIn: function (plane)
        {}, 
        rotate: function (t, obj)
        {}, 
        reflectionIn: function (obj)
        {}, 
        to3D: function ()
        {
          var V = this.dup();
          switch(V.elements.length)
          {
            case 3:
              break;
          }
          return V;
        }, 
        inspect: function ()
        {}, 
        setElements: function (els)
        {
          this.elements = (els.elements || els).slice();
          return this;
        }
      };
      Sylvester.Vector.prototype.x = Sylvester.Vector.prototype.multiply;
      Sylvester.Vector.prototype.each = Sylvester.Vector.prototype.forEach;
      Sylvester.Vector.i = Sylvester.Vector.create([1, 0, 0]);
      Sylvester.Vector.j = Sylvester.Vector.create([0, 1, 0]);
      Sylvester.Vector.k = Sylvester.Vector.create([0, 0, 1]);
      Sylvester.Line = function ()
      {};
      Sylvester.Line.prototype = {
        eql: function (line)
        {}, 
        dup: function ()
        {}, 
        translate: function (vector)
        {
          var V = vector.elements || vector;
          return Sylvester.Line.create([this.anchor.elements[0] + V[0], this.anchor.elements[1] + V[1], this.anchor.elements[2] + (V[2] || 0)], this.direction);
        }, 
        isParallelTo: function (obj)
        {
          var theta = this.direction.angleFrom(obj.direction);
          return Math.abs(theta) <= Sylvester.precision || Math.abs(theta - Math.PI) <= Sylvester.precision;
        }, 
        distanceFrom: function (obj)
        {
          if(obj.direction)
          {
            if(this.isParallelTo(obj));

            var N = this.direction.cross(obj.direction).toUnitVector().elements;
            var A = this.anchor.elements, B = obj.anchor.elements;
            return Math.abs((((A[0] - B[0]) * N[0]) + ((A[1] - B[1]) * N[1])) + ((A[2] - B[2]) * N[2]));
          }
          else 
          {
            var P = obj.elements || obj;
            var A = this.anchor.elements, D = this.direction.elements;
            var PA1 = P[0] - A[0], PA2 = P[1] - A[1], PA3 = (P[2] || 0) - A[2];
            var modPA = Math.sqrt(((PA1 * PA1) + (PA2 * PA2)) + (PA3 * PA3));
            var cosTheta = (((PA1 * D[0]) + (PA2 * D[1])) + (PA3 * D[2])) / modPA;
            var sin2 = 1 - (cosTheta * cosTheta);
            return Math.abs(modPA * Math.sqrt(sin2 < 0 ? 0 : sin2));
          }
        }, 
        contains: function (obj)
        {
          var dist = this.distanceFrom(obj);
          return dist !== null && dist <= Sylvester.precision;
        }, 
        positionOf: function (point)
        {
          if(!(this.contains(point)));

          var P = point.elements;
          var A = this.anchor.elements, D = this.direction.elements;
          return (((P[0] - A[0]) * D[0]) + ((P[1] - A[1]) * D[1])) + (((P[2] || 0) - A[2]) * D[2]);
        }, 
        liesIn: function (plane)
        {}, 
        intersects: function (obj)
        {
          return !(this.isParallelTo(obj)) && this.distanceFrom(obj) <= Sylvester.precision;
        }, 
        intersectionWith: function (obj)
        {
          if(obj.normal || obj.start)
          {
            return obj.intersectionWith(this);
          }

          if(!(this.intersects(obj)));

          var P = this.anchor.elements, X = this.direction.elements, Q = obj.anchor.elements, Y = obj.direction.elements;
          var X1 = X[0], X2 = X[1], X3 = X[2], Y1 = Y[0], Y2 = Y[1], Y3 = Y[2];
          var PsubQ1 = P[0] - Q[0], PsubQ2 = P[1] - Q[1], PsubQ3 = P[2] - Q[2];
          var XdotQsubP = ((-X1 * PsubQ1) - (X2 * PsubQ2)) - (X3 * PsubQ3);
          var YdotPsubQ = ((Y1 * PsubQ1) + (Y2 * PsubQ2)) + (Y3 * PsubQ3);
          var XdotX = ((X1 * X1) + (X2 * X2)) + (X3 * X3);
          var YdotY = ((Y1 * Y1) + (Y2 * Y2)) + (Y3 * Y3);
          var XdotY = ((X1 * Y1) + (X2 * Y2)) + (X3 * Y3);
          var k = (((XdotQsubP * YdotY) / XdotX) + (XdotY * YdotPsubQ)) / (YdotY - (XdotY * XdotY));
          return Sylvester.Vector.create([P[0] + (k * X1), P[1] + (k * X2), P[2] + (k * X3)]);
        }, 
        pointClosestTo: function (obj)
        {
          if(obj.start)
          {
            var P;
          }
          else if(obj.direction)
          {
            if(this.intersects(obj))
            {
              return this.intersectionWith(obj);
            }

            if(this.isParallelTo(obj))
            {
              return null;
            }

            var D = this.direction.elements, E = obj.direction.elements;
            var D1 = D[0], D2 = D[1], D3 = D[2], E1 = E[0], E2 = E[1], E3 = E[2];
            var x = (D3 * E1) - (D1 * E3), y = (D1 * E2) - (D2 * E1), z = (D2 * E3) - (D3 * E2);
            var N = [(x * E3) - (y * E2), (y * E1) - (z * E3), (z * E2) - (x * E1)];
            var P = Sylvester.Plane.create(obj.anchor, N);
            return P.intersectionWith(this);
          }
          else 
          {
            var P = obj.elements;
            if(this.contains(P))
            {
              return Sylvester.Vector.create(P);
            }

            var A, D;
            var D1, D2, D3, A1, A2, A3;
            var x, y, z;
            var V;
            var k;
          }
        }, 
        rotate: function (t, line)
        {}, 
        reverse: function ()
        {}, 
        reflectionIn: function (obj)
        {}, 
        setVectors: function (anchor, direction)
        {
          anchor = Sylvester.Vector.create(anchor);
          direction = Sylvester.Vector.create(direction);
          var mod = direction.modulus();
          this.anchor = anchor;
          this.direction = Sylvester.Vector.create([direction.elements[0] / mod, direction.elements[1] / mod, direction.elements[2] / mod]);
          return this;
        }
      };
      Sylvester.Line.create = function (anchor, direction)
      {
        var L = new Sylvester.Line();
        return L.setVectors(anchor, direction);
      };
      var $L = Sylvester.Line.create;
      Sylvester.Line.X = Sylvester.Line.create(Sylvester.Vector.Zero(3), Sylvester.Vector.i);
      Sylvester.Line.Y = Sylvester.Line.create(Sylvester.Vector.Zero(3), Sylvester.Vector.j);
      Sylvester.Line.Z = Sylvester.Line.create(Sylvester.Vector.Zero(3), Sylvester.Vector.k);
      Sylvester.Line.Segment = function ()
      {};
      Sylvester.Line.Segment.prototype = {
        eql: function (segment)
        {}, 
        dup: function ()
        {}, 
        length: function ()
        {}, 
        toVector: function ()
        {
          var A = this.start.elements, B = this.end.elements;
          return Sylvester.Vector.create([B[0] - A[0], B[1] - A[1], B[2] - A[2]]);
        }, 
        midpoint: function ()
        {}, 
        bisectingPlane: function ()
        {}, 
        translate: function (vector)
        {}, 
        isParallelTo: function (obj)
        {}, 
        distanceFrom: function (obj)
        {}, 
        contains: function (obj)
        {
          var P = (obj.elements).slice();
          if(this.start.eql(P));

          var S = this.start.elements;
          var V = Sylvester.Vector.create([S[0] - P[0], S[1] - P[1], S[2] - (P[2] || 0)]);
          var vect = this.toVector();
          return V.isAntiparallelTo(vect) && V.modulus() <= vect.modulus();
        }, 
        intersects: function (obj)
        {}, 
        intersectionWith: function (obj)
        {}, 
        pointClosestTo: function (obj)
        {
          if(obj.normal)
          {
            var V = this.line.intersectionWith(obj);
            if(V === null)
            {
              return null;
            }

            return this.pointClosestTo(V);
          }
          else 
          {
            var P = this.line.pointClosestTo(obj);
            if(P === null)
            {
              return null;
            }

            if(this.contains(P))
            {
              return P;
            }

            return (this.line.positionOf(P) < 0 ? this.start : this.end).dup();
          }
        }, 
        setPoints: function (startPoint, endPoint)
        {
          startPoint = Sylvester.Vector.create(startPoint).to3D();
          endPoint = Sylvester.Vector.create(endPoint).to3D();
          this.line = Sylvester.Line.create(startPoint, endPoint.subtract(startPoint));
          this.start = startPoint;
          this.end = endPoint;
          return this;
        }
      };
      Sylvester.Line.Segment.create = function (v1, v2)
      {
        var S = new Sylvester.Line.Segment();
        return S.setPoints(v1, v2);
      };
      Sylvester.LinkedList = function ()
      {};
      Sylvester.LinkedList.prototype = {
        length: null, 
        first: null, 
        last: null, 
        forEach: function (fn, context)
        {}, 
        at: function (i)
        {}, 
        randomNode: function ()
        {}, 
        toArray: function ()
        {}
      };
      Sylvester.LinkedList.prototype.each = Sylvester.LinkedList.prototype.forEach;
      Sylvester.LinkedList.Node = function (data)
      {};
      Sylvester.LinkedList.Circular = function ()
      {};
      Sylvester.LinkedList.Circular.Methods = {
        append: function (node)
        {}, 
        prepend: function (node)
        {}, 
        insertAfter: function (node, newNode)
        {}, 
        insertBefore: function (node, newNode)
        {}, 
        remove: function (node)
        {}, 
        withData: function (data)
        {}
      };
      Sylvester.LinkedList.Circular.prototype = new Sylvester.LinkedList();
      for(var method in Sylvester.LinkedList.Circular.Methods)
      {
        Sylvester.LinkedList.Circular.prototype[method] = Sylvester.LinkedList.Circular.Methods[method];
      }

      Sylvester.LinkedList.Circular.fromArray = function (list, useNodes)
      {};
      Sylvester.Matrix = function ()
      {};
      Sylvester.Matrix.create = function (elements)
      {};
      var $M = Sylvester.Matrix.create;
      Sylvester.Matrix.I = function (n)
      {};
      Sylvester.Matrix.Diagonal = function (elements)
      {};
      Sylvester.Matrix.Rotation = function (theta, a)
      {};
      Sylvester.Matrix.RotationX = function (t)
      {};
      Sylvester.Matrix.RotationY = function (t)
      {};
      Sylvester.Matrix.RotationZ = function (t)
      {};
      Sylvester.Matrix.Random = function (n, m)
      {};
      Sylvester.Matrix.Zero = function (n, m)
      {};
      Sylvester.Matrix.prototype = {
        e: function (i, j)
        {}, 
        row: function (i)
        {}, 
        col: function (j)
        {}, 
        dimensions: function ()
        {}, 
        rows: function ()
        {}, 
        cols: function ()
        {}, 
        eql: function (matrix)
        {}, 
        dup: function ()
        {}, 
        map: function (fn, context)
        {}, 
        isSameSizeAs: function (matrix)
        {}, 
        add: function (matrix)
        {}, 
        subtract: function (matrix)
        {}, 
        canMultiplyFromLeft: function (matrix)
        {}, 
        multiply: function (matrix)
        {}, 
        minor: function (a, b, c, d)
        {}, 
        transpose: function ()
        {}, 
        isSquare: function ()
        {}, 
        max: function ()
        {}, 
        indexOf: function (x)
        {}, 
        diagonal: function ()
        {}, 
        toRightTriangular: function ()
        {}, 
        determinant: function ()
        {}, 
        isSingular: function ()
        {}, 
        trace: function ()
        {}, 
        rank: function ()
        {}, 
        augment: function (matrix)
        {}, 
        inverse: function ()
        {}, 
        round: function ()
        {}, 
        snapTo: function (x)
        {}, 
        inspect: function ()
        {}, 
        setElements: function (els)
        {}
      };
      Sylvester.Matrix.prototype.toUpperTriangular = Sylvester.Matrix.prototype.toRightTriangular;
      Sylvester.Matrix.prototype.det = Sylvester.Matrix.prototype.determinant;
      Sylvester.Matrix.prototype.tr = Sylvester.Matrix.prototype.trace;
      Sylvester.Matrix.prototype.rk = Sylvester.Matrix.prototype.rank;
      Sylvester.Matrix.prototype.inv = Sylvester.Matrix.prototype.inverse;
      Sylvester.Matrix.prototype.x = Sylvester.Matrix.prototype.multiply;
      Sylvester.Plane = function ()
      {};
      Sylvester.Plane.prototype = {
        eql: function (plane)
        {}, 
        dup: function ()
        {}, 
        translate: function (vector)
        {}, 
        isParallelTo: function (obj)
        {
          var theta;
          if(obj.normal);
          else if(obj.direction)
          {
            return this.normal.isPerpendicularTo(obj.direction);
          }
        }, 
        isPerpendicularTo: function (plane)
        {}, 
        distanceFrom: function (obj)
        {}, 
        contains: function (obj)
        {}, 
        intersects: function (obj)
        {
          return !(this.isParallelTo(obj));
        }, 
        intersectionWith: function (obj)
        {
          if(!(this.intersects(obj)))
          {
            return null;
          }

          if(obj.direction)
          {
            var A = obj.anchor.elements, D = obj.direction.elements, P = this.anchor.elements, N = this.normal.elements;
            var multiplier = (((N[0] * (P[0] - A[0])) + (N[1] * (P[1] - A[1]))) + (N[2] * (P[2] - A[2]))) / (((N[0] * D[0]) + (N[1] * D[1])) + (N[2] * D[2]));
            return Sylvester.Vector.create([A[0] + (D[0] * multiplier), A[1] + (D[1] * multiplier), A[2] + (D[2] * multiplier)]);
          }
          else if(false)
          {
            var direction;
            var N, A, O, B;
            var solver, i;
            var inverse;
            var x;
            var y;
            var intersection;
            var anchor;
            var j;
          }
        }, 
        pointClosestTo: function (point)
        {}, 
        rotate: function (t, line)
        {}, 
        reflectionIn: function (obj)
        {}, 
        setVectors: function (anchor, v1, v2)
        {
          anchor = Sylvester.Vector.create(anchor);
          anchor = anchor.to3D();
          v1 = Sylvester.Vector.create(v1);
          v1 = v1.to3D();
          if(typeof v2 === 'undefined')
          {
            v2 = null;
          }

          var A1 = anchor.elements[0], A2 = anchor.elements[1], A3 = anchor.elements[2];
          var v11 = v1.elements[0], v12 = v1.elements[1], v13 = v1.elements[2];
          var normal, mod;
          if(v2 !== null)
          {
            var v21, v22, v23;
          }
          else 
          {
            mod = Math.sqrt(((v11 * v11) + (v12 * v12)) + (v13 * v13));
            normal = Sylvester.Vector.create([v1.elements[0] / mod, v1.elements[1] / mod, v1.elements[2] / mod]);
          }

          this.anchor = anchor;
          this.normal = normal;
          return this;
        }
      };
      Sylvester.Plane.create = function (anchor, v1, v2)
      {
        var P = new Sylvester.Plane();
        return P.setVectors(anchor, v1, v2);
      };
      var $P = Sylvester.Plane.create;
      Sylvester.Plane.XY = Sylvester.Plane.create(Sylvester.Vector.Zero(3), Sylvester.Vector.k);
      Sylvester.Plane.YZ = Sylvester.Plane.create(Sylvester.Vector.Zero(3), Sylvester.Vector.i);
      Sylvester.Plane.ZX = Sylvester.Plane.create(Sylvester.Vector.Zero(3), Sylvester.Vector.j);
      Sylvester.Plane.YX = Sylvester.Plane.XY;
      Sylvester.Plane.ZY = Sylvester.Plane.YZ;
      Sylvester.Plane.XZ = Sylvester.Plane.ZX;
      Sylvester.Plane.fromPoints = function (points)
      {};
      Sylvester.Polygon = function ()
      {};
      Sylvester.Polygon.prototype = {
        v: function (i)
        {}, 
        nodeFor: function (vertex)
        {}, 
        dup: function ()
        {}, 
        translate: function (vector)
        {}, 
        rotate: function (t, line)
        {}, 
        scale: function (k, point)
        {}, 
        updateTrianglePlanes: function (fn)
        {}, 
        isTriangle: function ()
        {}, 
        trianglesForSurfaceIntegral: function ()
        {}, 
        area: function ()
        {}, 
        centroid: function ()
        {}, 
        projectionOn: function (plane)
        {}, 
        removeVertex: function (vertex)
        {}, 
        contains: function (point)
        {}, 
        containsByWindingNumber: function (point)
        {}, 
        hasEdgeContaining: function (point)
        {}, 
        toTriangles: function ()
        {}, 
        triangulateByEarClipping: function ()
        {}, 
        setVertices: function (points, plane)
        {}, 
        populateVertexTypeLists: function ()
        {}, 
        copyVertices: function ()
        {}, 
        clearCache: function ()
        {}, 
        setCache: function (key, value)
        {}, 
        inspect: function ()
        {}
      };
      Sylvester.Polygon.create = function (points, plane)
      {};
      Sylvester.Polygon.Vertex = function (point)
      {};
      Sylvester.Polygon.Vertex.prototype = new Sylvester.Vector();
      Sylvester.Polygon.Vertex.prototype.isConvex = function (polygon)
      {};
      Sylvester.Polygon.Vertex.prototype.isReflex = function (polygon)
      {};
      Sylvester.Polygon.Vertex.prototype.type = function (polygon)
      {};
      Sylvester.Polygon.Vertex.convert = function (points)
      {};
    </script>
  </head>
  <body>
    <h2>Sylvester - test</h2>
    <div id="resultContainer">
    </div>
    <script>
      var segment = Sylvester.Line.Segment.create([5, 5, 5], [10, 10, 10]);
      var segment2 = Sylvester.Line.Segment.create([1, 1, 0], [1, 2, 0]);
      var a1 = segment2.pointClosestTo(Sylvester.Line.Y) == null;
      var a2 = segment2.pointClosestTo(Sylvester.Line.X).eql([1, 1, 0]);
      var a3 = segment2.pointClosestTo(Sylvester.Line.X.translate([0, 10])).eql([1, 2, 0]);
      var a4 = segment2.pointClosestTo($L([0, 1.5, 0], [0, 0, 1])).eql([1, 1.5, 0]);
      var a5 = segment2.pointClosestTo(Sylvester.Plane.XZ).eql([1, 1, 0]);
      var a6 = segment2.pointClosestTo(Sylvester.Plane.YZ) == null;
      a1;
      a2;
      a3;
      a4;
      a5;
      a6;
    </script>
  </body>
</html>
