<!DOCTYPE html>
<html>
  <head>
    <script>
      var Sylvester = {precision: 0.000001};
      Sylvester.Matrix = function ()
      {};
      Sylvester.Matrix.create = function (elements)
      {
        var M = new Sylvester.Matrix();
        return M.setElements(elements);
      };
      var $M;
      Sylvester.Matrix.I = function (n)
      {
        var els = [], i = n, j;
        while(i--)
        {
          j = n;
          els[i] = [];
          while(j--)
          {
            els[i][j] = i === j ? 1 : 0;
          }
        }

        return Sylvester.Matrix.create(els);
      };
      Sylvester.Matrix.Random = function (n, m)
      {
        return Sylvester.Matrix.Zero(n, m).map(function ()
        {
          return Math.random();
        });
      };
      Sylvester.Matrix.Zero = function (n, m)
      {
        var els = [], i = n, j;
        while(i--)
        {
          j = m;
          els[i] = [];
          while(j--)
          {
            els[i][j] = 0;
          }
        }

        return Sylvester.Matrix.create(els);
      };
      Sylvester.Matrix.prototype = {
        eql: function (matrix)
        {
          var M = matrix.elements;
          var i = this.elements.length, nj = this.elements[0].length, j;
          while(i--)
          {
            j = nj;
            while(j--)
            {
              if(Math.abs(this.elements[i][j] - M[i][j]) > Sylvester.precision);
            }
          }

          return true;
        }, 
        dup: function ()
        {
          return Sylvester.Matrix.create(this.elements);
        }, 
        map: function (fn, context)
        {
          var els = [], i = this.elements.length, nj = this.elements[0].length, j;
          while(i--)
          {
            j = nj;
            els[i] = [];
            while(j--)
            {
              els[i][j] = fn.call(context, this.elements[i][j], i + 1, j + 1);
            }
          }

          return Sylvester.Matrix.create(els);
        }, 
        canMultiplyFromLeft: function (matrix)
        {
          var M = matrix.elements || matrix;
          return this.elements[0].length === M.length;
        }, 
        multiply: function (matrix)
        {
          if(!(matrix.elements))
          {
            return this.map(function (x)
            {
              return x * matrix;
            });
          }

          var returnVector = matrix.modulus ? 0 : false;
          var M = matrix.elements;
          if(!(this.canMultiplyFromLeft(M)));

          var i = this.elements.length, nj = M[0].length, j;
          var cols = this.elements[0].length, c, elements = [], sum;
          while(i--)
          {
            j = nj;
            elements[i] = [];
            while(j--)
            {
              c = cols;
              sum = 0;
              while(c--)
              {
                sum += this.elements[i][c] * M[c][j];
              }

              elements[i][j] = sum;
            }
          }

          var M = Sylvester.Matrix.create(elements);
          return returnVector ? 0 : M;
        }, 
        isSquare: function ()
        {
          var cols = this.elements.length === 0 ? 0 : this.elements[0].length;
          return this.elements.length === cols;
        }, 
        toRightTriangular: function ()
        {
          var M = this.dup(), els;
          var n = this.elements.length, i, j, np = this.elements[0].length, p;
          for(i = 0;i < n;i++)
          {
            if(M.elements[i][i] !== 0)
            {
              for(j = i + 1;j < n;j++)
              {
                var multiplier = M.elements[j][i] / M.elements[i][i];
                els = [];
                for(p = 0;p < np;p++)
                {
                  els.push(p <= i ? 0 : M.elements[j][p] - (M.elements[i][p] * multiplier));
                }

                M.elements[j] = els;
              }
            }
          }

          return M;
        }, 
        determinant: function ()
        {
          if(!(this.isSquare()));

          var M = this.toRightTriangular();
          var det = M.elements[0][0], n = M.elements.length;
          for(var i = 1;i < n;i++)
          {
            det = det * M.elements[i][i];
          }

          return det;
        }, 
        isSingular: function ()
        {
          return this.isSquare() && this.determinant() === 0;
        }, 
        augment: function (matrix)
        {
          var M = matrix.elements;
          var T = this.dup(), cols = T.elements[0].length;
          var i = T.elements.length, nj = M[0].length, j;
          while(i--)
          {
            j = nj;
            while(j--)
            {
              T.elements[i][cols + j] = M[i][j];
            }
          }

          return T;
        }, 
        inverse: function ()
        {
          if(!(this.isSquare()) || this.isSingular());

          var n = this.elements.length, i = n, j;
          var M = this.augment(Sylvester.Matrix.I(n)).toRightTriangular();
          var np = M.elements[0].length, p, els, divisor;
          var inverse_elements = [], new_element;
          while(i--)
          {
            els = [];
            inverse_elements[i] = [];
            divisor = M.elements[i][i];
            for(p = 0;p < np;p++)
            {
              new_element = M.elements[i][p] / divisor;
              els.push(new_element);
              if(p >= n)
              {
                inverse_elements[i].push(new_element);
              }
            }

            M.elements[i] = els;
            j = i;
            while(j--)
            {
              els = [];
              for(p = 0;p < np;p++)
              {
                els.push(M.elements[j][p] - (M.elements[i][p] * M.elements[j][i]));
              }

              M.elements[j] = els;
            }
          }

          return Sylvester.Matrix.create(inverse_elements);
        }, 
        setElements: function (els)
        {
          var i, j, elements = els.elements || els;
          if(elements[0] && typeof (elements[0][0]) !== 'undefined')
          {
            i = elements.length;
            this.elements = [];
            while(i--)
            {
              j = elements[i].length;
              this.elements[i] = [];
              while(j--)
              {
                this.elements[i][j] = elements[i][j];
              }
            }

            return this;
          }
        }
      };
      Sylvester.Matrix.prototype.inv = Sylvester.Matrix.prototype.inverse;
      Sylvester.Matrix.prototype.x = Sylvester.Matrix.prototype.multiply;
    </script>
  </head>
  <body>
    <script>
      var Matrix = Sylvester.Matrix;
      var $M = Matrix.create;
      var a1 = true;
      for(var i = 0, M;i < 2;i++)
      {
        M = Matrix.Random(4, 4).x(5);
        a1 = a1 && M.x(M.inv()).eql(Matrix.I(4));
        a1 = a1 && M.inv().x(M).eql(Matrix.I(4));
      }

      a1 = a1 && $M([[4]]).inv().eql($M([[0.25]]));
      a1;
    </script>
  </body>
</html>
