<!DOCTYPE html>
<html>
  <head>
    <script>
      var Sylvester = {precision: 0.000001};
      Sylvester.Vector = function ()
      {};
      Sylvester.Vector.create = function (elements)
      {
        var V = new Sylvester.Vector();
        return V.setElements(elements);
      };
      Sylvester.Vector.Random = function (n)
      {
        var elements = [];
        while(n--)
        {
          elements.push(Math.random());
        }

        return Sylvester.Vector.create(elements);
      };
      Sylvester.Vector.Zero = function (n)
      {
        var elements = [];
        while(n--);
        return Sylvester.Vector.create(elements);
      };
      Sylvester.Vector.prototype = {
        modulus: function ()
        {
          return Math.sqrt(this.dot(this));
        }, 
        dup: function ()
        {
          return Sylvester.Vector.create(this.elements);
        }, 
        map: function (fn, context)
        {
          var elements = [];
          this.each(function (x, i)
          {
            elements.push(fn.call(context, x, i));
          });
          return Sylvester.Vector.create(elements);
        }, 
        forEach: function (fn, context)
        {
          var n = this.elements.length;
          for(var i = 0;i < n;i++)
          {
            fn.call(context, this.elements[i], i + 1);
          }
        }, 
        toUnitVector: function ()
        {
          var r = this.modulus();
          return this.map(function (x)
          {
            return x / r;
          });
        }, 
        angleFrom: function (vector)
        {
          var V = vector.elements;
          var n = this.elements.length;
          var dot = 0, mod1 = 0, mod2 = 0;
          this.each(function (x, i)
          {
            dot += x * V[i - 1];
            mod1 += x * x;
            mod2 += V[i - 1] * V[i - 1];
          });
          mod1 = Math.sqrt(mod1);
          mod2 = Math.sqrt(mod2);
          var theta = dot / (mod1 * mod2);
          return Math.acos(theta);
        }, 
        add: function (vector)
        {
          var V = vector.elements;
          return this.map(function (x, i)
          {
            return x + V[i - 1];
          });
        }, 
        multiply: function (k)
        {
          return this.map(function (x)
          {
            return x * k;
          });
        }, 
        dot: function (vector)
        {
          var V = vector.elements;
          var product = 0, n = this.elements.length;
          while(n--)
          {
            product += this.elements[n] * V[n];
          }

          return product;
        }, 
        cross: function (vector)
        {
          var B = vector.elements;
          var A = this.elements;
          return Sylvester.Vector.create([(A[1] * B[2]) - (A[2] * B[1]), (A[2] * B[0]) - (A[0] * B[2]), (A[0] * B[1]) - (A[1] * B[0])]);
        }, 
        to3D: function ()
        {
          var V = this.dup();
          return V;
        }, 
        setElements: function (els)
        {
          this.elements = (els.elements || els).slice();
          return this;
        }
      };
      Sylvester.Vector.prototype.x = Sylvester.Vector.prototype.multiply;
      Sylvester.Vector.prototype.each = Sylvester.Vector.prototype.forEach;
      Sylvester.Vector.i = Sylvester.Vector.create([null, null, null]);
      Sylvester.Vector.j = Sylvester.Vector.create([null, null, null]);
      Sylvester.Vector.k = Sylvester.Vector.create([null, null, null]);
      Sylvester.Line = function ()
      {};
      Sylvester.Line.prototype = {
        eql: function (line)
        {
          return this.isParallelTo(line) && this.contains(line.anchor);
        }, 
        isParallelTo: function (obj)
        {
          var theta = this.direction.angleFrom(obj.direction);
          return Math.abs(theta) <= Sylvester.precision || Math.abs(theta - Math.PI) <= Sylvester.precision;
        }, 
        distanceFrom: function (obj)
        {
          if(obj.direction)
          {
            var A;
          }
          else 
          {
            var P = obj.elements;
            var A = this.anchor.elements, D = this.direction.elements;
            var PA1 = P[0] - A[0], PA2 = P[1] - A[1], PA3 = P[2] - A[2];
            var modPA = Math.sqrt(((PA1 * PA1) + (PA2 * PA2)) + (PA3 * PA3));
            var cosTheta = (((PA1 * D[0]) + (PA2 * D[1])) + (PA3 * D[2])) / modPA;
            var sin2 = 1 - (cosTheta * cosTheta);
            return Math.abs(modPA * Math.sqrt(sin2 < 0 ? 0 : sin2));
          }
        }, 
        contains: function (obj)
        {
          var dist = this.distanceFrom(obj);
          return dist !== null && dist <= Sylvester.precision;
        }, 
        liesIn: function (plane)
        {
          return plane.contains(this);
        }, 
        setVectors: function (anchor, direction)
        {
          anchor = Sylvester.Vector.create(anchor);
          direction = Sylvester.Vector.create(direction);
          var mod = direction.modulus();
          this.anchor = anchor;
          this.direction = Sylvester.Vector.create([direction.elements[0] / mod, direction.elements[1] / mod, direction.elements[2] / mod]);
          return this;
        }
      };
      Sylvester.Line.create = function (anchor, direction)
      {
        var L = new Sylvester.Line();
        return L.setVectors(anchor, direction);
      };
      Sylvester.Line.create(Sylvester.Vector.Zero(3), Sylvester.Vector.i);
      Sylvester.Line.create(Sylvester.Vector.Zero(3), Sylvester.Vector.j);
      Sylvester.Line.create(Sylvester.Vector.Zero(3), Sylvester.Vector.k);
      Sylvester.Matrix = function ()
      {};
      Sylvester.Matrix.create = function (elements)
      {
        var M = new Sylvester.Matrix();
        return M.setElements(elements);
      };
      Sylvester.Matrix.I = function (n)
      {
        var els = [], i = n, j;
        while(i--)
        {
          j = n;
          els[i] = [];
          while(j--)
          {
            els[i][j] = i === j ? 1 : 0;
          }
        }

        return Sylvester.Matrix.create(els);
      };
      Sylvester.Matrix.Zero = function (n, m)
      {
        var els = [], i = n, j;
        while(i--)
        {
          j = m;
          els[i] = [];
          while(j--)
          {
            els[i][j] = 0;
          }
        }

        return Sylvester.Matrix.create(els);
      };
      Sylvester.Matrix.prototype = {
        dup: function ()
        {
          return Sylvester.Matrix.create(this.elements);
        }, 
        isSquare: function ()
        {
          var cols = this.elements.length === 0 ? 0 : this.elements[0].length;
          return this.elements.length === cols;
        }, 
        toRightTriangular: function ()
        {
          var M = this.dup(), els;
          var n = this.elements.length, i, j, np = this.elements[0].length, p;
          for(i = 0;i < n;i++)
          {
            if(M.elements[i][i] === 0)
            {
              for(j = i + 1;j < n;j++)
              {}
            }

            if(M.elements[i][i] !== 0)
            {
              for(j = i + 1;j < n;j++)
              {
                var multiplier = M.elements[j][i] / M.elements[i][i];
                els = [];
                for(p = 0;p < np;p++)
                {
                  els.push(p <= i ? 0 : M.elements[j][p] - (M.elements[i][p] * multiplier));
                }

                M.elements[j] = els;
              }
            }
          }

          return M;
        }, 
        determinant: function ()
        {
          if(!(this.isSquare()));

          var M = this.toRightTriangular();
          var det = M.elements[0][0], n = M.elements.length;
          for(var i = 1;i < n;i++)
          {
            det = det * M.elements[i][i];
          }

          return det;
        }, 
        isSingular: function ()
        {
          return this.isSquare() && this.determinant() === 0;
        }, 
        augment: function (matrix)
        {
          var M = matrix.elements;
          var T = this.dup(), cols = T.elements[0].length;
          var i = T.elements.length, nj = M[0].length, j;
          while(i--)
          {
            j = nj;
            while(j--)
            {
              T.elements[i][cols + j] = M[i][j];
            }
          }

          return T;
        }, 
        inverse: function ()
        {
          if(!(this.isSquare()) || this.isSingular());

          var n = this.elements.length, i = n, j;
          var M = this.augment(Sylvester.Matrix.I(n)).toRightTriangular();
          var np = M.elements[0].length, p, els, divisor;
          var inverse_elements = [], new_element;
          while(i--)
          {
            els = [];
            inverse_elements[i] = [];
            divisor = M.elements[i][i];
            for(p = 0;p < np;p++)
            {
              new_element = M.elements[i][p] / divisor;
              els.push(new_element);
              if(p >= n)
              {
                inverse_elements[i].push(new_element);
              }
            }

            M.elements[i] = els;
            j = i;
            while(j--)
            {
              els = [];
              for(p = 0;p < np;p++)
              {
                els.push(M.elements[j][p] - (M.elements[i][p] * M.elements[j][i]));
              }

              M.elements[j] = els;
            }
          }

          return Sylvester.Matrix.create(inverse_elements);
        }, 
        setElements: function (els)
        {
          var i, j, elements = els.elements || els;
          if(elements[0] && typeof (elements[0][0]) !== 'undefined')
          {
            i = elements.length;
            this.elements = [];
            while(i--)
            {
              j = elements[i].length;
              this.elements[i] = [];
              while(j--)
              {
                this.elements[i][j] = elements[i][j];
              }
            }

            return this;
          }
        }
      };
      Sylvester.Plane = function ()
      {};
      Sylvester.Plane.prototype = {
        isParallelTo: function (obj)
        {
          var theta;
          if(obj.normal)
          {
            theta = this.normal.angleFrom(obj.normal);
            return Math.abs(theta) <= Sylvester.precision || Math.abs(Math.PI - theta) <= Sylvester.precision;
          }
        }, 
        contains: function (obj)
        {
          if(obj.direction)
          {
            return this.contains(obj.anchor) && this.contains(obj.anchor.add(obj.direction));
          }
          else 
          {
            var P = obj.elements;
            var A = this.anchor.elements, N = this.normal.elements;
            var diff = Math.abs(((N[0] * (A[0] - P[0])) + (N[1] * (A[1] - P[1]))) + (N[2] * (A[2] - P[2])));
            return diff <= Sylvester.precision;
          }
        }, 
        intersects: function (obj)
        {
          return !(this.isParallelTo(obj));
        }, 
        intersectionWith: function (obj)
        {
          if(!(this.intersects(obj)));

          if(obj.direction)
          {
            var A, N;
          }
          else if(obj.normal)
          {
            var direction = this.normal.cross(obj.normal).toUnitVector();
            var N = this.normal.elements, A = this.anchor.elements, O = obj.normal.elements, B = obj.anchor.elements;
            var solver = Sylvester.Matrix.Zero(2, 2), i = 0;
            while(solver.isSingular())
            {
              i++;
              solver = Sylvester.Matrix.create([[N[i % 3], N[(i + 1) % 3]], [O[i % 3], O[(i + 1) % 3]]]);
            }

            var inverse = solver.inverse().elements;
            var x = ((N[0] * A[0]) + (N[1] * A[1])) + (N[2] * A[2]);
            var y = ((O[0] * B[0]) + (O[1] * B[1])) + (O[2] * B[2]);
            var intersection = [(inverse[0][0] * x) + (inverse[0][1] * y), (inverse[1][0] * x) + (inverse[1][1] * y)];
            var anchor = [];
            for(var j = 1;j <= 3;j++)
            {
              anchor.push(i === j ? 0 : intersection[(j + ((5 - i) % 3)) % 3]);
            }

            return Sylvester.Line.create(anchor, direction);
          }
        }, 
        setVectors: function (anchor, v1, v2)
        {
          anchor = Sylvester.Vector.create(anchor);
          anchor = anchor.to3D();
          v1 = Sylvester.Vector.create(v1);
          v1 = v1.to3D();
          if(typeof v2 === 'undefined')
          {
            v2 = null;
          }

          var v11 = v1.elements[0], v12 = v1.elements[1], v13 = v1.elements[2];
          var normal, mod;
          if(v2 !== null);
          else 
          {
            mod = Math.sqrt(((v11 * v11) + (v12 * v12)) + (v13 * v13));
            normal = Sylvester.Vector.create([v1.elements[0] / mod, v1.elements[1] / mod, v1.elements[2] / mod]);
          }

          this.anchor = anchor;
          this.normal = normal;
          return this;
        }
      };
      Sylvester.Plane.create = function (anchor, v1, v2)
      {
        var P = new Sylvester.Plane();
        return P.setVectors(anchor, v1, v2);
      };
      var $P;
      Sylvester.Plane.create(Sylvester.Vector.Zero(3), Sylvester.Vector.k);
      Sylvester.Plane.create(Sylvester.Vector.Zero(3), Sylvester.Vector.i);
      Sylvester.Plane.create(Sylvester.Vector.Zero(3), Sylvester.Vector.j);
    </script>
  </head>
  <body>
    <script>
      var Plane = Sylvester.Plane;
      var $P = Plane.create;
      var i, P1, P2, L1, L2, Vector = Sylvester.Vector;
      var a1 = true;
      for(i = 0;i < 2;i++)
      {
        P1 = $P(Vector.create([-50, -50, -50]).add(Vector.Random(3).x(100)), Vector.create([-50, -50, -50]).add(Vector.Random(3).x(100)));
        P2 = $P(Vector.create([-50, -50, -50]).add(Vector.Random(3).x(100)), Vector.create([-50, -50, -50]).add(Vector.Random(3).x(100)));
        if(P1.intersects(P2))
        {
          L1 = P1.intersectionWith(P2);
          L2 = P2.intersectionWith(P1);
          a1 = a1 && L1.eql(L2);
          a1 = a1 && L1.liesIn(P1);
          a1 = a1 && P2.contains(L1);
        }
      }

      a1;
    </script>
  </body>
</html>
