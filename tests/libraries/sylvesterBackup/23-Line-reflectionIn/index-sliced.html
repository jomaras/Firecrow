<!DOCTYPE html>
<html>
  <head>
    <script>
      var Sylvester = {precision: 0.000001};
      Sylvester.Vector = function ()
      {};
      Sylvester.Vector.create = function (elements)
      {
        var V = new Sylvester.Vector();
        return V.setElements(elements);
      };
      Sylvester.Vector.Zero = function (n)
      {
        var elements = [];
        while(n--)
        {
          elements.push(0);
        }

        return Sylvester.Vector.create(elements);
      };
      Sylvester.Vector.prototype = {
        modulus: function ()
        {
          return Math.sqrt(this.dot(this));
        }, 
        dup: function ()
        {
          return Sylvester.Vector.create(this.elements);
        }, 
        map: function (fn, context)
        {
          var elements = [];
          this.each(function (x, i)
          {
            elements.push(fn.call(context, x, i));
          });
          return Sylvester.Vector.create(elements);
        }, 
        forEach: function (fn, context)
        {
          var n = this.elements.length;
          for(var i = 0;i < n;i++)
          {
            fn.call(context, this.elements[i], i + 1);
          }
        }, 
        angleFrom: function (vector)
        {
          var V = vector.elements;
          var n = this.elements.length;
          var dot = 0, mod1 = 0, mod2 = 0;
          this.each(function (x, i)
          {
            dot += x * V[i - 1];
            mod1 += x * x;
            mod2 += V[i - 1] * V[i - 1];
          });
          mod1 = Math.sqrt(mod1);
          mod2 = Math.sqrt(mod2);
          var theta = dot / (mod1 * mod2);
          return Math.acos(theta);
        }, 
        multiply: function (k)
        {
          return this.map(function (x)
          {
            return x * k;
          });
        }, 
        dot: function (vector)
        {
          var V = vector.elements;
          var product = 0, n = this.elements.length;
          while(n--)
          {
            product += this.elements[n] * V[n];
          }

          return product;
        }, 
        reflectionIn: function (obj)
        {
          if(obj.anchor)
          {
            var P = this.elements.slice();
            var C = obj.pointClosestTo(P).elements;
            return Sylvester.Vector.create([C[0] + (C[0] - P[0]), C[1] + (C[1] - P[1]), C[2] + (C[2] - (P[2] || 0))]);
          }
          else 
          {
            var Q = obj.elements || obj;
            return this.map(function (x, i)
            {
              return Q[i - 1] + (Q[i - 1] - x);
            });
          }
        }, 
        to3D: function ()
        {
          var V = this.dup();
          return V;
        }, 
        setElements: function (els)
        {
          this.elements = (els.elements || els).slice();
          return this;
        }
      };
      Sylvester.Vector.prototype.x = Sylvester.Vector.prototype.multiply;
      Sylvester.Vector.prototype.each = Sylvester.Vector.prototype.forEach;
      Sylvester.Vector.i = Sylvester.Vector.create([1, 0, 0]);
      Sylvester.Vector.j = Sylvester.Vector.create([null, null, null]);
      Sylvester.Vector.k = Sylvester.Vector.create([0, 0, 1]);
      Sylvester.Line = function ()
      {};
      Sylvester.Line.prototype = {
        eql: function (line)
        {
          return this.isParallelTo(line) && this.contains(line.anchor);
        }, 
        dup: function ()
        {
          return Sylvester.Line.create(this.anchor, this.direction);
        }, 
        isParallelTo: function (obj)
        {
          var theta = this.direction.angleFrom(obj.direction);
          return Math.abs(theta) <= Sylvester.precision || Math.abs(theta - Math.PI) <= Sylvester.precision;
        }, 
        distanceFrom: function (obj)
        {
          if(obj.direction)
          {
            var A;
          }
          else 
          {
            var P = obj.elements || obj;
            var A = this.anchor.elements, D = this.direction.elements;
            var PA1 = P[0] - A[0], PA2 = P[1] - A[1], PA3 = (P[2] || 0) - A[2];
            var modPA = Math.sqrt(((PA1 * PA1) + (PA2 * PA2)) + (PA3 * PA3));
            if(modPA === 0)
            return 0;

            var cosTheta = (((PA1 * D[0]) + (PA2 * D[1])) + (PA3 * D[2])) / modPA;
            var sin2 = 1 - (cosTheta * cosTheta);
            return Math.abs(modPA * Math.sqrt(sin2 < 0 ? 0 : sin2));
          }
        }, 
        contains: function (obj)
        {
          var dist = this.distanceFrom(obj);
          return dist !== null && dist <= Sylvester.precision;
        }, 
        pointClosestTo: function (obj)
        {
          if(obj.start)
          {
            var P;
          }
          else if(obj.direction);
          else 
          {
            var P = obj.elements;
            if(this.contains(P))
            {
              return Sylvester.Vector.create(P);
            }
          }
        }, 
        rotate: function (t, line)
        {
          var R = Sylvester.Matrix.Rotation(t, line.direction).elements;
          var C = line.pointClosestTo(this.anchor).elements;
          var A = this.anchor.elements, D = this.direction.elements;
          var C1 = C[0], C2 = C[1], C3 = C[2], A1 = A[0], A2 = A[1], A3 = A[2];
          var x = A1 - C1, y = A2 - C2, z = A3 - C3;
          return Sylvester.Line.create([((C1 + (R[0][0] * x)) + (R[0][1] * y)) + (R[0][2] * z), ((C2 + (R[1][0] * x)) + (R[1][1] * y)) + (R[1][2] * z), ((C3 + (R[2][0] * x)) + (R[2][1] * y)) + (R[2][2] * z)], [((R[0][0] * D[0]) + (R[0][1] * D[1])) + (R[0][2] * D[2]), ((R[1][0] * D[0]) + (R[1][1] * D[1])) + (R[1][2] * D[2]), ((R[2][0] * D[0]) + (R[2][1] * D[1])) + (R[2][2] * D[2])]);
        }, 
        reflectionIn: function (obj)
        {
          if(obj.normal)
          {
            var A = this.anchor.elements, D = this.direction.elements;
            var A1 = A[0], A2 = A[1], A3 = A[2], D1 = D[0], D2 = D[1], D3 = D[2];
            var newA = this.anchor.reflectionIn(obj).elements;
            var AD1 = A1 + D1, AD2 = A2 + D2, AD3 = A3 + D3;
            var Q = obj.pointClosestTo([AD1, AD2, AD3]).elements;
            var newD = [(Q[0] + (Q[0] - AD1)) - newA[0], (Q[1] + (Q[1] - AD2)) - newA[1], (Q[2] + (Q[2] - AD3)) - newA[2]];
            return Sylvester.Line.create(newA, newD);
          }
          else if(obj.direction)
          {
            return this.rotate(Math.PI, obj);
          }
          else 
          {
            var P = obj.elements || obj;
            return Sylvester.Line.create(this.anchor.reflectionIn([P[0], P[1], P[2] || 0]), this.direction);
          }
        }, 
        setVectors: function (anchor, direction)
        {
          anchor = Sylvester.Vector.create(anchor);
          direction = Sylvester.Vector.create(direction);
          if(anchor.elements.length === 2)
          {
            anchor.elements.push(0);
          }

          if(direction.elements.length === 2)
          {
            direction.elements.push(0);
          }

          var mod = direction.modulus();
          this.anchor = anchor;
          this.direction = Sylvester.Vector.create([direction.elements[0] / mod, direction.elements[1] / mod, direction.elements[2] / mod]);
          return this;
        }
      };
      Sylvester.Line.create = function (anchor, direction)
      {
        var L = new Sylvester.Line();
        return L.setVectors(anchor, direction);
      };
      var $L = Sylvester.Line.create;
      Sylvester.Line.X = Sylvester.Line.create(Sylvester.Vector.Zero(3), Sylvester.Vector.i);
      Sylvester.Line.create(Sylvester.Vector.Zero(3), Sylvester.Vector.j);
      Sylvester.Line.Z = Sylvester.Line.create(Sylvester.Vector.Zero(3), Sylvester.Vector.k);
      Sylvester.Matrix = function ()
      {};
      Sylvester.Matrix.create = function (elements)
      {
        var M = new Sylvester.Matrix();
        return M.setElements(elements);
      };
      Sylvester.Matrix.Rotation = function (theta, a)
      {
        var axis = a.dup();
        var mod = axis.modulus();
        var x = axis.elements[0] / mod, y = axis.elements[1] / mod, z = axis.elements[2] / mod;
        var s = Math.sin(theta), c = Math.cos(theta), t = 1 - c;
        return Sylvester.Matrix.create([[((t * x) * x) + c, ((t * x) * y) - (s * z), ((t * x) * z) + (s * y)], [((t * x) * y) + (s * z), ((t * y) * y) + c, ((t * y) * z) - (s * x)], [((t * x) * z) - (s * y), ((t * y) * z) + (s * x), ((t * z) * z) + c]]);
      };
      Sylvester.Matrix.prototype = {
        setElements: function (els)
        {
          var i, j, elements = els.elements || els;
          if(elements[0] && typeof (elements[0][0]) !== 'undefined')
          {
            i = elements.length;
            this.elements = [];
            while(i--)
            {
              j = elements[i].length;
              this.elements[i] = [];
              while(j--)
              {
                this.elements[i][j] = elements[i][j];
              }
            }

            return this;
          }
        }
      };
      Sylvester.Plane = function ()
      {};
      Sylvester.Plane.prototype = {
        pointClosestTo: function (point)
        {
          var P = point.elements || point;
          var A = this.anchor.elements, N = this.normal.elements;
          var dot = (((A[0] - P[0]) * N[0]) + ((A[1] - P[1]) * N[1])) + ((A[2] - (P[2] || 0)) * N[2]);
          return Sylvester.Vector.create([P[0] + (N[0] * dot), P[1] + (N[1] * dot), (P[2] || 0) + (N[2] * dot)]);
        }, 
        setVectors: function (anchor, v1, v2)
        {
          anchor = Sylvester.Vector.create(anchor);
          anchor = anchor.to3D();
          v1 = Sylvester.Vector.create(v1);
          v1 = v1.to3D();
          if(typeof v2 === 'undefined')
          {
            v2 = null;
          }

          var v11 = v1.elements[0], v12 = v1.elements[1], v13 = v1.elements[2];
          var normal, mod;
          if(v2 !== null);
          else 
          {
            mod = Math.sqrt(((v11 * v11) + (v12 * v12)) + (v13 * v13));
            normal = Sylvester.Vector.create([v1.elements[0] / mod, v1.elements[1] / mod, v1.elements[2] / mod]);
          }

          this.anchor = anchor;
          this.normal = normal;
          return this;
        }
      };
      Sylvester.Plane.create = function (anchor, v1, v2)
      {
        var P = new Sylvester.Plane();
        return P.setVectors(anchor, v1, v2);
      };
      Sylvester.Plane.create(Sylvester.Vector.Zero(3), Sylvester.Vector.k);
      Sylvester.Plane.create(Sylvester.Vector.Zero(3), Sylvester.Vector.i);
      Sylvester.Plane.create(Sylvester.Vector.Zero(3), Sylvester.Vector.j);
    </script>
  </head>
  <body>
    <script>
      var Line = Sylvester.Line;
      var a1 = Line.Z.reflectionIn([28, 0, -12]).eql($L([56, 0, 0], Sylvester.Vector.k.x(-1)));
      var a2 = Line.X.reflectionIn($L([0, 0, 0], [1, 0, 1])).eql(Line.Z);
      var L1 = Line.X.dup();
      var L2 = $L([5, 0, 0], Sylvester.Vector.k);
      var a3 = L1.reflectionIn(Sylvester.Plane.create([5, 0, 0], [1, 0, 1])).eql(L2);
      var a4 = L2.reflectionIn(Sylvester.Plane.create([5, 0, 0], [1, 0, 1])).eql(L1);
      var a5 = $L([-4, 3], [0, -1]).reflectionIn(Sylvester.Vector.create([0, 0])).eql($L([4, 100], [0, 4]));
      a1;
      a2;
      a3;
      a4;
      a5;
    </script>
  </body>
</html>
