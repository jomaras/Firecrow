- Make it work for other pages!!
   - problem with
        - nodeID: 46899 ("opts.animIn") - does not include the definition of animIn for some reason !?
        - includes the assignement:  "opts.animIn = $.extend({}, opts.original.animIn)"   nodeId 43583 (continue here)
        + problem with i and i++ being arguments in a call expression: the argument values would be determined in the end, which means that argument i would have the value
        + return Sizzle(expr, null, null, [node]).length in Sizzle.matchesSelector (return from Sizzle is not included); but it does not seem that Sizzle(expr, null).. is even necessary
        + the problem is that [node] is necessary -> this probably causes the inclusion of everything in the call expressions
        ! -> (but the problem is including the property .length in the dependency postprocessor)
   + problem with thisCache[jQuery.camelCase(name)];
        (there is no connection to thisCache and jQuery.camelCase is "imporant") - study more!
   + the problem was with creating dependencies between internal function call expressions and arguments (arg -> call expression, i don't know why i even did that..)

- there is an overall problem of dependencyPostprocessor - that part should not be there

+ dependency traversal algorithm in node.js
    + for finding groups, maybe don't go through all dependencies again, but only forward till it is ok, and backward till it is ok

- Make automatic testing for libraries
    - gauss
    - medialize (has errors - fix)
        - Guide: run C:\GitWebStorm\Firecrow\tests\libraries\medialize\tests\debugMedialize.html (and study errors)
        - it seems that i broke something when i added automatic toValue and toString invocation (check it by creating a smaller test suite behaving the same way)
    - sylvester
------------------------------------------------------------------------------------------------------------------------
NEXT:

    - continue debugging - it seems that the addition of :not([origin="reuse"]) does not work for complex selectors
    - on a test example implement, after a slicing criteria is processed,
      create a map of all constructs included in the slice (i'm not sure how detailed it has to be, at least on memberExpression, callExpression, identifiers levels)
      then group them by functions, and see what could potentially cause problems.
      Then in a situation where it causes problems - we should again traverse.. this could lead to fixed point iteration algorithms

    - i think the problem can occur anywhere.. but the most serious manifestations are in functions and maybe loops
    - this will require more post-processing in the end.
    - for a slicing criteria, make a map of all included code constructs and max dependencies which have added them
    - once we have performed slicing based one each individual criteria, we have to take care of the union of dynamic slices problem
    - it might not even be necessary to track which were included by which; just again, for each included code construct,
      go through all unprocessed dependencies - i'm not sure if this will break anything; maybe not even all, but the ones between the
      edges that have caused the inclusion? So i would have to keep track of indexes of the edges that have caused the inclusion of a code construct
      I can dismiss all dependencies after the last one that has caused the inclusion. But probably not all are necessary;
    - the problem is that i'm not sure if this is worth only for call expressions. If it is, this process should only be performed for code constructs
      whose call expression is also included; a not for all dependencies

    - yes, it should only be if they depend on a call expression that gets included.. So maybe i should
      somehow keep a set of dependencies between every exprssion and the parent call expression
      When creating a dependency to the call expression, log in the execution summary, or somewhere
      that there is a dependency, then when processing included constructs, see if t
      we should see if this dependency comes to a call expression that has been included, if
      it is - then traverse it

      ! create a mapping between an executed call expression and all dependencies created in the execution, so
      that each dependency can be associated with an executed call expression. Then, for each included expression,
      find a data-dependency that leads an unicluded construct, and traverse it

      - log a connection between both the currently created dependency and the call expression and the last created dependnecy
      - that way i know exactly where it is bound to, than i can traverse only the interesting connections, and then i check only
        the dependencies - which ones?

    - possibly to go the other way -> from profiling, remove things that for sure will not be included
    - try to find these problems when unioning

    - i think i could remove the way i handled return expressions in that case

    - tried with differentiating between pure data-dependencies and the rest, but it didn't work on it's own

    - another idea: while evaluating the application, keep a list of evaluated member and call expressions
      (these are the ones that can cause null exceptions) along with the index of the last dependency created from them;
      add this after the command has been evaluated; then when the first phases of marking are done,
      go through the list and for each included element check whether there is an untraversed (pure-data) dependency
      whose index is less than the stored dependency.


20-mooToolsPlay
 - Continue executing debugTestPages and 20-mooTools;
 - the same problem as with 01c


*******Reuse
- add options to remove outside HTML nodes
- fix the CSS Specificity problem

- The problem comes from this:
          .or div { color:green}
          .container { color: red; }
      <div class ="or">
          <div class="container">
              Test -> Will be red (the problem is that in the original case it was only "div" which is weaker than ".container", so maybe the solution would be to also expand the ".container")
              //All rules should be traversed and expanded: .container -> .or .container, .or.container
          </div>
      </div>


- 01-16_01 - 137 sec, OK
- 02-20_01 - 569 sec, OK
- 03-21_01 - 218 sec, OK

- 04-15_12 - 31 sec,

- 05-06_02 -
- 06-11_02 -
- 07-21_02 -

- 08-06_03 -
- 09-08_03 -
- 10-21_03 -

- 11-21_04 -
- 12-06_04 -
- 13-08_04 -
- 14-01b_04
- 15-01c_04
- 16-02a_04
- 17-02b_04
- 18-03_04
- 19-11_04
- 20-12_04
  21-16_04
  22-19_04
  23-20_04
  24-21_04
  25-02a_05
  26-02b_05
  27-03_05
  28-04_05
  29-06_05
  30-08_05
  31-11_05
  32-16_05
  33-20_05
  34-21_05
  36-01c_06
  37-02a_06
  38-02b_06
  39-11_06
  40-15_06
  41-19_06
  42-21_06
  43-01c_07
  44-02a_07
  45-02b_07
  46-05_07
  47-06_07
  48-11_07
  49-12_07
  50-15_07
  51-19_07
  52-20_07
  53-21_07
  54-01b_08
  55-01c_08
  56-02b_08
  57-03_08
  58_04_08
  59_06_08
  60-11_08
  61-15_08
  62-19_08
  63-20_08
  63-21_08



*******UI Controls:
 - 01a - OK; F: 140 113; S: 102 979;
 - 01b - OK; F: 194 325; S: 87 510;
 - 01c - OK; F: 181 796; S: 136 277;
 - 02a - OK; F: 192 599; S: 101 255;
 - 02b - OK; F: 140 567; S: 76 935;
 - 03 -  OK; F: 86 088;  S: 38 036;
 - 04 -  OK; F: 107 054; S: 70 892;
 - 05 - OK;  F: 137 596; S: 99 555;
 - 06 - OK;
 - 07 - OK  F: 64 583; S: 35 072;
 - 08 - OK  F: 34 040; S: 17 200;
 - 09 - NOK F: 176 179; S:139 802   (fixHook in fix: function(event)) !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 - 10 - OK  F: 193 200; S:
 - 11 - OK
 - 12 - OK
 - 13 - OK
 - 14 - NOK
 - 15 - OK
 - 16 - OK
 - 17 - OK
 - 18 - NOK
 - 19 - OK
 - 20 - OK
 - 21 -
         node id: 23619 -> (new Fx.Slide('login')).hide
         node id: 23620 -> (new Fx.Slide('login')) -> tu je neki problem
         marginTop ne postavi dobro za #top

******************* Libraries
- gauss OK
- medialize - not running
- sylvester - 61-Plane-containement problem


******************* Suggestions
- maybe visualize the relationships between full, profiled and extracted code (bars similar to the ones used in Reuse-Driven Interprocedural Slicing)
------------------------------------------------------------------------------------------------------------------------
Testing TO-DO list:
-


- smaller, but more effective test suite
- delete all unnecessary tests
- enable all tests!
- make one unified test that tests both debugSlicing and debugDOM tests

To Do List:

- eval
- ES5 stuff (Object.defineProperty, etc.), canvas
- refactor

***********************************************************************************************************************
- Add the extraction wizard
    - offer simple download
    - offer simple profiling
    - offer extraction
- classList.add; remove...
***********************************************************************************************************************
- Detecting conflicts on dependency graphs
