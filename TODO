- Make it work for other pages!!
   - problem with
        - nodeID: 46899 ("opts.animIn") - does not include the definition of animIn for some reason !?
        - includes the assignement:  "opts.animIn = $.extend({}, opts.original.animIn)"   nodeId 43583 (continue here)
        + problem with i and i++ being arguments in a call expression: the argument values would be determined in the end, which means that argument i would have the value
        + return Sizzle(expr, null, null, [node]).length in Sizzle.matchesSelector (return from Sizzle is not included); but it does not seem that Sizzle(expr, null).. is even necessary
        + the problem is that [node] is necessary -> this probably causes the inclusion of everything in the call expressions
        ! -> (but the problem is including the property .length in the dependency postprocessor)
   + problem with thisCache[jQuery.camelCase(name)];
        (there is no connection to thisCache and jQuery.camelCase is "imporant") - study more!
   + the problem was with creating dependencies between internal function call expressions and arguments (arg -> call expression, i don't know why i even did that..)

- there is an overall problem of dependencyPostprocessor - that part should not be there

+ dependency traversal algorithm in node.js
    + for finding groups, maybe don't go through all dependencies again, but only forward till it is ok, and backward till it is ok

- Make automatic testing for libraries
    - gauss
    - medialize (has errors - fix)
        - Guide: run C:\GitWebStorm\Firecrow\tests\libraries\medialize\tests\debugMedialize.html (and study errors)
        - it seems that i broke something when i added automatic toValue and toString invocation (check it by creating a smaller test suite behaving the same way)
    - sylvester


------------------------------------------------------------------------------------------------------------------------
NEXT:
    - on a test example implement, after a slicing criteria is processed,
      create a map of all constructs included in the slice (i'm not sure how detailed it has to be, at least on memberExpression, callExpression, identifiers levels)
      then group them by functions, and see what could potentially cause problems.
      Then in a situation where it causes problems - we should again traverse.. this could lead to fixed point iteration algorithms

    - i think the problem can occur anywhere.. but the most serious manifestations are in functions and maybe loops
    - this will require more post-processing in the end.
    - for a slicing criteria, make a map of all included code constructs and max dependencies which have added them
    - once we have performed slicing based one each individual criteria, we have to take care of the union of dynamic slices problem
    - it might not even be necessary to track which were included by which; just again, for each included code construct,
      go through all unprocessed dependencies - i'm not sure if this will break anything; maybe not even all, but the ones between the
      edges that have caused the inclusion? So i would have to keep track of indexes of the edges that have caused the inclusion of a code construct
      I can dismiss all dependencies after the last one that has caused the inclusion. But probably not all are necessary;
    - the problem is that i'm not sure if this is worth only for call expressions. If it is, this process should only be performed for code constructs
      whose call expression is also included; a not for all dependencies

    - yes, it should only be if they depend on a call expression that gets included.. So maybe i should
      somehow keep a set of dependencies between every exprssion and the parent call expression
      When creating a dependency to the call expression, log in the execution summary, or somewhere
      that there is a dependency, then when processing included constructs, see if t
      we should see if this dependency comes to a call expression that has been included, if
      it is - then traverse it

      ! create a mapping between an executed call expression and all dependencies created in the execution, so
      that each dependency can be associated with an executed call expression. Then, for each included expression,
      find a data-dependency that leads an unicluded construct, and traverse it

      - log a connection between both the currently created dependency and the call expression and the last created dependnecy
      - that way i know exactly where it is bound to, than i can traverse only the interesting connections, and then i check only
        the dependencies - which ones?

    - possibly to go the other way -> from profiling, remove things that for sure will not be included
    - try to find these problems when unioning

    - i think i could remove the way i handled return expressions in that case

    - tried with differentiating between pure data-dependencies and the rest, but it didn't work on it's own

    - another idea: while evaluating the application, keep a list of evaluated member and call expressions
      (these are the ones that can cause null exceptions) along with the index of the last dependency created from them;
      add this after the command has been evaluated; then when the first phases of marking are done,
      go through the list and for each included element check whether there is an untraversed (pure-data) dependency
      whose index is less than the stored dependency.




20-mooToolsPlay
 - Continue executing debugTestPages and 20-mooTools;
 - the same problem as with 01c


*******UI Controls:
 - 01a - OK; F: 140 113; S: 102 979;
 - 01b - NOK; F: 194 325; S: 87 510;  (produces an error, but works, a different error - now a problem with expressions of )
 - 01c - NOK; F: 181 796; S: 136 277; (error on opts.animIn.left..)
    - it seems that it takes a different path than the browser (the problem is the dependency from the node with the id 46899
    - it creates a dependency to a construct which is not executed in the original execution at that point)
    - ln450 ass buildOptions()
    - ln640 ass resetState()
    - ln1197 causes error
    - It seems that this is a fundamental problem... :-/
    - let's say that we have two slicing criteria that include a function call
    func example() {
        $cont.css('overflow', 'none'); -> this one gets included for the first slicing criteria
        opts.animIn.left = 0; -> this one for the second
    }

    And let's say that we only have two calls to this function
    the first call is mapped to the first slicing criteria and includes the first line
    the second call to the second slicing criteria and includes the first and the second line
    The problem is that opts.animIn object is created after the first call (and would not be included in the
    first slice, but since it is included from the second slice, the code gets executed, and throws an error)

    I think it is progressing ¨- the problem now is that it gets stuck on traversing the same dependencies


 - 02a - OK; F: 192 599; S: 101 255; (error when generating text)
 - 02b - NOK; F: 140 567; S: 76 935;
 - 03 -  OK; F: 86 088;  S: 38 036;
 - 04 -  OK; F: 107 054; S: 70 892;
    - there is a problem with a return statement in the remove: function()
    - the one in the if statement - maybe if an if condition is included when traversing return dependencies
    - if it also contains a return statement, include that return statement (but not sure about the return expression value) - i've done it in the dependency postprocessor
      but i'm not sure if it is a good place to do it
    - doesn't terminate

 - 05 - OK;  F: 137 596; S: 99 555;
 - 06 - OK;
 - 07 - OK  F: 64 583; S: 35 072 (NOK - $(window).height() not working in FF) - važan je i argument
   func(a).test({a:b()}) -> important func(a) and b();

 - 08 - OK  F: 34 040; S: 17 200
 - 09 - NOK F: 176 179; S:139 802   (fixHook in fix: function(event))
 - 10 - OK  F: 193 200; S:

******************* Libraries
- gauss OK
- medialize - not running
- sylvester - 61-Plane-containement problem


******************* Suggestions
- maybe visualize the relationships between full, profiled and extracted code (bars similar to the ones used in Reuse-Driven Interprocedural Slicing)
------------------------------------------------------------------------------------------------------------------------
Testing TO-DO list:
-


- smaller, but more effective test suite
- delete all unnecessary tests
- enable all tests!
- make one unified test that tests both debugSlicing and debugDOM tests

To Do List:

- eval
- ES5 stuff (Object.defineProperty, etc.), canvas
- refactor

***********************************************************************************************************************
- Add the extraction wizard
    - offer simple download
    - offer simple profiling
    - offer extraction
- classList.add; remove...
***********************************************************************************************************************
- Detecting conflicts on dependency graphs
